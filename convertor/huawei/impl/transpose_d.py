#!/usr/bin/env python
# -*- coding:utf-8 -*-
"""
Copyright (C) 2019. Huawei Technologies Co., Ltd. All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the Apache License Version 2.0.You may not use this file
except in compliance with the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
Apache License for more details at
http://www.apache.org/licenses/LICENSE-2.0

transpose_d
"""
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import json
import operator
import os
from functools import reduce as functools_reduce

from te import platform as cce
from te.platform import insn_cmd
from te import tvm
from te.platform.cce_build import build_config
import te.platform.cce_params as cce_params
from topi.cce import util

# General limitation of the size for input shape: 2**31 - 1
SHAPE_SIZE_LIMIT = 2147483647
# available ub size
UB_SIZE_B = cce.cce_conf.get_soc_spec(cce.cce_conf.UB_SIZE)
# available number of cores
AICORE_NUM = cce.cce_conf.get_soc_spec(cce.cce_conf.CORE_NUM)


# pylint: disable=locally-disabled,too-many-lines
def _get_factor(ele_zero, ele_cnt, total_ele):
    """
    get split factor for _tilling_one_axis function

    Parameters
    ----------
    ele_zero: int
        the number of shape's first dimension elements
    ele_cnt: int
        the number of all elements
    total_ele: int
        the number of total elements in UB

    Returns
    -------
    split_factor: int
        the factor used when tiling the target axis
    """
    split_factor = 1
    for i in reversed(list(range(1, ele_zero))):
        if i*ele_cnt <= total_ele:
            split_factor = i
            break

    return split_factor


def _get_count_bigger_one(shape):
    """
    get the count of elements bigger than one

    """
    count = 0
    for item in shape:
        if item > 1:
            count += 1

    return count


def _tilling_axis_not_last(shape, dtype):
    """
    calculate the split parameters according to different shapes
    for last axis not changed

    Parameters
    ----------
    shape: tuple
        shape of tensor
    dtype: str
        the data type

    Returns
    -------
    split_axis: int
        the target axis that is used for tiling the tensor to find
    split_factor: int
        the factor used when tiling the target axis
    """
    ub_size_bytes = UB_SIZE_B - 1*1024
    # 8 bit = 1byte, '8' below for this reason
    dtype_bytes_size = cce.cce_intrin.get_bit_len(dtype) // 8
    # 32 means one block size(32 Bytes),
    # divide by 32 to get the numbers of data that
    # can be stored in one block.
    flag = 32 // dtype_bytes_size
    element_new = ((shape[-1] + flag - 1) // flag)*flag
    shape_new = []
    for i in shape:
        shape_new.append(i)
    shape_new[-1] = int(element_new)
    total_ele = ub_size_bytes // dtype_bytes_size
    split_axis = 0
    split_factor = 1

    for i, item in enumerate(shape):
        ele_cnt = functools_reduce(lambda x, y: x*y, shape_new[i:])
        if ele_cnt <= total_ele:
            split_axis = i - 1
            split_factor = total_ele // ele_cnt
            break
        elif i == len(shape) - 1:
            if len(shape) == 1:
                split_axis = 0
                split_factor = _get_factor(shape[0], 1, total_ele)
            else:
                split_axis = i
                split_factor = total_ele
            break

    if split_axis < 0:
        split_axis = 0
        split_factor = shape[0]

    if shape[len(shape) - 1] == 1:
        count = _get_count_bigger_one(shape)
        if count > 1:
            for i, item in enumerate(reversed(shape)):
                if item > 1:
                    flag = i
                    break
            if split_axis != len(shape) - flag - 1:
                split_axis = len(shape) - flag - 1
                split_factor = shape[split_axis]

    return split_axis, split_factor


def _tilling_axis_last(shape, dtype):
    """
    calculate the split parameters according to different shapes
    for last axis changed

    Parameters
    ----------
    shape: tuple
        shape of tensor
    dtype: str
        the data type

    Returns
    -------
    split_axis: int
        the target axis that is used for tiling the tensor to find
    split_factor: int
        the factor used when tiling the target axis
    """
    ub_size_bytes = UB_SIZE_B - 1*1024
    dtype_bytes_size = cce.cce_intrin.get_bit_len(dtype) // 8
    dtype_bytes_size_fp16 = cce.cce_intrin.get_bit_len("float16") // 8
    if dtype == "float16" or dtype == "int16" or dtype == "uint16":
        total_ele = ub_size_bytes // dtype_bytes_size
    elif dtype == "int8" or dtype == "uint8"\
            or dtype == "int32" or dtype == "float32":
        total_ele = ub_size_bytes // (dtype_bytes_size + dtype_bytes_size_fp16)

    flag = 32 // dtype_bytes_size
    element_new = ((shape[-1] + flag - 1) // flag)*flag
    shape_new = []
    for i in shape:
        shape_new.append(i)
    shape_new[-1] = int(element_new)
    split_axis = 0
    split_factor = 1

    for i, _ in enumerate(shape):
        ele_cnt = functools_reduce(lambda x, y: x*y, shape_new[i:])
        if ele_cnt <= total_ele:
            split_axis = i - 1
            split_factor = total_ele // ele_cnt
            break
        elif i == len(shape) - 1:
            split_axis = i
            split_factor = total_ele
            break

    if split_axis < 0:
        split_axis = 0
        split_factor = shape[0]

    return split_axis, split_factor


def _get_factor_multi_core(ele_zero, ele_cnt, total_ele, no_remainder):
    """
    get split factor for _tilling_axis_multi_core function

    Parameters
    ----------
    ele_zero: int
        the number of shape's first dimension elements
    ele_cnt: int
        the number of all elements
    total_ele: int
        the number of total elements in UB
    no_remainder: bool
        when split_axis == 0,
        the value of shape[0] whether divided by split_factor without remainder.

    Returns
    -------
    split_factor: int
        the factor used when tiling the target axis
    """
    split_factor = 1
    if no_remainder:
        for i in reversed(list(range(1, ele_zero))):
            if ele_zero % i == 0 and i*ele_cnt <= total_ele:
                split_factor = i
                break
    else:
        for i in reversed(list(range(1, ele_zero))):
            if i*ele_cnt <= total_ele:
                split_factor = i
                break

    return split_factor


# pylint: disable=locally-disabled, too-many-locals, too-many-branches
def _tilling_axis_multi_core_fuse(shape, dtype):
    """
    calculate the split parameters according to different shapes
     for multi core scene

    Parameters
    ----------
    shape: tuple
        shape of tensor
    dtype: str
        the data type

    Returns
    -------
    split_axis: int
        the target axis that is used for tiling the tensor to find
    split_factor: int
        the factor used when tiling the target axis
    """
    ub_size_bytes = UB_SIZE_B - 1*1024
    dtype_bytes_size = cce.cce_intrin.get_bit_len(dtype) // 8
    flag = 32 // dtype_bytes_size
    element_new = ((shape[-1] + flag - 1) // flag)*flag
    shape_new = []
    for i in shape:
        shape_new.append(i)
    shape_new[-1] = int(element_new)

    total_ele = ub_size_bytes // dtype_bytes_size
    split_axis = 0
    split_factor = 1

    for i, _ in enumerate(shape):
        ele_cnt = functools_reduce(lambda x, y: x*y, shape_new[i:])
        if ele_cnt <= total_ele:
            split_axis = i - 1
            split_factor = total_ele // ele_cnt
            if split_axis >= 0:
                for j in reversed(list(range(1, split_factor))):
                    if shape[split_axis] % j == 0:
                        split_factor = j
                        break
            break
        elif i == len(shape) - 1:
            split_axis = i
            split_factor = total_ele

    if split_axis < 0:
        split_axis = 0
        split_factor = shape[0]

    device_core_num = AICORE_NUM
    shape_ele = functools_reduce(lambda x, y: x * y, shape[:])
    if split_axis == 0 and split_factor == shape[0] and device_core_num >= 2\
            and shape_ele >= (2 * flag):
        if shape[0] >= (2 * flag):
            split_factor = shape[0] // 2
        elif len(shape) >= 2:
            loc_more = len(shape) - 1
            for i, value in enumerate(shape):
                if value >= 2:
                    loc_more = i
                    break
            current_ele = functools_reduce(lambda x, y: x * y, shape[loc_more:])
            if current_ele >= (2 * flag):
                split_axis = loc_more
                split_factor = shape[split_axis] // 2

    return split_axis, split_factor


def _get_perm_shape(shape, perm):
    """
    get new shape of transposed tensor

    Parameters
    ----------
    shape: list or tuple
        shape of tensor
    perm: list or tuple
        the data type

    Returns
    -------
    shape_new_tuple: tuple
        the new shape of transposed tensor
    """
    shape_new = []
    for i in perm:
        shape_new.append(shape[i])

    return shape_new


def _check_params(shape, perm, dtype, kernel_name):
    """
    check the parameters including shape, perm, dtype and kernel_name

    Parameters
    ----------
    shape: list or tuple
        shape of tensor
    perm: list or tuple
        permutation of the dimension of tensor
    dtype: str
        the data type
    kernel_name: str
        cce kernel name, default value is "cce_transpose"

    Returns
    -------
    None
    """
    util.check_kernel_name(kernel_name)
    util.check_shape_rule(shape)
    limit = SHAPE_SIZE_LIMIT // 2
    util.check_shape_size(shape, limit)
    len_shape = len(shape)
    if len(shape) != len(perm):
        raise RuntimeError(
            "length of perm must be equal to the length of shape")

    list_range = list(range(len_shape))
    list_perm = list(perm[:])
    list_perm.sort()
    if operator.ne(list_range, list_perm):
        raise RuntimeError("value of perm is wrong")

    check_list = ("int8", "int16", "int32", "int64",
                  "uint8", "uint16", "uint32", "uint64",
                  "float16", "float32")
    util.check_dtype_rule(dtype, check_list)


def _add_last_axis(shape, perm, dtype):
    """
    check whether the last axis needs to be added

    """
    len_shape = len(shape)
    if perm[len_shape - 1] != len_shape - 1:
        if dtype == "int64" or dtype == "uint32" or dtype == "uint64"\
                or dtype == "float32" or dtype == "int32":
            return True
        elif dtype == "int8" or dtype == "uint8":
            if shape[len_shape - 1] % 32 != 0:
                return True
        elif shape[len_shape - 1] % 16 != 0:
            return True

        shape_res = _get_perm_shape(shape, perm)
        if shape_res[len_shape - 1] % 16 != 0:
            return True

    return False


def _write_code(wkspace_dict, fname):
    """
    write workspaces to json file

    """
    fname = os.path.realpath(fname)
    if fname.startswith(os.getcwd()):
        if os.path.exists(fname):
            with open(fname, "r") as f_var:
                load_dict = json.load(f_var)
            load_dict.update(wkspace_dict)
            with open(fname, "w") as f_var:
                json.dump(load_dict, f_var, sort_keys=True,
                          indent=4, separators=(',', ':'))


def _get_perm_one(perm):
    """
    get the perm of first stage for transpose the last axis scene

    """
    perm_new = []
    perm_len = len(perm)
    dst_num = perm[perm_len - 1]
    dst_idx = perm_len - 2
    for i in range(perm_len):
        if i == dst_num:
            perm_new.append(dst_idx)
        elif i == dst_idx:
            perm_new.append(dst_num)
        else:
            perm_new.append(i)

    return perm_new


def _get_shape_two(shape):
    """
    get the shape of second stage for transpose the last axis scene

    """
    last = len(shape) - 1
    sec = last - 1
    shape_new = []
    for i, item in enumerate(shape):
        if i == sec:
            shape_new.append(shape[last])
        elif i == last:
            shape_new.append(shape[sec])
        else:
            shape_new.append(item)

    return shape_new


def _get_perm_three(perm_two, perm_res):
    """
    get the perm of third stage for transpose the last axis scene

    """
    perm_new = []
    for item_res in perm_res:
        res = -1
        for i, item in enumerate(perm_two):
            if item == item_res:
                res = i
                break
        perm_new.append(res)

    return perm_new


def _perm_to_flag(perm):
    """
    get the flag for permutation according to perm

    """
    flag = [i for i in perm]
    for i, item in enumerate(perm):
        flag[item] = i

    return flag


def _is_perm_change(perm):
    """
    whether the shape changes according to perm

    """
    length = len(perm)
    list_range = list(range(length))
    list_perm = list(perm[:])
    if operator.ne(list_range, list_perm):
        return True

    return False


def _get_align_axis(out_shape):
    """
    get the axis_info when applying the align

    """
    flag = -1
    if out_shape[-1] != 1:
        axis = len(out_shape) - 2
    else:
        for i, item in enumerate(reversed(out_shape)):
            if item > 1:
                flag = i
                break
        if flag == -1 or flag == 0:
            axis = 0
        else:
            axis = len(out_shape) - flag - 1

    return axis


def _new_alloc(tvm_ib, dtype, shape, name, scope):
    """
    decl new buffer

    Parameters
    ----------
    tvm_ib : tvm.ir_builder
        Developer API of IR node builder make function
    dtype : str
        buffer date type
    shape : int
        buffer shape
    name : str
        buffer name
    scope : str
        buffer memory scope

    Returns
    -------
    new_buffer : tvm.schedule.Buffer
        Symbolic data buffer
    """
    buf_var = tvm_ib.allocate(dtype, shape, name=name, scope=scope)
    new_buffer = tvm.decl_buffer(shape, buf_var.dtype, name=name,
                                 scope=scope, data=buf_var)

    return new_buffer


def _get_params_for_multi_group_ir(tvm_ib, shape, dtype):
    """
    calculate parameters for multi group permute_ir

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    col_len = shape[len(shape) - 2]
    row_len = shape[len(shape) - 1]
    block_row_len = row_len // 16
    block_col_len = col_len // 16
    block_size = 16*16*float_size
    ub_block_num = UB_SIZE_B // 2 // block_size
    index_size = 1
    for i, item in enumerate(shape):
        if i < (len(shape) - 2):
            index_size *= item

    # available bytes in UB
    data_ub_size = ub_block_num*block_size
    # elements in two dim shape
    two_dim = col_len*row_len
    # bytes in two dim shape
    two_dim_bytes = col_len*row_len*float_size
    # two dim shapes in UB
    num_two_dim_one_ub = data_ub_size // two_dim_bytes
    all_core_size = num_two_dim_one_ub*two_dim_bytes*device_core_num
    all_core_offset = num_two_dim_one_ub*two_dim*device_core_num
    actual_one_core_ele = num_two_dim_one_ub*two_dim
    actual_one_core_block = actual_one_core_ele // 256
    num_all_two_dim = index_size*two_dim // 256
    num_block_one_group = device_core_num*num_two_dim_one_ub*two_dim // 256
    data_size = index_size*two_dim_bytes
    num_group_index = data_size // all_core_size
    num_group_mod = data_size % all_core_size

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {'block_row_len': block_row_len, 'two_dim': two_dim,
                 'index_size': index_size,
                 'float_size': float_size, 'col_len': col_len,
                 'row_len': row_len,
                 'num_two_dim_one_ub': num_two_dim_one_ub,
                 'all_core_offset': all_core_offset,
                 'block_index': block_index, 'block_col_len': block_col_len,
                 'num_group_mod': num_group_mod,
                 'actual_one_core_ele': actual_one_core_ele,
                 'actual_one_core_block': actual_one_core_block,
                 'num_all_two_dim': num_all_two_dim,
                 'device_core_num': device_core_num,
                 'num_group_index': num_group_index,
                 'num_block_one_group': num_block_one_group}

    return param_map


def _get_params_for_multi_row_ir(tvm_ib, shape, dtype):
    """
    calculate parameters for multi row permute_ir

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    col_len = shape[len(shape) - 2]
    row_len = shape[len(shape) - 1]
    block_row_len = row_len // 16
    block_col_len = col_len // 16
    block_size = 16*16*float_size
    ub_block_num = UB_SIZE_B // 2 // block_size
    index_size = 1
    for i, item in enumerate(shape):
        if i < (len(shape) - 2):
            index_size *= item

    # available bytes in UB
    data_ub_size = ub_block_num*block_size
    # elements in two dim shape
    two_dim = col_len*row_len
    # bytes in two dim shape
    two_dim_bytes = col_len*row_len*float_size
    # two dim shapes in UB
    num_two_dim_one_ub = data_ub_size // two_dim_bytes
    block_row_len_bytes = 16*row_len*float_size
    # number of block row in one core
    num_block_row_one_core = data_ub_size // block_row_len_bytes
    # number of block row in data
    all_block_row_in_data = index_size*block_col_len
    # number of block row in one group
    num_block_row_one_group = num_block_row_one_core*device_core_num
    num_group_more_row_index = all_block_row_in_data // num_block_row_one_group
    num_group_more_row_mod = all_block_row_in_data % num_block_row_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {'block_row_len': block_row_len, 'float_size': float_size,
                 'two_dim': two_dim,
                 'index_size': index_size, 'col_len': col_len,
                 'row_len': row_len,
                 'num_two_dim_one_ub': num_two_dim_one_ub,
                 'block_index': block_index,
                 'block_col_len': block_col_len,
                 'device_core_num': device_core_num,
                 'num_block_row_one_core': num_block_row_one_core,
                 'num_group_more_row_index': num_group_more_row_index,
                 'num_block_row_one_group': num_block_row_one_group,
                 'num_group_more_row_mod': num_group_more_row_mod}

    return param_map


def _get_params_for_split_row_ir(tvm_ib, shape, dtype):
    """
    calculate parameters for split row permute_ir

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    col_len = shape[len(shape) - 2]
    row_len = shape[len(shape) - 1]
    block_row_len = row_len // 16
    block_col_len = col_len // 16
    block_size = 16*16*float_size
    ub_block_num = UB_SIZE_B // 2 // block_size
    index_size = 1
    for i, item in enumerate(shape):
        if i < (len(shape) - 2):
            index_size *= item

    # available bytes in one ub
    data_ub_size = ub_block_num*block_size
    # elements in two dim shape
    two_dim = col_len*row_len
    # bytes in two dim shape
    two_dim_bytes = col_len*row_len*float_size
    # number of block in two dim shape
    num_block_in_two_dim = two_dim // 256
    # number of two dim shapes in UB
    num_two_dim_one_ub = data_ub_size // two_dim_bytes
    # number of 16*16 block in one core
    num_block256_one_core = data_ub_size // (256*float_size)
    # number of 16*16 block in one group
    num_block256_one_group = num_block256_one_core*device_core_num
    # number of 16*16 block in data
    num_block256_in_data = index_size*two_dim // 256
    num_group_split_row_index = num_block256_in_data // num_block256_one_group
    num_group_split_row_mod = num_block256_in_data % num_block256_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {'block_row_len': block_row_len, 'float_size': float_size,
                 'two_dim': two_dim,
                 'index_size': index_size, 'col_len': col_len,
                 'row_len': row_len,
                 'num_two_dim_one_ub': num_two_dim_one_ub,
                 'block_index': block_index,
                 'block_col_len': block_col_len,
                 'device_core_num': device_core_num,
                 'num_block_in_two_dim': num_block_in_two_dim,
                 'num_block256_one_core': num_block256_one_core,
                 'num_block256_one_group': num_block256_one_group,
                 'num_group_split_row_index': num_group_split_row_index,
                 'num_group_split_row_mod': num_group_split_row_mod}

    return param_map


# pylint: disable=locally-disabled, too-many-statements
def _multi_core_split_row_ir(dst, data, ir_type):
    """
    function of make ir node builder to transpose last two axes
     for split row in one UB scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_params_for_split_row_ir(tvm_ib, data.shape, data.dtype)
    data_ub = _new_alloc(tvm_ib, "uint16_t",
                         param.get('num_block256_one_core')*256,
                         "data_ub", scope=cce.scope_ubuf)
    data_ub_trans = _new_alloc(tvm_ib, "uint16_t",
                               param.get('num_block256_one_core')*256,
                               "data_ub", scope=cce.scope_ubuf)

    with tvm_ib.for_range(0, param.get('num_group_split_row_index'),
                          name='num_g_sr') as num_g_sr:
        with tvm_ib.for_range(0, param.get('num_block256_one_core'),
                              name='num_b_c') as num_b_c:
            block256_index = num_g_sr*param.get('num_block256_one_group')\
                             + param.get('block_index')\
                             * param.get('num_block256_one_core') + num_b_c
            two_dim_index = block256_index // param.get('num_block_in_two_dim')
            two_dim_mod = block256_index % param.get('num_block_in_two_dim')
            block_col_len_index = two_dim_mod // param.get('block_row_len')
            block_row_len_index = two_dim_mod % param.get('block_row_len')
            tvm_ib.emit(tvm.call_extern(data.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=(num_b_c*256)),
                                        data.access_ptr(
                                            'r',
                                            offset=(two_dim_index
                                                    * param.get('two_dim')
                                                    + block_col_len_index
                                                    * param.get('row_len')*16
                                                    + block_row_len_index*16)),
                                        0, 16,
                                        ((16*param.get('float_size')) // 32),
                                        (((param.get('row_len') - 16)
                                          * param.get('float_size')) // 32), 0))
        with tvm_ib.for_range(0, param.get('num_block256_one_core'),
                              name='num_v') as num_v:
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "vtranspose",
                                        data_ub_trans.access_ptr(
                                            "rw", offset=(256*num_v)),
                                        data_ub.access_ptr(
                                            "r", offset=(256*num_v))))
        with tvm_ib.for_range(0, param.get('num_block256_one_core'),
                              name='num_b_c') as num_b_c:
            block256_index = num_g_sr*param.get('num_block256_one_group')\
                             + param.get('block_index')\
                             * param.get('num_block256_one_core') + num_b_c
            two_dim_index = block256_index // param.get('num_block_in_two_dim')
            two_dim_mod = block256_index % param.get('num_block_in_two_dim')
            block_col_len_index = two_dim_mod // param.get('block_row_len')
            block_row_len_index = two_dim_mod % param.get('block_row_len')
            tvm_ib.emit(tvm.call_extern(ir_type, "copy_ubuf_to_gm",
                                        dst.access_ptr(
                                            'w',
                                            offset=(two_dim_index
                                                    * param.get('two_dim')
                                                    + block_row_len_index
                                                    * param.get('col_len')*16
                                                    + block_col_len_index*16)),
                                        data_ub_trans.access_ptr(
                                            "r", offset=(num_b_c*256)),
                                        0, 16,
                                        ((16*param.get('float_size')) // 32),
                                        0, (((param.get('col_len') - 16)
                                             * param.get('float_size')) // 32)))
    with tvm_ib.if_scope(param.get('num_group_split_row_mod') > 0):
        num_core_split_row_index = param.get('num_group_split_row_mod') \
                                   // param.get('num_block256_one_core')
        num_core_split_row_mod = param.get('num_group_split_row_mod')\
                                 % param.get('num_block256_one_core')
        with tvm_ib.if_scope(num_core_split_row_index > 0):
            with tvm_ib.if_scope(param.get('block_index').var
                                 < num_core_split_row_index):
                with tvm_ib.for_range(0, param.get('num_block256_one_core'),
                                      name='num_b_c') as num_b_c:
                    block256_index = param.get('num_group_split_row_index')\
                                     * param.get('num_block256_one_group')\
                                     + param.get('block_index')\
                                     * param.get('num_block256_one_core')\
                                     + num_b_c
                    two_dim_index = block256_index\
                                    // param.get('num_block_in_two_dim')
                    two_dim_mod = block256_index\
                                  % param.get('num_block_in_two_dim')
                    block_col_len_index = two_dim_mod\
                                          // param.get('block_row_len')
                    block_row_len_index = two_dim_mod\
                                          % param.get('block_row_len')
                    tvm_ib.emit(
                        tvm.call_extern(
                            data.dtype, "copy_gm_to_ubuf",
                            data_ub.access_ptr(
                                "w", offset=(num_b_c*256)),
                            data.access_ptr(
                                'r',
                                offset=(two_dim_index
                                        * param.get('two_dim')
                                        + block_col_len_index
                                        * param.get('row_len')*16
                                        + block_row_len_index*16)),
                            0, 16, ((16*param.get('float_size')) // 32),
                            (((param.get('row_len') - 16)
                              * param.get('float_size')) // 32), 0))
                with tvm_ib.for_range(0, param.get('num_block256_one_core'),
                                      name='num_vtrans') as num_vtrans:
                    tvm_ib.emit(
                        tvm.call_extern(
                            data_ub.dtype, "vtranspose",
                            data_ub_trans.access_ptr(
                                "rw", offset=(256*num_vtrans)),
                            data_ub.access_ptr("r", offset=(256*num_vtrans))))
                with tvm_ib.for_range(0, param.get('num_block256_one_core'),
                                      name='num_b_c') as num_b_c:
                    block256_index = param.get('num_group_split_row_index')\
                                     * param.get('num_block256_one_group') \
                                     + param.get('block_index')\
                                     * param.get('num_block256_one_core')\
                                     + num_b_c
                    two_dim_index = block256_index\
                                    // param.get('num_block_in_two_dim')
                    two_dim_mod = block256_index\
                                  % param.get('num_block_in_two_dim')
                    block_col_len_index = two_dim_mod\
                                          // param.get('block_row_len')
                    block_row_len_index = two_dim_mod\
                                          % param.get('block_row_len')
                    tvm_ib.emit(
                        tvm.call_extern(
                            ir_type, "copy_ubuf_to_gm",
                            dst.access_ptr(
                                'w',
                                offset=(two_dim_index
                                        * param.get('two_dim')
                                        + block_row_len_index
                                        * param.get('col_len')*16
                                        + block_col_len_index*16)),
                            data_ub_trans.access_ptr(
                                "r", offset=(num_b_c * 256)),
                            0, 16, ((16*param.get('float_size')) // 32),
                            0, (((param.get('col_len') - 16)
                                 * param.get('float_size')) // 32)))
        with tvm_ib.if_scope(tvm.all(param.get('block_index')
                                     < (num_core_split_row_index + 1),
                                     param.get('block_index')
                                     > (num_core_split_row_index - 1))):
            with tvm_ib.for_range(0, num_core_split_row_mod, name='num_b_c')\
                    as num_b_c:
                block256_offset = param.get('num_group_split_row_index')\
                                  * param.get('num_block256_one_group')\
                                 + param.get('block_index')\
                                  * param.get('num_block256_one_core')
                block256_index = block256_offset + num_b_c
                two_dim_index = block256_index\
                                // param.get('num_block_in_two_dim')
                two_dim_mod = block256_index % param.get('num_block_in_two_dim')
                block_col_len_index = two_dim_mod // param.get('block_row_len')
                block_row_len_index = two_dim_mod % param.get('block_row_len')
                tvm_ib.emit(
                    tvm.call_extern(
                        data.dtype, "copy_gm_to_ubuf",
                        data_ub.access_ptr("w", offset=(num_b_c*256)),
                        data.access_ptr(
                            'r',
                            offset=(two_dim_index
                                    * param.get('two_dim')
                                    + block_col_len_index
                                    * param.get('row_len')*16
                                    + block_row_len_index*16)),
                        0, 16, ((16*param.get('float_size')) // 32),
                        (((param.get('row_len') - 16)
                          * param.get('float_size')) // 32), 0))
            with tvm_ib.for_range(0, num_core_split_row_mod,
                                  name='num_vtrans') as num_vtrans:
                tvm_ib.emit(
                    tvm.call_extern(
                        data_ub.dtype, "vtranspose",
                        data_ub_trans.access_ptr(
                            "rw", offset=(256*num_vtrans)),
                        data_ub.access_ptr("r", offset=(256*num_vtrans))))
            with tvm_ib.for_range(0, num_core_split_row_mod,
                                  name='num_b_c') as num_b_c:
                block256_index = param.get('num_group_split_row_index')\
                                 * param.get('num_block256_one_group') \
                                 + param.get('block_index')\
                                 * param.get('num_block256_one_core')\
                                 + num_b_c
                two_dim_index = block256_index\
                                // param.get('num_block_in_two_dim')
                two_dim_mod = block256_index\
                              % param.get('num_block_in_two_dim')
                block_col_len_index = two_dim_mod // param.get('block_row_len')
                block_row_len_index = two_dim_mod % param.get('block_row_len')
                tvm_ib.emit(
                    tvm.call_extern(
                        ir_type, "copy_ubuf_to_gm",
                        dst.access_ptr(
                            'w',
                            offset=(two_dim_index * param.get('two_dim')
                                    + block_row_len_index
                                    * param.get('col_len')*16
                                    + block_col_len_index*16)),
                        data_ub_trans.access_ptr("r", offset=(num_b_c*256)),
                        0, 16, ((16*param.get('float_size')) // 32),
                        0, (((param.get('col_len') - 16)
                             * param.get('float_size')) // 32)))

    return tvm_ib.get()


def _multi_core_more_row_ir(dst, data, ir_type):
    """
    function of make ir node builder to transpose last two axes
     for multi row in one UB scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_params_for_multi_row_ir(tvm_ib, data.shape, data.dtype)
    data_ub = _new_alloc(tvm_ib, "uint16_t",
                         param.get('num_block_row_one_core')
                         * param.get('row_len') * 16,
                         "data_ub", scope=cce.scope_ubuf)
    data_ub_trans = _new_alloc(tvm_ib, "uint16_t",
                               param.get('num_block_row_one_core')
                               * param.get('row_len') * 16, "data_ub_trans",
                               scope=cce.scope_ubuf)

    with tvm_ib.for_range(0, param.get('num_group_more_row_index'),
                          name='num_g_i') as num_g_i:
        with tvm_ib.for_range(0, param.get('num_block_row_one_core'),
                              name='num_b_c') as num_b_c:
            with tvm_ib.for_range(0, param.get('block_row_len'),
                                  name='num_b_r') as num_b_r:
                tvm_ib.emit(
                    tvm.call_extern(
                        data.dtype, "copy_gm_to_ubuf",
                        data_ub.access_ptr(
                            "w",
                            offset=(num_b_c*param.get('row_len') * 16
                                    + num_b_r*256)),
                        data.access_ptr(
                            'r',
                            offset=(num_g_i
                                    * param.get('num_block_row_one_group')
                                    * param.get('row_len')*16
                                    + param.get('block_index')
                                    * param.get('num_block_row_one_core')
                                    * param.get('row_len')*16
                                    + num_b_c*param.get('row_len')
                                    * 16 + num_b_r * 16)),
                        0, 16, ((16*param.get('float_size')) // 32),
                        (((param.get('row_len') - 16)
                          * param.get('float_size')) // 32), 0))

        with tvm_ib.for_range(0, param.get('num_block_row_one_core')
                              * param.get('block_row_len'),
                              name='num_vtrans') as num_vtrans:
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "vtranspose",
                                        data_ub_trans.access_ptr(
                                            "rw", offset=(256*num_vtrans)),
                                        data_ub.access_ptr(
                                            "r", offset=(256*num_vtrans))))
        with tvm_ib.for_range(0, param.get('num_block_row_one_core'),
                              name='num_b_c') as num_b_c:
            block_row_index = num_g_i * param.get('num_block_row_one_group')\
                              + param.get('block_index')\
                              * param.get('num_block_row_one_core')\
                              + num_b_c
            two_dim_index = block_row_index // param.get('block_col_len')
            block_row_index_in_two_dim = block_row_index\
                                         % param.get('block_col_len')
            tvm_ib.emit(
                tvm.call_extern(
                    ir_type, "copy_ubuf_to_gm",
                    dst.access_ptr(
                        'w',
                        offset=(two_dim_index * param.get('two_dim')
                                + block_row_index_in_two_dim * 16)),
                    data_ub_trans.access_ptr(
                        "r",
                        offset=(num_b_c * param.get('row_len')*16)),
                    0, param.get('row_len'),
                    ((16*param.get('float_size')) // 32),
                    0, (((param.get('col_len') - 16)
                         * param.get('float_size')) // 32)))
    with tvm_ib.if_scope(param.get('num_group_more_row_mod') > 0):
        num_mod_core_index = param.get('num_group_more_row_mod') \
                             // param.get('num_block_row_one_core')
        num_mod_core_mod = param.get('num_group_more_row_mod') \
                             % param.get('num_block_row_one_core')
        with tvm_ib.if_scope(num_mod_core_index > 0):
            with tvm_ib.if_scope(param.get('block_index').var
                                 < num_mod_core_index):
                with tvm_ib.for_range(0, param.get('num_block_row_one_core'),
                                      name='num_b_c') as num_b_c:
                    with tvm_ib.for_range(0, param.get('block_row_len'),
                                          name='num_b_r') as num_b_r:
                        tvm_ib.emit(
                            tvm.call_extern(
                                data.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr(
                                    "w",
                                    offset=(num_b_c * param.get('row_len')
                                            * 16 + num_b_r*256)),
                                data.access_ptr(
                                    'r',
                                    offset=(param.get(
                                        'num_group_more_row_index')
                                            * param.get('num_block_'
                                                        'row_one_group')
                                            * param.get('row_len') * 16
                                            + param.get('block_index')
                                            * param.get('num_block_'
                                                        'row_one_core')
                                            * param.get('row_len')*16
                                            + num_b_c
                                            * param.get('row_len')*16
                                            + num_b_r * 16)),
                                0, 16, ((16*param.get('float_size')) // 32),
                                (((param.get('row_len') - 16)
                                  * param.get('float_size')) // 32), 0))
                with tvm_ib.for_range(0, param.get('num_block_row_one_core')
                                      * param.get('block_row_len'),
                                      name='num_vtrans') as num_vtrans:
                    tvm_ib.emit(
                        tvm.call_extern(
                            data_ub.dtype, "vtranspose",
                            data_ub_trans.access_ptr(
                                "rw", offset=(256*num_vtrans)),
                            data_ub.access_ptr("r", offset=(256*num_vtrans))))
                with tvm_ib.for_range(0, param.get('num_block_row_one_core'),
                                      name='num_b_c') as num_b_c:
                    block_row_index = param.get('num_group_more_row_index')\
                                      * param.get('num_block_row_one_group')\
                                      + param.get('block_index')\
                                      * param.get('num_block_row_one_core')\
                                      + num_b_c
                    two_dim_index = block_row_index\
                                    // param.get('block_col_len')
                    block_row_index_in_two_dim = block_row_index\
                                                 % param.get('block_col_len')
                    tvm_ib.emit(
                        tvm.call_extern(
                            ir_type, "copy_ubuf_to_gm",
                            dst.access_ptr(
                                'w',
                                offset=(two_dim_index
                                        * param.get('two_dim')
                                        + block_row_index_in_two_dim
                                        * 16)),
                            data_ub_trans.access_ptr(
                                "r", offset=(num_b_c * param.get('row_len')
                                             * 16)),
                            0, param.get('row_len'),
                            ((16*param.get('float_size')) // 32),
                            0, (((param.get('col_len') - 16)
                                 * param.get('float_size')) // 32)))
        with tvm_ib.if_scope(tvm.all(param.get('block_index').var
                                     < (num_mod_core_index + 1),
                                     param.get('block_index').var
                                     > (num_mod_core_index - 1))):
            with tvm_ib.for_range(0, num_mod_core_mod, name='num_b_c')\
                    as num_b_c:
                with tvm_ib.for_range(0, param.get('block_row_len'),
                                      name='num_b_r') as num_b_r:
                    tvm_ib.emit(
                        tvm.call_extern(
                            data.dtype, "copy_gm_to_ubuf",
                            data_ub.access_ptr(
                                "w",
                                offset=(num_b_c * param.get('row_len')*16
                                        + num_b_r*256)),
                            data.access_ptr(
                                'r',
                                offset=(param.get('num_group_more_row_index')
                                        * param.get('num_block_row_one_group')
                                        * param.get('row_len') * 16
                                        + param.get('block_index')
                                        * param.get('num_block_row_one_core')
                                        * param.get('row_len') * 16
                                        + num_b_c * param.get('row_len') * 16
                                        + num_b_r*16)),
                            0, 16, ((16*param.get('float_size')) // 32),
                            (((param.get('row_len') - 16)
                              * param.get('float_size')) // 32), 0))
            with tvm_ib.for_range(0, num_mod_core_mod
                                  * param.get('block_row_len'),
                                  name='num_vtrans') as num_vtrans:
                tvm_ib.emit(
                    tvm.call_extern(
                        data_ub.dtype, "vtranspose",
                        data_ub_trans.access_ptr(
                            "rw", offset=(256*num_vtrans)),
                        data_ub.access_ptr("r", offset=(256*num_vtrans))))
            with tvm_ib.for_range(0, num_mod_core_mod, name='num_b_c')\
                    as num_b_c:
                block_row_index = param.get('num_group_more_row_index')\
                                  * param.get('num_block_row_one_group') \
                                  + param.get('block_index')\
                                  * param.get('num_block_row_one_core')\
                                  + num_b_c
                two_dim_index = block_row_index // param.get('block_col_len')
                block_row_index_in_two_dim = block_row_index\
                                             % param.get('block_col_len')
                tvm_ib.emit(
                    tvm.call_extern(
                        ir_type, "copy_ubuf_to_gm",
                        dst.access_ptr(
                            'w',
                            offset=(two_dim_index * param.get('two_dim')
                                    + block_row_index_in_two_dim * 16)),
                        data_ub_trans.access_ptr(
                            "r",
                            offset=(num_b_c * param.get('row_len') * 16)),
                        0, param.get('row_len'),
                        ((16*param.get('float_size')) // 32),
                        0, (((param.get('col_len') - 16)
                             * param.get('float_size')) // 32)))

    return tvm_ib.get()


def _multi_core_more_group_ir(dst, data, ir_type):
    """
    function of make ir node builder to transpose last two axes
     for multi group in one UB scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_params_for_multi_group_ir(tvm_ib, data.shape, data.dtype)
    data_ub = _new_alloc(tvm_ib, "uint16_t", param.get('actual_one_core_ele'),
                         "data_ub", scope=cce.scope_ubuf)
    data_ub_trans = _new_alloc(tvm_ib, "uint16_t",
                               param.get('actual_one_core_ele'),
                               "data_ub_trans", scope=cce.scope_ubuf)

    with tvm_ib.for_range(0, param.get('num_group_index'), name='num_g')\
            as num_g:
        with tvm_ib.for_range(0, param.get('num_two_dim_one_ub'),
                              name='num_b') as num_b:
            with tvm_ib.for_range(0, param.get('block_row_len'),
                                  name='num_br') as num_br:
                tvm_ib.emit(
                    tvm.call_extern(
                        data.dtype, "copy_gm_to_ubuf",
                        data_ub.access_ptr(
                            "w",
                            offset=(num_b * param.get('two_dim')
                                    + num_br * 16 * param.get('col_len'))),
                        data.access_ptr(
                            'r',
                            offset=(num_g * param.get('all_core_offset')
                                    + param.get("block_index")
                                    * param.get('actual_one_core_ele')
                                    + num_b*param.get('two_dim')
                                    + num_br*16)),
                        0, param.get('col_len'),
                        ((16*param.get('float_size')) // 32),
                        (((param.get('row_len') - 16)
                          * param.get('float_size')) // 32), 0))
        with tvm_ib.for_range(0, param.get('actual_one_core_block'),
                              name='num_b_core') as num_b_core:
            tvm_ib.emit(
                tvm.call_extern(
                    data_ub.dtype, "vtranspose",
                    data_ub_trans.access_ptr("rw", offset=(256*num_b_core)),
                    data_ub.access_ptr("r", offset=(256*num_b_core))))
        with tvm_ib.for_range(0, param.get('num_two_dim_one_ub'),
                              name='num_b') as num_b:
            with tvm_ib.for_range(0, param.get('block_row_len'),
                                  name='num_br') as num_br:
                with tvm_ib.for_range(0, 16, name='i') as i:
                    tvm_ib.emit(
                        tvm.call_extern(
                            ir_type, "copy_ubuf_to_gm",
                            dst.access_ptr(
                                'w',
                                offset=(num_g * param.get('all_core_offset')
                                        + param.get("block_index")
                                        * param.get('actual_one_core_ele')
                                        + num_b * param.get('two_dim')
                                        + num_br * 16 * param.get('col_len')
                                        + 16*param.get('block_col_len')*i)),
                            data_ub_trans.access_ptr(
                                "r",
                                offset=(num_b * param.get('two_dim')
                                        + num_br * 16 * param.get('col_len')
                                        + 16 * i)),
                            0, param.get('block_col_len'),
                            ((16*param.get('float_size')) // 32),
                            ((15*16*param.get('float_size')) // 32), 0))

    with tvm_ib.if_scope(param.get('num_group_mod') > 0):
        tail_block_num_index = param.get('index_size')\
                               - (param.get('num_group_index'))\
                               * param.get('device_core_num')\
                               * param.get('num_two_dim_one_ub')
        tail_core_num_index = tail_block_num_index\
                              // param.get('num_two_dim_one_ub')
        tail_core_num_mod = tail_block_num_index\
                            % param.get('num_two_dim_one_ub')
        tail_core_mod_block = tail_core_num_mod*param.get('two_dim')//256
        with tvm_ib.if_scope(tail_core_num_index > 0):
            with tvm_ib.if_scope(param.get('block_index') < tail_core_num_index):
                with tvm_ib.for_range(0, param.get('num_two_dim_one_ub'),
                                      name='num_b') as num_b:
                    with tvm_ib.for_range(0, param.get('block_row_len'),
                                          name='num_br') as num_br:
                        tvm_ib.emit(
                            tvm.call_extern(
                                data.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr(
                                    "w",
                                    offset=(num_b * param.get('two_dim')
                                            + num_br * 16
                                            * param.get('col_len'))),
                                data.access_ptr(
                                    'r',
                                    offset=(param.get('num_group_index')
                                            * param.get('all_core_offset')
                                            + param.get('block_index')
                                            * param.get('actual_one_core_ele')
                                            + num_b * param.get('two_dim')
                                            + num_br * 16)),
                                0, param.get('col_len'),
                                ((16*param.get('float_size')) // 32),
                                (((param.get('row_len') - 16)
                                  * param.get('float_size')) // 32), 0))
                with tvm_ib.for_range(0, param.get('actual_one_core_block'),
                                      name='num_b_core') as num_b_core:
                    tvm_ib.emit(
                        tvm.call_extern(
                            data_ub.dtype, "vtranspose",
                            data_ub_trans.access_ptr(
                                "rw", offset=(256*num_b_core)),
                            data_ub.access_ptr("r", offset=(256*num_b_core))))
                with tvm_ib.for_range(0, param.get('num_two_dim_one_ub'),
                                      name='num_b') as num_b:
                    with tvm_ib.for_range(0, param.get('block_row_len'),
                                          name='num_br') as num_br:
                        with tvm_ib.for_range(0, 16, name='i') as i:
                            tvm_ib.emit(
                                tvm.call_extern(
                                    ir_type, "copy_ubuf_to_gm",
                                    dst.access_ptr(
                                        'w',
                                        offset=(param.get('num_group_index')
                                                * param.get('all_core_offset')
                                                + param.get('block_index')
                                                * param.get('actual_one'
                                                            '_core_ele')
                                                + num_b * param.get('two_dim')
                                                + num_br * 16
                                                * param.get('col_len')
                                                + 16
                                                * param.get('block_col_len')
                                                * i)),
                                    data_ub_trans.access_ptr(
                                        "r",
                                        offset=(num_b * param.get('two_dim')
                                                + num_br * 16
                                                * param.get('col_len')
                                                + 16 * i)),
                                    0, param.get('block_col_len'),
                                    ((16*param.get('float_size')) // 32),
                                    ((15*16*param.get('float_size')) // 32),
                                    0))

        with tvm_ib.if_scope(tvm.all(param.get('block_index')
                                     < (tail_core_num_index + 1),
                                     param.get('block_index')
                                     > (tail_core_num_index - 1))):
            with tvm_ib.for_range(0, tail_core_num_mod, name='num_b') as num_b:
                with tvm_ib.for_range(0, param.get('block_row_len'),
                                      name='num_br') as num_br:
                    tvm_ib.emit(
                        tvm.call_extern(
                            data.dtype, "copy_gm_to_ubuf",
                            data_ub.access_ptr(
                                "w",
                                offset=(num_b * param.get('two_dim')
                                        + num_br * 16 * param.get('col_len'))),
                            data.access_ptr(
                                'r',
                                offset=(param.get('num_group_index')
                                        * param.get('all_core_offset')
                                        + param.get('block_index')
                                        * param.get('actual_one_core_ele')
                                        + num_b * param.get('two_dim')
                                        + num_br * 16)),
                            0, param.get('col_len'),
                            ((16*param.get('float_size')) // 32),
                            (((param.get('row_len') - 16)
                              * param.get('float_size')) // 32), 0))
            with tvm_ib.for_range(0, tail_core_mod_block, name='num_b_core')\
                    as num_b_core:
                tvm_ib.emit(
                    tvm.call_extern(
                        data_ub.dtype, "vtranspose",
                        data_ub_trans.access_ptr(
                            "rw", offset=(256*num_b_core)),
                        data_ub.access_ptr("r", offset=(256*num_b_core))))
            with tvm_ib.for_range(0, tail_core_num_mod, name='num_b') as num_b:
                with tvm_ib.for_range(0, param.get('block_row_len'),
                                      name='num_br') as num_br:
                    with tvm_ib.for_range(0, 16, name='i') as i:
                        tvm_ib.emit(
                            tvm.call_extern(
                                ir_type, "copy_ubuf_to_gm",
                                dst.access_ptr(
                                    'w',
                                    offset=(param.get('num_group_index')
                                            * param.get('all_core_offset')
                                            + param.get('block_index')
                                            * param.get('actual_one_core_ele')
                                            + num_b*param.get('two_dim')
                                            + num_br*16
                                            * param.get('col_len')
                                            + 16 * param.get('block_col_len')
                                            * i)),
                                data_ub_trans.access_ptr(
                                    "r",
                                    offset=(num_b * param.get('two_dim')
                                            + num_br * 16
                                            * param.get('col_len') + 16*i)),
                                0, param.get('block_col_len'),
                                ((16*param.get('float_size')) // 32),
                                ((15*16*param.get('float_size')) // 32), 0))

    return tvm_ib.get()


def _ir_branch_index(shape, dtype):
    """
    judge ir node builder branch according to shape and dtype

    """
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    col_len = shape[len(shape) - 2]
    row_len = shape[len(shape) - 1]
    block_size = 16*16*float_size
    ub_block_num = UB_SIZE_B // 2 // block_size
    # available bytes in UB
    data_ub_size = ub_block_num*block_size
    # bytes in two dim shape
    two_dim_bytes = col_len*row_len*float_size
    # bytes in block row length
    block_row_len_bytes = row_len*16*float_size

    if data_ub_size >= two_dim_bytes:
        return "more_group"
    elif data_ub_size < block_row_len_bytes:
        return "split_row"
    elif data_ub_size < two_dim_bytes:
        return "more_row"


# pylint: disable=locally-disabled,unnecessary-lambda
def _get_res_ir(data, shape, perm, dtype):
    """
    the function to get the res_ir and parameters

    """
    def _permute_gm(*index):
        """
        function of permute the dimensions to get data_gm

        """
        for i, item in enumerate(_perm_to_flag(_get_perm_one(perm))):
            if i == 0:
                res_axis = (index[item],)
            else:
                res_axis = res_axis + (index[item],)

        return res_axis

    perm_one = _get_perm_one(perm)
    if _is_perm_change(perm_one) or (dtype != "float16"
                                     and dtype != "int16"
                                     and dtype != "uint16"):
        shape_one = _get_perm_shape(shape, _get_perm_one(perm))
        data_ub_one = tvm.compute(shape, lambda *i: data(*i),
                                  name="data_ub_one")
        if dtype == "float16" or dtype == "int16" or dtype == "uint16":
            ir_type = dtype
            data_ub_one_fp16 = data_ub_one
        else:
            ir_type = "float16"
            data_ub_one_fp16 = tvm.compute(shape,
                                           lambda *i:
                                           data_ub_one(*i).astype("float16"),
                                           name="data_ub_one_fp16")
        data_gm = tvm.compute(shape_one,
                              lambda *i: data_ub_one_fp16(*_permute_gm(*i)),
                              name="data_gm")
        param_ir = {'data_ub_one': data_ub_one,
                    'data_ub_one_fp16': data_ub_one_fp16,
                    'data_gm': data_gm, 'shape_one': shape_one,
                    'ir_type': ir_type}
    else:
        shape_one = shape
        data_gm = data
        ir_type = dtype
        param_ir = {'data_gm': data_gm, 'shape_one': shape_one,
                    'ir_type': ir_type}

    branch_index = _ir_branch_index(shape_one, ir_type)
    if branch_index == "more_group":
        res_ir = tvm.extern(_get_shape_two(shape_one), [data_gm],
                            lambda ins, outs:
                            _multi_core_more_group_ir(outs[0], ins[0], ir_type),
                            name="res_ir", dtype=ir_type)
    elif branch_index == "more_row":
        res_ir = tvm.extern(_get_shape_two(shape_one), [data_gm],
                            lambda ins, outs:
                            _multi_core_more_row_ir(outs[0], ins[0], ir_type),
                            name="res_ir", dtype=ir_type)
    else:
        res_ir = tvm.extern(_get_shape_two(shape_one), [data_gm],
                            lambda ins, outs:
                            _multi_core_split_row_ir(outs[0], ins[0], ir_type),
                            name="res_ir", dtype=ir_type)

    perm_three = _get_perm_three(_get_shape_two(_get_perm_one(perm)), perm)
    if _is_perm_change(perm_three)\
            or (dtype != "float16" and dtype != "int16" and dtype != "uint16"):
        res, param_res = _get_res(res_ir, _get_perm_shape(shape, perm),
                                  dtype, perm,
                                  _get_shape_two(_get_perm_one(perm)))
    else:
        res = res_ir
        param_res = {}

    param_ir.setdefault('res_ir', res_ir)
    param = {}
    param.update(param_ir)
    param.update(param_res)

    return res, param


def _get_res(res_ir, shape_res, dtype, perm, perm_two):
    """
    the function to get the res and parameters

    """
    def _permute_res(*index):
        """
        function of permute the dimensions of data_ub_two

        """
        for i, item in enumerate(flag_three):
            if i == 0:
                res_axis = (index[item],)
            else:
                res_axis = res_axis + (index[item],)

        return res_axis

    perm_three = _get_perm_three(perm_two, perm)
    flag_three = _perm_to_flag(perm_three)
    data_ub_two = tvm.compute(shape_res, lambda *i: res_ir(*_permute_res(*i)),
                              name="data_ub_two")
    if dtype != "float16" and dtype != "int16" and dtype != "uint16":
        data_ub_two_res = tvm.compute(shape_res,
                                      lambda *i: data_ub_two(*i).astype(dtype),
                                      name="data_ub_two_res")
    else:
        data_ub_two_res = data_ub_two
    res = tvm.compute(shape_res, lambda *i: data_ub_two_res(*i), name="res")
    param_res = {'data_ub_two': data_ub_two,
                 'data_ub_two_res': data_ub_two_res}

    return res, param_res


def _schedule_for_data_ub_two(sch, res, param, shape_res, dtype):
    """
    the function of schedule for the third stage
     for transpose the last axis scene

    """
    split_axis2, split_factor2 = _tilling_axis_last(shape_res, dtype)
    axis_outer2, axis_inner2 = sch[res].split(res.op.axis[split_axis2],
                                              factor=split_factor2)
    sch[param.get('data_ub_two')].compute_at(sch[res], axis_outer2)
    sch[param.get('data_ub_two_res')].compute_at(sch[res], axis_outer2)
    sch[param.get('data_ub_two')].emit_insn(
        param.get('data_ub_two').op.axis[split_axis2], insn_cmd.DMA_COPY)
    if dtype == "int32":
        sch[param.get('data_ub_two_res')].emit_insn(
            param.get('data_ub_two_res').op.axis[split_axis2],
            insn_cmd.CAST_RINT)
    elif dtype != "float16" and dtype != "int16" and dtype != "uint16":
        sch[param.get('data_ub_two_res')].emit_insn(
            param.get('data_ub_two_res').op.axis[split_axis2],
            insn_cmd.CAST)
    sch[res].emit_insn(axis_inner2, insn_cmd.DMA_COPY)

    return sch


def _transpose_change_last(data, shape, shape_res, perm, dtype):
    """
    permutes the dimensions and the last axis is transposed

    Parameters
    ----------
    data: tvm.tensor
        tensor of input data
    shape: list or tuple
        shape of input tensor
    shape_res: tuple
        shape of output tensor
    perm: list or tuple
        permutation of the dimension of tensor
    dtype: str
        the data type

    Returns
    -------
    sch: tvm.schedule
        the compute schedule
    tensor_list: list
        list of tensor
        [data, res, param.get('data_gm'), param.get('res_ir')]
    num: int
        the count of workspaces
    total_size: list
        the list of size of workspaces
    """
    res, param = _get_res_ir(data, shape, perm, dtype)
    sch = tvm.create_schedule(res.op)
    if 'data_ub_one' in param:
        sch[param.get('data_ub_one')].set_scope(cce.scope_ubuf)
        sch[param.get('data_ub_one_fp16')].set_scope(cce.scope_ubuf)
    if 'data_ub_two' in param:
        sch[param.get('data_ub_two')].set_scope(cce.scope_ubuf)
        sch[param.get('data_ub_two_res')].set_scope(cce.scope_ubuf)

    if 'data_ub_one' in param:
        split_axis1, split_factor1 = _tilling_axis_last(param.get('shape_one'),
                                                        dtype)
        axis_outer1, axis_inner1 = sch[param.get('data_gm')].split(
            param.get('data_gm').op.axis[split_axis1], factor=split_factor1)
        sch[param.get('data_ub_one')].compute_at(sch[param.get('data_gm')],
                                                 axis_outer1)
        sch[param.get('data_ub_one_fp16')].compute_at(
            sch[param.get('data_gm')], axis_outer1)
        sch[param.get('data_ub_one')].emit_insn(
            param.get('data_ub_one').op.axis[split_axis1], insn_cmd.DMA_COPY)
        if dtype != "float16" and dtype != "int16" or dtype != "uint16":
            sch[param.get('data_ub_one_fp16')].emit_insn(
                param.get('data_ub_one_fp16').op.axis[split_axis1],
                insn_cmd.CAST)
        sch[param.get('data_gm')].emit_insn(axis_inner1, insn_cmd.DMA_COPY)

    if 'data_ub_two' in param:
        sch = _schedule_for_data_ub_two(sch, res, param, shape_res, dtype)

    size = 1
    for item in shape:
        size *= item
    dtype_bytes_size = cce.cce_intrin.get_bit_len(param.get('ir_type')) // 8
    size *= dtype_bytes_size

    if ('data_ub_one' in param) and ('data_ub_two' in param):
        tensor_list = [data, res, param.get('data_gm'), param.get('res_ir')]
        num = 2
        total_size = [size, size]
    elif 'data_ub_one' in param:
        tensor_list = [data, res, param.get('data_gm')]
        num = 1
        total_size = [size]
    elif 'data_ub_two' in param:
        tensor_list = [data, res, param.get('res_ir')]
        num = 1
        total_size = [size]
    else:
        tensor_list = [data, res]
        num = 0
        total_size = []

    return sch, tensor_list, num, total_size


def _do_storage_align(sch, data_ub, shape_res, dtype):
    """
    the function to do storage align

    """
    if len(shape_res) >= 2:
        do_align = True
        if shape_res[len(shape_res) - 1] == 1:
            count = 0
            for i in shape_res:
                if i > 1:
                    count += 1
            if count == 1:
                do_align = False
        if do_align:
            dtype_bytes_size = cce.cce_intrin.get_bit_len(dtype) // 8
            # 32 means one block size(32 Bytes),
            # divide by 32 to get the numbers of data that
            # can be stored in one block.
            element = 32 // dtype_bytes_size
            align_axis = _get_align_axis(shape_res)
            sch[data_ub].storage_align(data_ub.op.axis[align_axis], element, 0)

    return sch


def _get_fused_index(fused_axis_value, origin_list_copy, split_axis):
    """
    get fused index for not change last schedule

    """
    fused_index_list = []
    for target in fused_axis_value:
        for i, item in enumerate(origin_list_copy):
            if target == item:
                fused_index_list.append(i)
                origin_list_copy[i] = -1
                break

    is_fuse_outer = False
    for i in fused_index_list:
        if i == split_axis:
            is_fuse_outer = True
            fused_index_list.remove(split_axis)
            break

    return fused_index_list, origin_list_copy, is_fuse_outer


def _get_after_reorder_axis(reorder_axis_index, split_axis):
    """
    get after reorder axis for not change last schedule

    """
    after_reorder_axis_index = []
    for i in list(range(split_axis)):
        if i not in reorder_axis_index:
            after_reorder_axis_index.append(i)

    return after_reorder_axis_index


def _do_compute_at(args):
    """
    compute at for not change last schedule

    """
    reorder_axis_index, sch, res, fused_axis, split_axis, data_ub = args
    if reorder_axis_index:
        fused_index_last = reorder_axis_index[-1]
        if fused_index_last == split_axis - 1:
            sch[data_ub].compute_at(sch[res], fused_axis)
        else:
            sch[data_ub].compute_at(sch[res], res.op.axis[split_axis - 1])
    else:
        sch[data_ub].compute_at(sch[res], fused_axis)

    return sch


def _schedule_for_not_change_last(args):
    """
    the function to bind multi core

    """
    sch, data, res, data_ub, shape_res, dtype = args
    sch[data_ub].set_scope(cce.scope_ubuf)
    dtype_bytes_size = cce.cce_intrin.get_bit_len(dtype) // 8
    element = 32 // dtype_bytes_size
    if shape_res[-1] < element:
        split_axis, split_factor = _tilling_axis_not_last(shape_res, dtype)
        axis_outer, axis_inner = sch[res].split(res.op.axis[split_axis],
                                                factor=split_factor)
        sch[data_ub].compute_at(sch[res], axis_outer)
    else:
        split_axis, split_factor = _tilling_axis_multi_core_fuse(shape_res,
                                                                 dtype)

        if split_axis == len(shape_res) - 1 and split_factor < element:
            axis_outer, axis_inner = sch[res].split(res.op.axis[split_axis],
                                                    factor=split_factor)
            sch[data_ub].compute_at(sch[res], axis_outer)
        else:
            axis_outer, axis_inner = sch[res].split(res.op.axis[split_axis],
                                                    factor=split_factor)
            axis_outer_num_index = shape_res[split_axis] // split_factor
            axis_outer_num_mod = shape_res[split_axis] % split_factor
            if axis_outer_num_mod > 0:
                axis_outer_num = axis_outer_num_index + 1
            else:
                axis_outer_num = axis_outer_num_index

            origin_list = [shape_res[i] for i in range(split_axis)]
            if axis_outer_num <= 65535:
                origin_list.append(axis_outer_num)

            origin_sort = list(reversed(sorted(origin_list)))
            fused_value = 1
            fused_axis_value = []
            for _, item in enumerate(origin_sort):
                if fused_value*item <= 65535:
                    fused_axis_value.append(item)
                    fused_value *= item

            origin_list_copy = origin_list[:]
            if fused_axis_value:
                fused_index_list, origin_list_copy, is_fuse_outer =\
                    _get_fused_index(
                        fused_axis_value, origin_list_copy, split_axis)
                reorder_axis_index = sorted(fused_index_list)
                if is_fuse_outer:
                    after_reorder_axis_index = _get_after_reorder_axis(
                        reorder_axis_index, split_axis)
                    reorder_axis = [sch[res].op.axis[i]
                                    for i in reorder_axis_index]
                    reorder_axis.append(axis_outer)
                    for i in after_reorder_axis_index:
                        reorder_axis.append(sch[res].op.axis[i])
                    sch[res].reorder(*reorder_axis)
                    fused_list = [sch[res].op.axis[i]
                                  for i in sorted(fused_index_list)]
                    fused_axis = sch[res].fuse(*fused_list)
                    fused_list.append(axis_outer)
                    fused_axis = sch[res].fuse(fused_axis, axis_outer)
                    args = [reorder_axis_index, sch, res, fused_axis,
                            split_axis, data_ub]
                    sch = _do_compute_at(args)
                    sch[res].bind(fused_axis, tvm.thread_axis('blockIdx.x'))
                else:
                    for i in list(range(split_axis)):
                        if i not in reorder_axis_index:
                            reorder_axis_index.append(i)
                    sch[res].reorder(*[sch[res].op.axis[i]
                                       for i in reorder_axis_index])
                    fused_axis = sch[res].fuse(
                        *[sch[res].op.axis[i]
                          for i in sorted(fused_index_list)])
                    sch[res].bind(fused_axis, tvm.thread_axis('blockIdx.x'))
                    sch[data_ub].compute_at(sch[res], axis_outer)
            else:
                split_axis, split_factor = _tilling_axis_not_last(
                    shape_res, dtype)
                axis_outer, axis_inner = sch[res].split(
                    res.op.axis[split_axis], factor=split_factor)
                sch[data_ub].compute_at(sch[res], axis_outer)

    sch[data_ub].emit_insn(data_ub.op.axis[split_axis], insn_cmd.DMA_COPY)
    sch = _do_storage_align(sch, data_ub, shape_res, dtype)
    sch[res].emit_insn(axis_inner, insn_cmd.DMA_COPY)
    tensor_list = [data, res]

    return sch, tensor_list


def _tranpose_notchange_last(data, shape_res, perm, dtype):
    """
    permutes the dimensions and the last axis is not transposed

    Parameters
    ----------
    data: tvm.tensor
        tensor of input data
    shape_res: list or tuple
        shape of output tensor
    perm: list or tuple
        permutation of the dimension of tensor
    dtype: str
        the data type

    Returns
    -------
    sch: tvm.schedule
        the compute schedule
    tensor_list: list
        list of tensor
    """
    def _permute(*index):
        """
        function of permute the dimensions of data

        """
        for i, item in enumerate(_perm_to_flag(perm)):
            if i == 0:
                res_axis = (index[item],)
            else:
                res_axis = res_axis + (index[item],)

        return res_axis

    data_ub = tvm.compute(shape_res, lambda *index: data(*_permute(*index)),
                          name="data_ub")
    res = tvm.compute(shape_res, lambda *index: data_ub(*index), name="res")
    sch = tvm.create_schedule(res.op)
    args = [sch, data, res, data_ub, shape_res, dtype]
    sch, tensor_list = _schedule_for_not_change_last(args)

    return sch, tensor_list


def _ceil_div(value, block):
    """
    integrate the input value by block

    """
    return (value + block - 1) // block


def _ceil_fill(value, block):
    """
    fill the input value by block

    """
    return _ceil_div(value, block)*block


# pylint: disable=locally-disabled,unused-argument
def _get_param_one_row_0231(tvm_ib, src_shape, dtype, core_divide):
    """
    calculate parameters for one row 0231 ir builder make function

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    n_i, _, h_i, w_i = src_shape
    num_ele_one_dim_data = h_i * w_i
    num_block_one_dim_data = _ceil_div(num_ele_one_dim_data, cp_align_len)
    num_row_group_one_core = 1
    num_row_group_in_data = num_block_one_dim_data*n_i
    num_row_group_one_group = num_row_group_one_core*device_core_num
    num_group_index = num_row_group_in_data // num_row_group_one_group
    num_group_mod = num_row_group_in_data % num_row_group_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "num_row_group_one_core": num_row_group_one_core,
                 "num_block_one_dim_data": num_block_one_dim_data,
                 "num_ele_one_dim_data": num_ele_one_dim_data,
                 "num_row_group_one_group": num_row_group_one_group}
    return param_map


def _reg_mov_batch_ci(args):
    """
    reg_move for c_i data

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, index, ub_offset,\
    res_offset, num_row, num_r = args

    ele_reg = 8
    r_cycle = num_row // ele_reg
    r_mod = num_row - ele_reg*r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_zero)
                                       * param.get("cp_align_len") + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_one)
                                       * param.get("cp_align_len") + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_two)
                                       * param.get("cp_align_len") + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_three)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_four)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_five)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_six)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_seven)
                                       * param.get("cp_align_len") + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset + num_cr*ele_reg
                                             + reg_zero)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset + num_cr*ele_reg
                                             + reg_one)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset + num_cr*ele_reg
                                             + reg_two)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset + num_cr*ele_reg
                                             + reg_three)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset + num_cr*ele_reg
                                             + reg_four)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset + num_cr*ele_reg
                                             + reg_five)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset + num_cr*ele_reg
                                             + reg_six)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset + num_cr*ele_reg
                                             + reg_seven)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    reg_addr[index] = r_mod
    with tvm_ib.for_range(0, reg_addr[index], name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (r_cycle*ele_reg + num_er)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(
                res_offset + r_cycle * ele_reg + num_er)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _reg_mov_batch_align(args):
    """
    reg_mov data for cp_align_len data

    """
    tvm_ib, data_res, data_tail, reg, res_offset, tail_offset,\
    len_align, num_align = args

    ele_reg = 8
    r_cycle = num_align // ele_reg
    r_mod = num_align - ele_reg*r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_res.access_ptr('r',
                                offset=(res_offset + len_align + num_cr*ele_reg
                                        + reg_zero))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_res.access_ptr('r',
                                offset=(res_offset + len_align + num_cr*ele_reg
                                        + reg_one))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_res.access_ptr('r',
                                offset=(res_offset + len_align + num_cr*ele_reg
                                        + reg_two))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_res.access_ptr('r',
                                offset=(res_offset + len_align + num_cr*ele_reg
                                        + reg_three))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_res.access_ptr('r',
                                offset=(res_offset + len_align + num_cr*ele_reg
                                        + reg_four))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_res.access_ptr('r',
                                offset=(res_offset + len_align + num_cr*ele_reg
                                        + reg_five))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_res.access_ptr('r',
                                offset=(res_offset + len_align + num_cr*ele_reg
                                        + reg_six))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_res.access_ptr('r',
                                offset=(res_offset + len_align + num_cr*ele_reg
                                        + reg_seven))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr('w', offset=tail_offset + num_cr*ele_reg
                                 + reg_zero),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr('w', offset=tail_offset + num_cr*ele_reg
                                 + reg_one),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr('w', offset=tail_offset + num_cr*ele_reg
                                 + reg_two),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr('w', offset=tail_offset + num_cr*ele_reg
                                 + reg_three),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr('w', offset=tail_offset + num_cr*ele_reg
                                 + reg_four),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr('w', offset=tail_offset + num_cr*ele_reg
                                 + reg_five),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr('w', offset=tail_offset + num_cr*ele_reg
                                 + reg_six),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr('w', offset=tail_offset + num_cr*ele_reg
                                 + reg_seven),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_res.access_ptr('r',
                                    offset=(res_offset + len_align
                                            + r_cycle * ele_reg + num_er))
            ))
            tvm_ib.emit(tvm.call_extern(
                data_tail.dtype, "reg_mov",
                data_tail.access_ptr('w', offset=tail_offset + r_cycle*ele_reg
                                     + num_er),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _ub_to_gm_one_row(args):
    """
    function of moving data from data_ub to dst for one row scene

    """
    tvm_ib, param, dst, data_ub, data_res, data_tail, reg, c_i, num_row,\
    num_n_before_core, num_ele_one_n, num_row_group_cur_dim_before,\
    reg_addr, index = args

    with tvm_ib.for_range(0, num_row, name="num_r") as num_r:
        args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
               index, 0, 0, c_i, num_r
        _reg_mov_batch_ci(args)

        with tvm_ib.if_scope(c_i % param.get("cp_align_len") > 0):
            len_align = c_i - param.get("cp_align_len")
            dst_offset = num_n_before_core*num_ele_one_n\
                         + num_row_group_cur_dim_before\
                         * param.get("cp_align_len")*c_i\
                         + num_r*c_i
            burst_len_dst = _ceil_div(len_align, param.get("cp_align_len"))
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))

            args = tvm_ib, data_res, data_tail, reg, 0, 0,\
                   len_align, param.get("cp_align_len")
            _reg_mov_batch_align(args)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr(
                                            'w', offset=dst_offset + len_align),
                                        data_tail.access_ptr("r", offset=0),
                                        0, 1, 1, 0, 0))

        with tvm_ib.else_scope():
            dst_offset = num_n_before_core*num_ele_one_n\
                         + num_row_group_cur_dim_before\
                         * param.get("cp_align_len")*c_i\
                         + num_r*c_i
            burst_len_dst = c_i // param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))


def _func_one_row_ir_0231(args):
    """
    function of moving data in one row 0231 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
    reg, reg_addr, num_g = args

    _, c_i, h_i, w_i = data.shape
    num_row_group_before_core = num_g*param.get("num_row_group_one_group")\
                                + param.get("block_index")\
                                * param.get("num_row_group_one_core")
    num_n_before_core = num_row_group_before_core\
                        // param.get("num_block_one_dim_data")
    num_row_group_cur_dim_before = num_row_group_before_core % param.get(
        "num_block_one_dim_data")
    num_ele_one_n = c_i * h_i * w_i

    # move from data(GM) to data_ub(UB)
    with tvm_ib.if_scope(param.get("num_ele_one_dim_data")
                         % param.get("cp_align_len") > 0):
        with tvm_ib.for_range(0, c_i, name="num_ci") as num_ci:
            ub_offset = num_ci*param.get("cp_align_len")
            data_offset = num_n_before_core*num_ele_one_n\
                          + num_ci*param.get("num_ele_one_dim_data")\
                          + num_row_group_cur_dim_before\
                          * param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, 1, 0, 0))
    with tvm_ib.else_scope():
        data_offset = num_n_before_core*num_ele_one_n\
                      + num_row_group_cur_dim_before*param.get("cp_align_len")
        src_stride = param.get("num_block_one_dim_data") - 1
        args = tvm_ib, param, data, data_ub, data_offset, 0, c_i, 1,\
               src_stride, 0
        _func_gm_to_ub(args)

    # move from data_ub(GM) to data_res(UB) to dst(GM)
    with tvm_ib.if_scope(num_row_group_cur_dim_before
                         < param.get("num_block_one_dim_data") - 1):
        num_row = param.get("cp_align_len")
        args = tvm_ib, param, dst, data_ub, data_res, data_tail, reg,\
               c_i, num_row, num_n_before_core, num_ele_one_n,\
               num_row_group_cur_dim_before, reg_addr, 0
        _ub_to_gm_one_row(args)
    with tvm_ib.else_scope():
        num_row = param.get("num_ele_one_dim_data")\
                  - num_row_group_cur_dim_before*param.get("cp_align_len")
        args = tvm_ib, param, dst, data_ub, data_res, data_tail, reg,\
               c_i, num_row, num_n_before_core, num_ele_one_n,\
               num_row_group_cur_dim_before, reg_addr, 1
        _ub_to_gm_one_row(args)


def _one_row_ir_0231(dst, data, core_divide):
    """
    function of making ir node builder for one row 0231 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_one_row_0231(tvm_ib, data.shape, dst.dtype, core_divide)
    c_i = data.shape[1]
    data_ub = _new_alloc(tvm_ib, dst.dtype, c_i*(param.get("cp_align_len") + 1),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, c_i,
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    data_tail = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                           "data_tail", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (8,), name='reg_addr',
                               scope=cce.scope_reg)

    with tvm_ib.for_range(0, param.get("num_group_index") + 1, name="num_g")\
            as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_g
            _func_one_row_ir_0231(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod")\
                       // param.get("num_row_group_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_tail, reg, reg_addr, num_g
                    _func_one_row_ir_0231(args)

    return tvm_ib.get()


def _get_param_more_row_0231(tvm_ib, src_shape, dtype, core_divide):
    """
    calculate parameters for more row 0231 ir builder make function

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = (UB_SIZE_B - 32) // core_divide
    ub_half = ub_bytes // 2
    n_i, c_i, h_i, w_i = src_shape
    num_ele_one_dim_data = h_i*w_i
    num_block_one_dim_data = _ceil_div(num_ele_one_dim_data, cp_align_len)
    num_block_in_data = num_block_one_dim_data*n_i*c_i
    num_block_in_ub_half = ub_half // 32
    num_row_group_one_core = num_block_in_ub_half // c_i
    num_block_one_core = num_row_group_one_core*c_i
    num_block_one_group = num_block_one_core*device_core_num
    num_group_index = num_block_in_data // num_block_one_group
    num_group_mod = num_block_in_data % num_block_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "num_block_one_core": num_block_one_core,
                 "num_block_one_group": num_block_one_group,
                 "num_block_one_dim_data": num_block_one_dim_data,
                 "num_ele_one_dim_data": num_ele_one_dim_data}

    return param_map


def _reg_mov_batch_more_one_store(args):
    """
    reg_mov data for first branch in more row 0231 scene

    """
    tvm_ib, data_ub, data_res, reg, num_row_cur, c_i, num_c = args

    ele_reg = 8
    r_cycle = num_row_cur // ele_reg
    r_mod = num_row_cur - ele_reg * r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_cur + num_cr*ele_reg
                                       + reg_zero))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_cur + num_cr*ele_reg
                                       + reg_one))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_cur + num_cr*ele_reg
                                       + reg_two))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_cur + num_cr*ele_reg
                                       + reg_three))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_cur + num_cr*ele_reg
                                       + reg_four))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_cur + num_cr*ele_reg
                                       + reg_five))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_cur + num_cr*ele_reg
                                       + reg_six))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_cur + num_cr*ele_reg
                                       + reg_seven))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_zero) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_one) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_two) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_three) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_four) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_five) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_six) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_seven) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_ub.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_ub.access_ptr('r',
                                   offset=(num_c * num_row_cur
                                           + r_cycle * ele_reg + num_er))
            ))
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                data_res.access_ptr('w', offset=(r_cycle * ele_reg + num_er)
                                    * c_i + num_c),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _reg_mov_batch_more_one(args):
    """
    reg_mov data for first branch in more row 0231 scene

    """
    tvm_ib, data_ub, data_res, reg, num_row_cur, c_i, num_r = args

    ele_reg = 8
    r_cycle = c_i // ele_reg
    r_mod = c_i - ele_reg * r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_zero)*num_row_cur
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_one)*num_row_cur
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_two)*num_row_cur
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_three)*num_row_cur
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_four)*num_row_cur
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_five)*num_row_cur
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_six)*num_row_cur
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_seven)
                                       * num_row_cur + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_zero),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_one),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_two),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_three),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_four),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_five),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_six),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_seven),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))

    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_ub.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_ub.access_ptr('r',
                                   offset=((r_cycle * ele_reg + num_er)
                                           * num_row_cur + num_r))
            ))
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                data_res.access_ptr('w',
                                    offset=num_r * c_i + r_cycle * ele_reg
                                    + num_er),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _reg_mov_batch_head_store(args):
    """
    reg_mov data for head store in more row 0231 scene

    """
    tvm_ib, data_ub, data_res, reg, num_row_head_actual,\
    num_row_total_space, c_i, num_c = args

    ele_reg = 8
    r_cycle = num_row_head_actual // ele_reg
    r_mod = num_row_head_actual - ele_reg * r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=num_c * num_row_total_space
                               + num_cr*ele_reg + reg_zero)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=num_c * num_row_total_space
                               + num_cr*ele_reg + reg_one)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=num_c * num_row_total_space
                               + num_cr*ele_reg + reg_two)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=num_c * num_row_total_space
                               + num_cr*ele_reg + reg_three)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=num_c * num_row_total_space
                               + num_cr*ele_reg + reg_four)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=num_c * num_row_total_space
                               + num_cr*ele_reg + reg_five)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=num_c * num_row_total_space
                               + num_cr*ele_reg + reg_six)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=num_c * num_row_total_space
                               + num_cr*ele_reg + reg_seven)
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_zero) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_one) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_two) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_three) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_four) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_five) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_six) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_seven) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_ub.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_ub.access_ptr('r',
                                   offset=num_c * num_row_total_space
                                   + r_cycle * ele_reg + num_er)
            ))
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                data_res.access_ptr('w', offset=(r_cycle * ele_reg + num_er)
                                    * c_i + num_c),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _reg_mov_batch_head(args):
    """
    reg_mov data for head in more row 0231 scene

    """
    tvm_ib, data_ub, data_res, reg,\
    num_row_total_space, c_i, num_r = args

    ele_reg = 8
    r_cycle = c_i // ele_reg
    r_mod = c_i - ele_reg * r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(num_cr*ele_reg + reg_zero)
                               * num_row_total_space + num_r)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(num_cr*ele_reg + reg_one)
                               * num_row_total_space + num_r)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(num_cr*ele_reg + reg_two)
                               * num_row_total_space + num_r)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(num_cr*ele_reg + reg_three)
                               * num_row_total_space + num_r)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(num_cr*ele_reg + reg_four)
                               * num_row_total_space + num_r)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(num_cr*ele_reg + reg_five)
                               * num_row_total_space + num_r)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(num_cr*ele_reg + reg_six)
                               * num_row_total_space + num_r)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(num_cr*ele_reg + reg_seven)
                               * num_row_total_space + num_r)
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_zero),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_one),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_two),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_three),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_four),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_five),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_six),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_seven),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))

    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_ub.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_ub.access_ptr('r',
                                   offset=(r_cycle*ele_reg + num_er)
                                   * num_row_total_space + num_r)
            ))
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                data_res.access_ptr('w', offset=num_r * c_i + r_cycle*ele_reg
                                    + num_er),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _reg_mov_batch_mid_store(args):
    """
    reg_mov data for middle store in more row 0231 scene

    """
    tvm_ib, param, data_ub, data_res, reg, num_row_mid_actual,\
    num_row_total_space, num_row_group_dim_head, num_row_head_actual,\
    c_i, num_md, num_c = args

    ele_reg = 8
    r_cycle = num_row_mid_actual // ele_reg
    r_mod = num_row_mid_actual - ele_reg * r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    ub_offset = num_c * num_row_total_space\
                    + (num_row_group_dim_head
                       + num_md*param.get("num_block_one_dim_data"))\
                    * param.get("cp_align_len")
    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_zero)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_one)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_two)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_three)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_four)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_five)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_six)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_seven)
        ))

        ub_res_offset_mid = (num_row_head_actual + num_md * num_row_mid_actual
                             + (num_cr*ele_reg + reg_zero)) * c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        ub_res_offset_mid = (num_row_head_actual + num_md * num_row_mid_actual
                             + (num_cr*ele_reg + reg_one)) * c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        ub_res_offset_mid = (num_row_head_actual + num_md * num_row_mid_actual
                             + (num_cr*ele_reg + reg_two)) * c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        ub_res_offset_mid = (num_row_head_actual + num_md * num_row_mid_actual
                             + (num_cr*ele_reg + reg_three)) * c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        ub_res_offset_mid = (num_row_head_actual + num_md * num_row_mid_actual
                             + (num_cr*ele_reg + reg_four)) * c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        ub_res_offset_mid = (num_row_head_actual + num_md * num_row_mid_actual
                             + (num_cr*ele_reg + reg_five)) * c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        ub_res_offset_mid = (num_row_head_actual + num_md * num_row_mid_actual
                             + (num_cr*ele_reg + reg_six)) * c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        ub_res_offset_mid = (num_row_head_actual + num_md * num_row_mid_actual
                             + (num_cr*ele_reg + reg_seven)) * c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_ub.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_ub.access_ptr('r',
                                   offset=ub_offset + r_cycle * ele_reg
                                   + num_er)
            ))
            ub_res_offset_mid = (num_row_head_actual
                                 + num_md * num_row_mid_actual
                                 + (r_cycle * ele_reg + num_er)) * c_i + num_c
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                data_res.access_ptr('w',
                                    offset=ub_res_offset_mid),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _reg_mov_batch_mid(args):
    """
    reg_mov data for middle in more row 0231 scene

    """
    tvm_ib, param, data_ub, data_res, reg, num_row_mid_actual,\
    num_row_total_space, num_row_group_dim_head, num_row_head_actual,\
    c_i, num_md, num_r = args

    ele_reg = 8
    r_cycle = c_i // ele_reg
    r_mod = c_i - ele_reg * r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    ub_offset = (num_row_group_dim_head
                 + num_md*param.get("num_block_one_dim_data"))\
                * param.get("cp_align_len") + num_r
    ub_res_offset_mid = (num_row_head_actual
                         + num_md * num_row_mid_actual + num_r) * c_i
    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_zero)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_one)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_two)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_three)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_four)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_five)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_six)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_seven)
                               * num_row_total_space)
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid
                                + (num_cr*ele_reg + reg_zero)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid
                                + (num_cr*ele_reg + reg_one)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid
                                + (num_cr*ele_reg + reg_two)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid
                                + (num_cr*ele_reg + reg_three)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid
                                + (num_cr*ele_reg + reg_four)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid
                                + (num_cr*ele_reg + reg_five)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid
                                + (num_cr*ele_reg + reg_six)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid
                                + (num_cr*ele_reg + reg_seven)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_ub.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_ub.access_ptr('r',
                                   offset=ub_offset
                                   + (r_cycle*ele_reg + num_er)
                                   * num_row_total_space)
            ))
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                data_res.access_ptr('w',
                                    offset=ub_res_offset_mid
                                    + (r_cycle*ele_reg + num_er)),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _reg_mov_batch_tail_store(args):
    """
    reg_mov data for tail store in more row 0231 scene

    """
    tvm_ib, param, data_ub, data_res, reg, num_row_total_space,\
    num_row_group_dim_head, num_row_head_actual, num_row_mid_actual,\
    num_mid_n, c_i, num_c, num_row_tail_reg, num_row_tail = args

    ele_reg = 8
    r_cycle = num_row_tail_reg // ele_reg
    r_mod = num_row_tail - ele_reg * r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    ub_offset = num_c*num_row_total_space\
                + (num_row_group_dim_head + num_mid_n
                   * param.get("num_block_one_dim_data"))\
                * param.get("cp_align_len")
    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_zero)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_one)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_two)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_three)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_four)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_five)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_six)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_seven)
        ))

        ub_res_offset_tail = (num_row_head_actual
                              + num_mid_n*num_row_mid_actual
                              + (num_cr*ele_reg + reg_zero))*c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        ub_res_offset_tail = (num_row_head_actual
                              + num_mid_n*num_row_mid_actual
                              + (num_cr*ele_reg + reg_one))*c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        ub_res_offset_tail = (num_row_head_actual
                              + num_mid_n*num_row_mid_actual
                              + (num_cr*ele_reg + reg_two))*c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        ub_res_offset_tail = (num_row_head_actual
                              + num_mid_n*num_row_mid_actual
                              + (num_cr*ele_reg + reg_three))*c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        ub_res_offset_tail = (num_row_head_actual
                              + num_mid_n*num_row_mid_actual
                              + (num_cr*ele_reg + reg_four))*c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        ub_res_offset_tail = (num_row_head_actual
                              + num_mid_n*num_row_mid_actual
                              + (num_cr*ele_reg + reg_five))*c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        ub_res_offset_tail = (num_row_head_actual
                              + num_mid_n*num_row_mid_actual
                              + (num_cr*ele_reg + reg_six))*c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        ub_res_offset_tail = (num_row_head_actual
                              + num_mid_n*num_row_mid_actual
                              + (num_cr*ele_reg + reg_seven))*c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_ub.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_ub.access_ptr('r',
                                   offset=ub_offset + r_cycle * ele_reg
                                   + num_er)
            ))
            ub_res_offset_tail = (num_row_head_actual
                                  + num_mid_n*num_row_mid_actual
                                  + (r_cycle * ele_reg + num_er))*c_i + num_c
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                data_res.access_ptr('w', offset=ub_res_offset_tail),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _reg_mov_batch_tail(args):
    """
    reg_mov data for tail in more row 0231 scene

    """
    tvm_ib, param, data_ub, data_res, reg, num_row_total_space,\
    num_row_group_dim_head, num_row_head_actual, num_row_mid_actual,\
    num_mid_n, c_i, num_r = args

    ele_reg = 8
    r_cycle = c_i // ele_reg
    r_mod = c_i - ele_reg * r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    ub_offset = (num_row_group_dim_head + num_mid_n * param.get(
        "num_block_one_dim_data")) \
                     * param.get("cp_align_len") + num_r
    ub_res_offset_tail = (num_row_head_actual
                          + num_mid_n * num_row_mid_actual + num_r) * c_i
    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_zero)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_one)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_two)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_three)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_four)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_five)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_six)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_seven)
                               * num_row_total_space)
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail + num_cr*ele_reg
                                + reg_zero),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail + num_cr*ele_reg
                                + reg_one),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail + num_cr*ele_reg
                                + reg_two),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail + num_cr*ele_reg
                                + reg_three),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail + num_cr*ele_reg
                                + reg_four),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail + num_cr*ele_reg
                                + reg_five),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail + num_cr*ele_reg
                                + reg_six),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail + num_cr*ele_reg
                                + reg_seven),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_ub.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_ub.access_ptr('r',
                                   offset=ub_offset + (r_cycle*ele_reg + num_er)
                                   * num_row_total_space)
            ))
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                data_res.access_ptr('w', offset=ub_res_offset_tail
                                    + r_cycle*ele_reg + num_er),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _func_more_row_ir_0231(args):
    """
    function of moving data in more row 0231 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
    reg, reg_addr, num_g, num_block_cur_core = args

    _, c_i, h_i, w_i = data.shape
    num_row_group_cur_core = num_block_cur_core // c_i
    num_block_before_core = num_g*param.get("num_block_one_group")\
                            + param.get("block_index")\
                            * param.get("num_block_one_core")
    num_row_group_before_core = num_block_before_core // c_i
    num_n_before_core = num_row_group_before_core\
                        // param.get("num_block_one_dim_data")
    num_row_group_cur_dim_before = num_row_group_before_core\
                                   % param.get("num_block_one_dim_data")
    num_row_group_dim_head = param.get("num_block_one_dim_data")\
                             - num_row_group_cur_dim_before
    num_ele_one_n = c_i*h_i*w_i

    with tvm_ib.if_scope(num_row_group_dim_head > num_row_group_cur_core):
        # move from data(GM) to data_ub(UB)
        with tvm_ib.if_scope(param.get("num_ele_one_dim_data")
                             % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, c_i, name="num_ci") as num_ci:
                data_offset_cur = num_n_before_core * num_ele_one_n\
                                  + num_row_group_cur_dim_before\
                                  * param.get("cp_align_len")\
                                  + num_ci*param.get("num_ele_one_dim_data")
                ub_offset_cur = num_ci*num_row_group_cur_core\
                                * param.get("cp_align_len")
                burst_len_cur = num_row_group_cur_core
                tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset_cur),
                                            data.access_ptr(
                                                'r',
                                                offset=data_offset_cur),
                                            0, 1, burst_len_cur, 0, 0))
        with tvm_ib.else_scope():
            data_offset = num_n_before_core * num_ele_one_n\
                          + num_row_group_cur_dim_before\
                          * param.get("cp_align_len")
            burst_len_data = num_row_group_cur_core
            src_stride = param.get("num_block_one_dim_data") - burst_len_data
            args = tvm_ib, param, data, data_ub, data_offset, 0, c_i,\
                   burst_len_data, src_stride, 0
            _func_gm_to_ub(args)

        # move from data_ub to data_res
        num_row_cur = num_row_group_cur_core*param.get("cp_align_len")
        with tvm_ib.if_scope(c_i >= 8):
            with tvm_ib.for_range(0, num_row_cur, name="num_r") as num_r:
                args = tvm_ib, data_ub, data_res, reg, num_row_cur,\
                       c_i, num_r
                _reg_mov_batch_more_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, c_i, name="num_c") as num_c:
                args = tvm_ib, data_ub, data_res, reg, num_row_cur,\
                       c_i, num_c
                _reg_mov_batch_more_one_store(args)

        # move from data_res to dst (32B align)
        dst_offset = num_n_before_core*num_ele_one_n\
                     + num_row_group_cur_dim_before\
                     * param.get("cp_align_len")*c_i
        burst_len_dst = num_row_group_cur_core*c_i
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))
    with tvm_ib.if_scope(num_row_group_dim_head <= num_row_group_cur_core):
        num_row_group_after = num_row_group_cur_core - num_row_group_dim_head
        reg_addr[0] = num_row_group_after
        num_mid_n = reg_addr[0] // param.get("num_block_one_dim_data")
        num_row_group_tail = num_row_group_after - param.get(
            "num_block_one_dim_data") * num_mid_n

        # move from data(GM) to data_ub(UB)
        with tvm_ib.if_scope(param.get("num_ele_one_dim_data") % param.get(
            "cp_align_len") > 0):
            # move data for head
            with tvm_ib.if_scope(num_row_group_dim_head > 0):
                with tvm_ib.for_range(0, c_i, name="num_ci") as num_ci:
                    ub_offset_head = num_ci*num_row_group_cur_core\
                                     * param.get("cp_align_len")
                    data_offset_head = num_n_before_core * num_ele_one_n\
                                       + num_row_group_cur_dim_before\
                                       * param.get("cp_align_len")\
                                       + num_ci\
                                       * param.get("num_ele_one_dim_data")
                    burst_len_head = num_row_group_dim_head
                    tvm_ib.emit(
                        tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset_head),
                                        data.access_ptr(
                                            'r',
                                            offset=data_offset_head),
                                        0, 1, burst_len_head, 0, 0))
            # move data for middle
            with tvm_ib.if_scope(num_mid_n > 0):
                with tvm_ib.for_range(0, num_mid_n, name="num_m") as num_m:
                    with tvm_ib.for_range(0, c_i, name="num_ci") as num_ci:
                        ub_offset_mid = (num_ci*num_row_group_cur_core
                                         + num_row_group_dim_head
                                         + num_m
                                         * param.get("num_block_one_dim_data"))\
                                        * param.get("cp_align_len")
                        data_offset_mid = (num_n_before_core + num_m + 1)\
                                          * num_ele_one_n\
                                          + num_ci\
                                          * param.get("num_ele_one_dim_data")
                        burst_len_mid = param.get("num_block_one_dim_data")
                        with tvm_ib.if_scope(burst_len_mid <= 65535):
                            tvm_ib.emit(
                                tvm.call_extern(data_ub.dtype,
                                                "copy_gm_to_ubuf",
                                                data_ub.access_ptr(
                                                    "w",
                                                    offset=ub_offset_mid),
                                                data.access_ptr(
                                                    'r',
                                                    offset=data_offset_mid),
                                                0, 1, burst_len_mid, 0, 0))
            # move data for tail
            with tvm_ib.if_scope(num_row_group_tail > 0):
                with tvm_ib.for_range(0, c_i, name="num_ci") as num_ci:
                    ub_offset_tail = (num_ci*num_row_group_cur_core
                                      + num_row_group_dim_head
                                      + num_mid_n
                                      * param.get("num_block_one_dim_data"))\
                                     * param.get("cp_align_len")
                    data_offset_tail = (num_n_before_core + num_mid_n + 1)\
                                       * num_ele_one_n\
                                       + num_ci\
                                       * param.get("num_ele_one_dim_data")
                    burst_len_tail = num_row_group_tail
                    tvm_ib.emit(
                        tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset_tail),
                                        data.access_ptr(
                                            'r', offset=data_offset_tail),
                                        0, 1, burst_len_tail, 0, 0))

        with tvm_ib.else_scope():
            # move data for head
            with tvm_ib.if_scope(num_row_group_dim_head > 0):
                data_offset_head = num_n_before_core * num_ele_one_n \
                                   + num_row_group_cur_dim_before * param.get(
                                       "cp_align_len")
                burst_len_head = num_row_group_dim_head
                src_stride_head = param.get(
                    "num_block_one_dim_data") - burst_len_head
                dst_stride_head = num_row_group_after
                args = tvm_ib, param, data, data_ub, data_offset_head, 0,\
                       c_i, burst_len_head, src_stride_head, dst_stride_head
                _func_gm_to_ub(args)
            # move data for middle
            with tvm_ib.if_scope(num_mid_n > 0):
                with tvm_ib.for_range(0, num_mid_n, name="num_m") as num_m:
                    ub_offset_mid = (num_row_group_dim_head + num_m * param.get(
                        "num_block_one_dim_data")) * param.get("cp_align_len")
                    data_offset_mid = (num_n_before_core + num_m + 1)\
                                      * num_ele_one_n
                    burst_len_mid = param.get("num_block_one_dim_data")
                    dst_stride_mid = num_row_group_cur_core - param.get(
                        "num_block_one_dim_data")
                    with tvm_ib.if_scope(burst_len_mid <= 65535):
                        args = tvm_ib, param, data, data_ub, data_offset_mid,\
                               ub_offset_mid, c_i, burst_len_mid, 0,\
                               dst_stride_mid
                        _func_gm_to_ub(args)

            # move data for tail
            with tvm_ib.if_scope(num_row_group_tail > 0):
                ub_offset_tail = (num_row_group_dim_head + num_mid_n
                                  * param.get("num_block_one_dim_data"))\
                                 * param.get("cp_align_len")
                data_offset_tail = (num_n_before_core + num_mid_n + 1)\
                                   * num_ele_one_n
                burst_len_tail = num_row_group_tail
                src_stride_tail = param.get(
                    "num_block_one_dim_data") - burst_len_tail
                dst_stride_tail = num_row_group_cur_core - num_row_group_tail
                args = tvm_ib, param, data, data_ub, data_offset_tail,\
                       ub_offset_tail, c_i, burst_len_tail, src_stride_tail,\
                       dst_stride_tail
                _func_gm_to_ub(args)

        # move from data_ub(UB) to data_res(UB)
        with tvm_ib.if_scope(param.get("num_ele_one_dim_data")
                             % param.get("cp_align_len") > 0):
            num_row_total_space = num_row_group_cur_core\
                                  * param.get("cp_align_len")
            # move data for head
            num_row_head_actual = (h_i*w_i) - (num_row_group_cur_dim_before
                                               * param.get("cp_align_len"))
            with tvm_ib.if_scope(c_i >= 8):
                with tvm_ib.for_range(0, num_row_head_actual,
                                      name="num_r") as num_r:
                    args = tvm_ib, data_ub, data_res, reg,\
                           num_row_total_space, c_i, num_r
                    _reg_mov_batch_head(args)
            with tvm_ib.else_scope():
                with tvm_ib.for_range(0, c_i, name="num_c") as num_c:
                    args = tvm_ib, data_ub, data_res, reg,\
                           num_row_head_actual, num_row_total_space, c_i, num_c
                    _reg_mov_batch_head_store(args)
            # move data for middle
            num_row_mid_actual = param.get("num_ele_one_dim_data")

            with tvm_ib.if_scope(c_i >= 8):
                with tvm_ib.for_range(0, num_mid_n, name="num_md") as num_md:
                    with tvm_ib.for_range(0, num_row_mid_actual,
                                          name="num_r") as num_r:
                        args = tvm_ib, param, data_ub, data_res, reg,\
                               num_row_mid_actual, num_row_total_space,\
                               num_row_group_dim_head, num_row_head_actual, \
                               c_i, num_md, num_r
                        _reg_mov_batch_mid(args)
            with tvm_ib.else_scope():
                with tvm_ib.for_range(0, num_mid_n, name="num_md") as num_md:
                    with tvm_ib.for_range(0, c_i, name="num_c") as num_c:
                        args = tvm_ib, param, data_ub, data_res, reg,\
                               num_row_mid_actual, num_row_total_space,\
                               num_row_group_dim_head, num_row_head_actual,\
                               c_i, num_md, num_c
                        _reg_mov_batch_mid_store(args)
            # move data for tail
            num_row_tail = num_row_group_tail*param.get("cp_align_len")
            reg_addr[8] = num_row_tail

            with tvm_ib.if_scope(c_i >= 8):
                with tvm_ib.for_range(0, num_row_tail, name="num_r") as num_r:
                    args = tvm_ib, param, data_ub, data_res, reg,\
                           num_row_total_space, num_row_group_dim_head,\
                           num_row_head_actual, num_row_mid_actual, num_mid_n,\
                           c_i, num_r
                    _reg_mov_batch_tail(args)
            with tvm_ib.else_scope():
                with tvm_ib.for_range(0, c_i, name="num_c") as num_c:
                    args = tvm_ib, param, data_ub, data_res, reg,\
                           num_row_total_space, num_row_group_dim_head,\
                           num_row_head_actual, num_row_mid_actual, num_mid_n,\
                           c_i, num_c, reg_addr[8], num_row_tail
                    _reg_mov_batch_tail_store(args)

        with tvm_ib.else_scope():
            num_row_total = num_row_group_cur_core*param.get("cp_align_len")
            with tvm_ib.if_scope(c_i >= 8):
                with tvm_ib.for_range(0, num_row_total, name="num_r") as num_r:
                    args = tvm_ib, data_ub, data_res, reg,\
                           num_row_total, c_i, num_r
                    _reg_mov_batch_head(args)
            with tvm_ib.else_scope():
                with tvm_ib.for_range(0, c_i, name="num_c") as num_c:
                    args = tvm_ib, data_ub, data_res, reg,\
                           num_row_total, num_row_total, c_i, num_c
                    _reg_mov_batch_head_store(args)

        # move from data_res(UB) to dst(GM)
        num_row_head_actual = (h_i * w_i) - (
            num_row_group_cur_dim_before * param.get("cp_align_len"))
        num_row_mid_actual = param.get("num_ele_one_dim_data")
        num_row_tail = num_row_group_tail * param.get("cp_align_len")
        total_len = (num_row_head_actual + num_row_mid_actual*num_mid_n
                     + num_row_tail)*c_i
        reg_addr[1] = total_len
        with tvm_ib.if_scope(reg_addr[1] % param.get("cp_align_len") > 0):
            with tvm_ib.if_scope(reg_addr[1] > param.get("cp_align_len")):
                total_len_32b_align = reg_addr[1] - param.get("cp_align_len")
                burst_len_align = _ceil_div(total_len_32b_align,
                                            param.get("cp_align_len"))
                dst_offset = num_n_before_core * num_ele_one_n \
                             + num_row_group_cur_dim_before * param.get(
                                 "cp_align_len") * c_i
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr("r", offset=0),
                                            0, 1, burst_len_align, 0, 0))

                args = tvm_ib, data_res, data_tail, reg, 0, 0,\
                       total_len_32b_align, param.get("cp_align_len")
                _reg_mov_batch_align(args)
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w',
                                                offset=dst_offset
                                                + total_len_32b_align),
                                            data_tail.access_ptr("r", offset=0),
                                            0, 1, 1, 0, 0))

            with tvm_ib.else_scope():
                dst_offset = num_n_before_core * num_ele_one_n \
                             + num_row_group_cur_dim_before * param.get(
                                 "cp_align_len") * c_i
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr("r", offset=0),
                                            0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            burst_len_dst = reg_addr[1] // param.get("cp_align_len")
            dst_offset = num_n_before_core * num_ele_one_n \
                         + num_row_group_cur_dim_before\
                         * param.get("cp_align_len")*c_i
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))


def _more_row_ir_0231(dst, data, core_divide):
    """
    function of making ir node builder for more row 0231 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_more_row_0231(tvm_ib, data.shape, dst.dtype, core_divide)
    data_ub = _new_alloc(tvm_ib, dst.dtype, param.get('num_block_one_core')
                         * param.get("cp_align_len"),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, param.get('num_block_one_core')
                          * param.get("cp_align_len"),
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    data_tail = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                           "data_tail", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (9,), name='reg_addr',
                               scope=cce.scope_reg)

    with tvm_ib.for_range(0, param.get("num_group_index") + 1, name="num_g")\
            as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_g, param.get("num_block_one_core")
            _func_more_row_ir_0231(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod")\
                       // param.get("num_block_one_core")
            num_block_mod = param.get("num_group_mod")\
                            % param.get("num_block_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_tail, reg, reg_addr, num_g, param.get(
                               "num_block_one_core")
                    _func_more_row_ir_0231(args)
            with tvm_ib.if_scope(num_block_mod > 0):
                with tvm_ib.if_scope(tvm.all(param.get("block_index")
                                             < (num_core + 1),
                                             param.get("block_index")
                                             > (num_core - 1))):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_tail, reg, reg_addr, num_g, num_block_mod
                    _func_more_row_ir_0231(args)

    return tvm_ib.get()


def _get_param_split_row_0231(tvm_ib, src_shape, dtype, core_divide):
    """
    calculate parameters for split row 0231 ir builder make function

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = ((UB_SIZE_B - 32*(cp_align_len + 1)) // 2) // core_divide
    n_i, c_i, h_i, w_i = src_shape
    num_ele_one_dim_data = h_i*w_i
    num_block_one_dim_data = _ceil_div(num_ele_one_dim_data, cp_align_len)
    num_block_in_data = num_block_one_dim_data*n_i*c_i
    num_block_one_n = num_block_one_dim_data*c_i
    ub_ele = ub_bytes // float_size
    num_block_one_core = ub_ele // (cp_align_len + 1)
    num_block_one_group = num_block_one_core*device_core_num
    num_group_index = num_block_in_data // num_block_one_group
    num_group_mod = num_block_in_data % num_block_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "num_block_one_core": num_block_one_core,
                 "num_block_one_group": num_block_one_group,
                 "num_block_one_dim_data": num_block_one_dim_data,
                 "num_ele_one_dim_data": num_ele_one_dim_data,
                 "num_block_one_n": num_block_one_n}

    return param_map


def _ub_to_gm_split_one(args):
    """
    function of moving data from data_ub to dst in split row 0231 function

    """
    tvm_ib, param, dst, data_ub, data_res, data_tail, reg, reg_addr,\
    num_n_before_core, num_row_group_cur_n, num_block_cur_row_group,\
    num_ele_one_n, c_i, ub_offset, res_offset, tail_offset, num_block,\
    num_row, n_index = args

    with tvm_ib.for_range(0, num_row, name="num_r") as num_r:
        args = tvm_ib, param, data_ub, data_res, reg, reg_addr, n_index,\
               ub_offset, res_offset, num_block, num_r
        _reg_mov_batch_ci(args)

        with tvm_ib.if_scope(num_block % param.get("cp_align_len") > 0):
            num_len_align = num_block - param.get("cp_align_len")
            dst_offset = num_n_before_core*num_ele_one_n\
                         + (num_row_group_cur_n*param.get("cp_align_len")
                            + num_r)*c_i\
                         + num_block_cur_row_group
            burst_len_one = num_len_align + param.get("cp_align_len") - 1
            reg_addr[n_index] = burst_len_one
            burst_len_dst = reg_addr[n_index] // param.get("cp_align_len")

            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

            args = tvm_ib, data_res, data_tail, reg, res_offset,\
                   tail_offset, num_len_align, param.get("cp_align_len")
            _reg_mov_batch_align(args)

            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr(
                                            'w',
                                            offset=dst_offset + num_len_align),
                                        data_tail.access_ptr(
                                            "r", offset=tail_offset),
                                        0, 1, 1, 0, 0))

        with tvm_ib.else_scope():
            dst_offset = num_n_before_core*num_ele_one_n\
                         + (num_row_group_cur_n*param.get("cp_align_len")
                            + num_r)*c_i\
                         + num_block_cur_row_group
            burst_len_dst = num_block // param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _ub_to_gm_split_two(args):
    """
    function of moving data from data_ub to dst in split row 0231 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail, reg, reg_addr,\
    num_n_before_core, num_row_group_cur_n, num_block_cur_row_group,\
    num_ele_one_n, c_i, ub_offset, res_offset, tail_offset, num_block,\
    num_row, n_index, num_n_before_tail, num_block_tail_row_group,\
    num_row_group_tail_n = args

    with tvm_ib.for_range(0, num_row, name="num_r") as num_r:
        args = tvm_ib, param, data_ub, data_res, reg, reg_addr, n_index,\
               ub_offset, res_offset, num_block, num_r
        _reg_mov_batch_ci(args)

        with tvm_ib.if_scope(num_block % param.get("cp_align_len") > 0):
            with tvm_ib.if_scope(num_block >= param.get("cp_align_len")):
                num_len_align = num_block - param.get("cp_align_len")
                dst_offset = num_n_before_core * num_ele_one_n \
                             + (num_row_group_cur_n * param.get("cp_align_len")
                                + num_r) * c_i \
                             + num_block_cur_row_group
                burst_len_one = num_len_align + param.get("cp_align_len") - 1
                reg_addr[n_index] = burst_len_one
                burst_len_dst = reg_addr[n_index] // param.get("cp_align_len")

                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))

                args = tvm_ib, data_res, data_tail, reg, res_offset, \
                       tail_offset, num_len_align, param.get("cp_align_len")
                _reg_mov_batch_align(args)

                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w',
                                                offset=dst_offset
                                                + num_len_align),
                                            data_tail.access_ptr(
                                                "r", offset=tail_offset),
                                            0, 1, 1, 0, 0))
            with tvm_ib.else_scope():
                num_block_align = param.get("cp_align_len") - num_block
                with tvm_ib.if_scope(num_r < num_row - 1):
                    with tvm_ib.if_scope(param.get("num_ele_one_dim_data")
                                         % param.get("cp_align_len") > 0):
                        with tvm_ib.for_range(0, num_block_align,
                                              name="num_ba") as num_ba:
                            data_offset = num_n_before_core * num_ele_one_n\
                                          + num_ba\
                                          * param.get("num_ele_one_dim_data")\
                                          + num_row_group_cur_n\
                                          * param.get("cp_align_len")\
                                          + num_r + 1
                            tail_offset = num_ba * param.get("cp_align_len")
                            tvm_ib.emit(
                                tvm.call_extern(data_tail.dtype,
                                                "copy_gm_to_ubuf",
                                                data_tail.access_ptr(
                                                    "w", offset=tail_offset),
                                                data.access_ptr(
                                                    'r',
                                                    offset=data_offset),
                                                0, 1, 1, 0, 0))
                    with tvm_ib.else_scope():
                        data_offset = num_n_before_core * num_ele_one_n\
                                      + num_row_group_cur_n\
                                      * param.get("cp_align_len")\
                                      + num_r + 1
                        src_stride = param.get("num_ele_one_dim_data")\
                                     // param.get("cp_align_len") - 1
                        args = tvm_ib, param, data, data_tail, data_offset, 0,\
                               num_block_align, 1, src_stride, 0
                        _func_gm_to_ub(args)
                with tvm_ib.else_scope():
                    with tvm_ib.if_scope(
                        param.get("num_ele_one_dim_data") % param.get(
                            "cp_align_len") > 0):
                        with tvm_ib.for_range(0, num_block_align,
                                              name="num_ba") as num_ba:
                            data_offset = num_n_before_tail * num_ele_one_n\
                                          + (num_block_tail_row_group + num_ba)\
                                          * param.get("num_ele_one_dim_data")\
                                          + num_row_group_tail_n\
                                          * param.get("cp_align_len")
                            tail_offset = num_ba*param.get("cp_align_len")
                            tvm_ib.emit(
                                tvm.call_extern(data_tail.dtype,
                                                "copy_gm_to_ubuf",
                                                data_tail.access_ptr(
                                                    "w", offset=tail_offset),
                                                data.access_ptr(
                                                    'r',
                                                    offset=data_offset),
                                                0, 1, 1, 0, 0))
                    with tvm_ib.else_scope():
                        data_offset = num_n_before_tail * num_ele_one_n \
                                      + num_block_tail_row_group\
                                      * param.get("num_ele_one_dim_data")\
                                      + num_row_group_tail_n\
                                      * param.get("cp_align_len")
                        src_stride = param.get("num_ele_one_dim_data")\
                                     // param.get("cp_align_len") - 1
                        args = tvm_ib, param, data, data_tail, data_offset, 0,\
                               num_block_align, 1, src_stride, 0
                        _func_gm_to_ub(args)

                with tvm_ib.for_range(0, num_block_align, name="num_ba")\
                        as num_ba:
                    tvm_ib.emit(tvm.call_extern(
                        data_tail.dtype, "reg_mov",
                        tvm.call_extern(reg.dtype, "reg", reg[0]),
                        data_tail.access_ptr(
                            'r', offset=num_ba*param.get("cp_align_len"))
                    ))
                    tvm_ib.emit(tvm.call_extern(
                        data_res.dtype, "reg_mov",
                        data_res.access_ptr(
                            'w', offset=res_offset + num_block + num_ba),
                        tvm.call_extern(reg.dtype, "reg", reg[0])
                    ))

                dst_offset = num_n_before_core * num_ele_one_n \
                             + (num_row_group_cur_n * param.get("cp_align_len")
                                + num_r) * c_i \
                             + num_block_cur_row_group
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, 1, 1, 0, 0))

        with tvm_ib.else_scope():
            dst_offset = num_n_before_core*num_ele_one_n\
                         + (num_row_group_cur_n*param.get("cp_align_len")
                            + num_r)*c_i\
                         + num_block_cur_row_group
            burst_len_dst = num_block // param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _ub_to_gm_split_three(args):
    """
    function of moving data from data_ub to dst in split row 0231 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail, reg, reg_addr,\
    num_n_before_core, num_row_group_cur_n, num_block_cur_row_group,\
    num_ele_one_n, c_i, ub_offset, res_offset, tail_offset, num_block,\
    num_row, n_index = args

    with tvm_ib.for_range(0, num_row, name="num_r") as num_r:
        args = tvm_ib, param, data_ub, data_res, reg, reg_addr, n_index,\
               ub_offset, res_offset, num_block, num_r
        _reg_mov_batch_ci(args)

        with tvm_ib.if_scope(num_block % param.get("cp_align_len") > 0):
            with tvm_ib.if_scope(num_block >= param.get("cp_align_len")):
                num_len_align = num_block - param.get("cp_align_len")
                dst_offset = num_n_before_core * num_ele_one_n \
                             + (num_row_group_cur_n * param.get("cp_align_len")
                                + num_r) * c_i \
                             + num_block_cur_row_group
                burst_len_one = num_len_align + param.get("cp_align_len") - 1
                reg_addr[n_index] = burst_len_one
                burst_len_dst = reg_addr[n_index] // param.get("cp_align_len")

                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))

                args = tvm_ib, data_res, data_tail, reg, res_offset, \
                       tail_offset, num_len_align, param.get("cp_align_len")
                _reg_mov_batch_align(args)

                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w',
                                                offset=dst_offset
                                                + num_len_align),
                                            data_tail.access_ptr(
                                                "r", offset=tail_offset),
                                            0, 1, 1, 0, 0))
            with tvm_ib.else_scope():
                num_block_align = param.get("cp_align_len") - num_block
                with tvm_ib.if_scope(
                    param.get("num_ele_one_dim_data")
                    % param.get("cp_align_len") > 0):
                    with tvm_ib.for_range(0, num_block_align,
                                          name="num_ba") as num_ba:
                        data_offset = num_n_before_core * num_ele_one_n\
                                      + (num_block_cur_row_group
                                         + num_block + num_ba)\
                                      * param.get("num_ele_one_dim_data")\
                                      + num_row_group_cur_n\
                                      * param.get("cp_align_len")\
                                      + num_r
                        tail_offset = num_ba*param.get("cp_align_len")
                        tvm_ib.emit(
                            tvm.call_extern(data_tail.dtype,
                                            "copy_gm_to_ubuf",
                                            data_tail.access_ptr(
                                                "w", offset=tail_offset),
                                            data.access_ptr(
                                                'r',
                                                offset=data_offset),
                                            0, 1, 1, 0, 0))
                with tvm_ib.else_scope():
                    data_offset = num_n_before_core * num_ele_one_n \
                                  + (num_block_cur_row_group + num_block)\
                                  * param.get("num_ele_one_dim_data") \
                                  + num_row_group_cur_n\
                                  * param.get("cp_align_len") \
                                  + num_r
                    src_stride = param.get("num_ele_one_dim_data")\
                                 // param.get("cp_align_len") - 1
                    args = tvm_ib, param, data, data_tail, data_offset,\
                           0, num_block_align, 1, src_stride, 0
                    _func_gm_to_ub(args)

                with tvm_ib.for_range(0, num_block_align, name="num_ba")\
                        as num_ba:
                    tvm_ib.emit(tvm.call_extern(
                        data_tail.dtype, "reg_mov",
                        tvm.call_extern(reg.dtype, "reg", reg[0]),
                        data_tail.access_ptr(
                            'r', offset=num_ba*param.get("cp_align_len"))
                    ))
                    tvm_ib.emit(tvm.call_extern(
                        data_res.dtype, "reg_mov",
                        data_res.access_ptr(
                            'w', offset=res_offset + num_block + num_ba),
                        tvm.call_extern(reg.dtype, "reg", reg[0])
                    ))

                dst_offset = num_n_before_core * num_ele_one_n \
                             + (num_row_group_cur_n * param.get("cp_align_len")
                                + num_r) * c_i \
                             + num_block_cur_row_group
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, 1, 1, 0, 0))

        with tvm_ib.else_scope():
            dst_offset = num_n_before_core*num_ele_one_n\
                         + (num_row_group_cur_n*param.get("cp_align_len")
                            + num_r)*c_i\
                         + num_block_cur_row_group
            burst_len_dst = num_block // param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _func_split_row_ir_0231(args):
    """
    function of moving data in split row 0231 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail, reg, reg_addr,\
    num_g, num_block_cur_core = args

    _, c_i, h_i, w_i = data.shape
    num_ele_one_n = c_i * h_i * w_i
    num_block_before_core = num_g*param.get("num_block_one_group")\
                            + param.get("block_index")\
                            * param.get("num_block_one_core")
    num_n_before_core = num_block_before_core // param.get("num_block_one_n")
    num_block_cur_n = num_block_before_core % param.get("num_block_one_n")
    num_row_group_cur_n = num_block_cur_n // c_i
    num_block_cur_row_group = num_block_cur_n % c_i
    num_block_head = c_i - num_block_cur_row_group
    reg_addr[0] = num_block_head

    with tvm_ib.if_scope(num_block_head >= num_block_cur_core):
        # move from data(GM) to data_ub(UB)
        with tvm_ib.if_scope(param.get("num_ele_one_dim_data") % param.get(
            "cp_align_len") > 0):
            with tvm_ib.for_range(0, num_block_cur_core, name="num_b") as num_b:
                data_offset = num_n_before_core * num_ele_one_n\
                              + (num_block_cur_row_group + num_b)\
                              * param.get("num_ele_one_dim_data")\
                              + num_row_group_cur_n * param.get("cp_align_len")
                ub_offset = num_b*param.get("cp_align_len")
                tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset),
                                            data.access_ptr('r',
                                                            offset=data_offset),
                                            0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            data_offset = num_n_before_core * num_ele_one_n\
                          + num_block_cur_row_group * param.get(
                              "num_ele_one_dim_data")\
                          + num_row_group_cur_n * param.get("cp_align_len")
            src_stride = param.get("num_block_one_dim_data") - 1
            args = tvm_ib, param, data, data_ub, data_offset, 0,\
                   num_block_cur_core, 1, src_stride, 0
            _func_gm_to_ub(args)

        # move from data_ub(UB) to data_res(UB)
        with tvm_ib.if_scope(num_row_group_cur_n
                             < param.get("num_block_one_dim_data") - 1):
            num_row = param.get("cp_align_len")
            args = tvm_ib, param, dst, data_ub, data_res, data_tail, reg,\
                   reg_addr, num_n_before_core, num_row_group_cur_n,\
                   num_block_cur_row_group, num_ele_one_n, c_i,\
                   0, 0, 0, num_block_cur_core, num_row, 2
            _ub_to_gm_split_one(args)
        with tvm_ib.else_scope():
            num_row = param.get("num_ele_one_dim_data")\
                      - num_row_group_cur_n*param.get("cp_align_len")
            args = tvm_ib, param, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_n_before_core,\
                   num_row_group_cur_n, num_block_cur_row_group,\
                   num_ele_one_n, c_i, 0, 0, 0, num_block_cur_core, num_row, 3
            _ub_to_gm_split_one(args)

    with tvm_ib.if_scope(num_block_head < num_block_cur_core):
        # move from data to data_ub for head
        with tvm_ib.if_scope(param.get("num_ele_one_dim_data") % param.get(
            "cp_align_len") > 0):
            with tvm_ib.for_range(0, reg_addr[0], name="num_b") as num_b:
                data_offset_head = num_n_before_core * num_ele_one_n\
                              + (num_block_cur_row_group + num_b)\
                                   * param.get("num_ele_one_dim_data")\
                              + num_row_group_cur_n * param.get("cp_align_len")
                ub_offset_head = num_b*param.get("cp_align_len")
                tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset_head),
                                            data.access_ptr(
                                                'r',
                                                offset=data_offset_head),
                                            0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            data_offset_head = num_n_before_core * num_ele_one_n\
                          + num_block_cur_row_group * param.get(
                              "num_ele_one_dim_data")\
                          + num_row_group_cur_n * param.get("cp_align_len")
            src_stride = param.get("num_block_one_dim_data") - 1
            args = tvm_ib, param, data, data_ub, data_offset_head,\
                   0, reg_addr[0], 1, src_stride, 0
            _func_gm_to_ub(args)

        # move from data to data_ub for tail
        num_block_tail = num_block_cur_core - num_block_head
        reg_addr[1] = num_block_tail
        num_block_before_tail = num_block_before_core + reg_addr[0]
        num_n_before_tail = num_block_before_tail\
                            // param.get("num_block_one_n")
        num_block_tail_n = num_block_before_tail % param.get("num_block_one_n")
        num_row_group_tail_n = num_block_tail_n // c_i
        num_block_tail_row_group = 0
        ub_offset_tail_begin = reg_addr[0]*param.get("cp_align_len")

        # move from data to data_ub for tail
        with tvm_ib.if_scope(param.get("num_ele_one_dim_data") % param.get(
            "cp_align_len") > 0):
            with tvm_ib.for_range(0, num_block_tail, name="num_b") as num_b:
                data_offset_tail = num_n_before_tail * num_ele_one_n\
                              + (num_block_tail_row_group + num_b)\
                                   * param.get("num_ele_one_dim_data")\
                              + num_row_group_tail_n\
                                   * param.get("cp_align_len")
                ub_offset_tail = ub_offset_tail_begin\
                                 + num_b*param.get("cp_align_len")
                tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset_tail),
                                            data.access_ptr(
                                                'r',
                                                offset=data_offset_tail),
                                            0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            data_offset_tail = num_n_before_tail*num_ele_one_n\
                          + num_block_tail_row_group\
                               * param.get("num_ele_one_dim_data")\
                          + num_row_group_tail_n*param.get("cp_align_len")
            src_stride = param.get("num_block_one_dim_data") - 1
            args = tvm_ib, param, data, data_ub, data_offset_tail,\
                   ub_offset_tail_begin, reg_addr[1], 1, src_stride, 0
            _func_gm_to_ub(args)

        # move from data_ub to data_res to gm for head
        with tvm_ib.if_scope(num_row_group_cur_n
                             < param.get("num_block_one_dim_data") - 1):
            num_row = param.get("cp_align_len")
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_n_before_core, num_row_group_cur_n,\
                   num_block_cur_row_group, num_ele_one_n, c_i,\
                   0, 0, 0, reg_addr[0], num_row, 4, num_n_before_tail,\
                   num_block_tail_row_group, num_row_group_tail_n
            _ub_to_gm_split_two(args)
        with tvm_ib.else_scope():
            num_row = param.get(
                "num_ele_one_dim_data") - num_row_group_cur_n * param.get(
                    "cp_align_len")
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail, reg,\
                   reg_addr, num_n_before_core, num_row_group_cur_n,\
                   num_block_cur_row_group, num_ele_one_n, c_i,\
                   0, 0, 0, reg_addr[0], num_row, 5, num_n_before_tail,\
                   num_block_tail_row_group, num_row_group_tail_n
            _ub_to_gm_split_two(args)

        # move from data_ub to data_res to gm for tail
        ub_offset_tail = reg_addr[0]*param.get("cp_align_len")
        reg_offset_one = reg_addr[0] + param.get("cp_align_len") - 1
        reg_addr[8] = reg_offset_one
        res_offset_tail = (reg_addr[8] // param.get("cp_align_len"))\
                          * param.get("cp_align_len")
        tail_offset = param.get("cp_align_len")

        with tvm_ib.if_scope(num_row_group_tail_n
                             < param.get("num_block_one_dim_data") - 1):
            num_row = param.get("cp_align_len")
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_n_before_tail, num_row_group_tail_n,\
                   num_block_tail_row_group, num_ele_one_n, c_i,\
                   ub_offset_tail, res_offset_tail, tail_offset,\
                   reg_addr[1], num_row, 6
            _ub_to_gm_split_three(args)
        with tvm_ib.else_scope():
            num_row = param.get(
                "num_ele_one_dim_data") - num_row_group_tail_n * param.get(
                    "cp_align_len")
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_n_before_tail, num_row_group_tail_n,\
                   num_block_tail_row_group, num_ele_one_n, c_i,\
                   ub_offset_tail, res_offset_tail, tail_offset,\
                   reg_addr[1], num_row, 7
            _ub_to_gm_split_three(args)


def _split_row_ir_0231(dst, data, core_divide):
    """
    function of making ir node builder for split row 0231 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_split_row_0231(tvm_ib, data.shape,
                                      dst.dtype, core_divide)
    data_ub = _new_alloc(tvm_ib, dst.dtype, param.get('num_block_one_core')
                         * param.get("cp_align_len"),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, param.get('num_block_one_core')
                          + param.get("cp_align_len"),
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    data_tail = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len')
                           * param.get('cp_align_len'),
                           "data_tail", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (10,), name='reg_addr',
                               scope=cce.scope_reg)

    with tvm_ib.for_range(0, param.get("num_group_index") + 1, name="num_g")\
            as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_g, param.get("num_block_one_core")
            _func_split_row_ir_0231(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod")\
                       // param.get("num_block_one_core")
            num_block_mod = param.get("num_group_mod")\
                            % param.get("num_block_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_tail, reg, reg_addr, num_g, param.get(
                               "num_block_one_core")
                    _func_split_row_ir_0231(args)
            with tvm_ib.if_scope(num_block_mod > 0):
                with tvm_ib.if_scope(tvm.all(param.get("block_index")
                                             < (num_core + 1),
                                             param.get("block_index")
                                             > (num_core - 1))):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_tail, reg, reg_addr, num_g, num_block_mod
                    _func_split_row_ir_0231(args)

    return tvm_ib.get()


def _func_gm_to_ub(args):
    """
    function of moving data from data to data_ub

    """
    tvm_ib, param, data, data_ub, data_offset, ub_offset, ori_nburst,\
    burst_len, src_stride, dst_stride = args

    with tvm_ib.if_scope(ori_nburst > 0):
        with tvm_ib.if_scope(burst_len > 0):
            with tvm_ib.if_scope(burst_len <= 65535):
                with tvm_ib.if_scope(src_stride >= 0):
                    with tvm_ib.if_scope(dst_stride >= 0):
                        with tvm_ib.if_scope(dst_stride <= 65535):
                            with tvm_ib.if_scope(src_stride <= 65535):
                                with tvm_ib.if_scope(ori_nburst <= 4095):
                                    tvm_ib.emit(
                                        tvm.call_extern(
                                            data_ub.dtype,
                                            "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset),
                                            data.access_ptr(
                                                'r', offset=data_offset),
                                            0, ori_nburst,
                                            burst_len,
                                            src_stride, dst_stride))
                                with tvm_ib.else_scope():
                                    n_burst = 4095
                                    c_cycle = ori_nburst // n_burst
                                    c_mod = ori_nburst % n_burst
                                    with tvm_ib.for_range(0, c_cycle,
                                                          name="num_cy")\
                                            as num_cy:
                                        data_cur = data_offset + (
                                            burst_len + src_stride) \
                                                   * param.get("cp_align_len")\
                                                   * n_burst * num_cy
                                        ub_cur = ub_offset + (
                                            burst_len + dst_stride) \
                                                 * param.get("cp_align_len")\
                                                 * n_burst * num_cy
                                        tvm_ib.emit(
                                            tvm.call_extern(
                                                data_ub.dtype,
                                                "copy_gm_to_ubuf",
                                                data_ub.access_ptr(
                                                    "w",
                                                    offset=ub_cur),
                                                data.access_ptr(
                                                    'r',
                                                    offset=data_cur),
                                                0, n_burst,
                                                burst_len,
                                                src_stride,
                                                dst_stride))
                                    with tvm_ib.if_scope(c_mod > 0):
                                        data_cur = data_offset + (
                                            burst_len + src_stride) \
                                                   * param.get("cp_align_len")\
                                                   * n_burst * c_cycle
                                        ub_cur = ub_offset + (
                                            burst_len + dst_stride) \
                                                 * param.get("cp_align_len")\
                                                 * n_burst * c_cycle
                                        tvm_ib.emit(
                                            tvm.call_extern(
                                                data_ub.dtype,
                                                "copy_gm_to_ubuf",
                                                data_ub.access_ptr(
                                                    "w", offset=ub_cur),
                                                data.access_ptr(
                                                    'r', offset=data_cur),
                                                0, c_mod, burst_len,
                                                src_stride,
                                                dst_stride))
                            with tvm_ib.else_scope():
                                with tvm_ib.for_range(0, ori_nburst,
                                                      name="num_nb") as num_nb:
                                    data_cur = data_offset + (
                                        burst_len + src_stride)\
                                               * param.get("cp_align_len")\
                                               * num_nb
                                    ub_cur = ub_offset + (
                                        burst_len + dst_stride)\
                                             * param.get("cp_align_len")\
                                             * num_nb
                                    tvm_ib.emit(
                                        tvm.call_extern(
                                            data_ub.dtype,
                                            "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_cur),
                                            data.access_ptr(
                                                'r', offset=data_cur),
                                            0, 1, burst_len,
                                            0, 0))


def _get_param_more_dim_0312(tvm_ib, src_shape, dtype):
    """
    calculate parameters for more dim 0312 ir builder make function

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 32
    ub_half = ub_bytes // 2
    n_i, h_i, w_i, c_i = src_shape
    num_row_one_dim = h_i*w_i
    dim_space = num_row_one_dim*cp_align_len
    dim_space_bytes = dim_space*float_size
    num_dim_one_core = ub_half // dim_space_bytes
    num_dim_in_data = _ceil_div(c_i, cp_align_len)*n_i
    num_dim_one_group = num_dim_one_core*device_core_num
    num_group_index = num_dim_in_data // num_dim_one_group
    num_group_mod = num_dim_in_data % num_dim_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index, "num_row_one_dim": num_row_one_dim,
                 "num_dim_one_core": num_dim_one_core, "dim_space": dim_space,
                 "num_dim_one_group": num_dim_one_group}

    return param_map


def _reg_mov_batch_row(args):
    """
    reg_mov data for _ub_to_res function

    """
    tvm_ib, data_ub, data_res, reg, ub_offset, res_offset,\
    num_row, num_col_space, num_c = args

    ele_reg = 8
    r_cycle = num_row // ele_reg
    r_mod = num_row - ele_reg * r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_zero)
                               * num_col_space + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_one)
                               * num_col_space + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_two)
                               * num_col_space + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_three)
                               * num_col_space + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_four)
                               * num_col_space + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_five)
                               * num_col_space + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_six)
                               * num_col_space + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_seven)
                               * num_col_space + num_c)
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + num_c * num_row
                                + (num_cr*ele_reg + reg_zero)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + num_c * num_row
                                + (num_cr*ele_reg + reg_one)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + num_c * num_row
                                + (num_cr*ele_reg + reg_two)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + num_c * num_row
                                + (num_cr*ele_reg + reg_three)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + num_c * num_row
                                + (num_cr*ele_reg + reg_four)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + num_c * num_row
                                + (num_cr*ele_reg + reg_five)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + num_c * num_row
                                + (num_cr*ele_reg + reg_six)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + num_c * num_row
                                + (num_cr*ele_reg + reg_seven)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_ub.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_ub.access_ptr('r',
                                   offset=ub_offset + (r_cycle*ele_reg + num_er)
                                   * num_col_space + num_c)
            ))
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                data_res.access_ptr('w', offset=res_offset + num_c * num_row
                                    + (r_cycle*ele_reg + num_er)),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _ub_to_res(args):
    """
    function of moving data from data_ub to data_res

    """
    tvm_ib, data_ub, data_res, reg, ub_offset, res_offset, num_row,\
    num_col, num_col_space = args

    with tvm_ib.for_range(0, num_col, name="num_c") as num_c:
        args = tvm_ib, data_ub, data_res, reg, ub_offset, res_offset, num_row,\
               num_col_space, num_c
        _reg_mov_batch_row(args)


def _res_to_gm(args):
    """
    function of moving data from data_res to dst

    """
    tvm_ib, param, dst, data_res, data_tail, reg, reg_addr, index, total_len,\
    dst_offset, res_offset = args

    with tvm_ib.if_scope(total_len % param.get("cp_align_len") > 0):
        with tvm_ib.if_scope(total_len > param.get("cp_align_len")):
            total_len_align = total_len - param.get("cp_align_len")
            burst_len_one = total_len_align + param.get("cp_align_len") - 1
            reg_addr[index] = burst_len_one
            burst_len_dst = reg_addr[index] // param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r",
                                                            offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))
            args = tvm_ib, data_res, data_tail, reg, res_offset,\
                   0, total_len_align, param.get("cp_align_len")
            _reg_mov_batch_align(args)
            reg_addr[index] = total_len_align
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr(
                                            'w',
                                            offset=dst_offset
                                            + reg_addr[index]),
                                        data_tail.access_ptr("r",
                                                             offset=0),
                                        0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r",
                                                            offset=res_offset),
                                        0, 1, 1, 0, 0))
    with tvm_ib.else_scope():
        burst_len_dst = total_len // param.get("cp_align_len")
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r",
                                                        offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))


def _func_more_dim_ir_0312(args):
    """
    function of moving data in more dim 0312 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail, reg, reg_addr,\
    num_g, num_dim_cur_core = args

    _, h_i, w_i, c_i = data.shape
    num_dim_block_col = _ceil_div(c_i, param.get("cp_align_len"))
    num_ele_block_col = h_i*w_i*c_i
    num_row_one_dim = h_i * w_i
    num_dim_before_core = num_g*param.get("num_dim_one_group")\
                          + param.get("block_index")\
                          * param.get("num_dim_one_core")
    num_block_col_before_core = num_dim_before_core // num_dim_block_col
    num_dim_block_col_before = num_dim_before_core % num_dim_block_col
    num_dim_cur_block_col = num_dim_block_col - num_dim_block_col_before

    with tvm_ib.if_scope(num_dim_cur_core <= num_dim_cur_block_col):
        # move data to data_ub
        with tvm_ib.if_scope(c_i % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, num_row_one_dim, name="num_r") as num_r:
                data_offset = num_block_col_before_core*num_ele_block_col\
                              + num_dim_block_col_before\
                              * param.get("cp_align_len")\
                              + num_r*c_i
                ub_offset = num_r*num_dim_cur_core*param.get("cp_align_len")
                burst_len = num_dim_cur_core
                tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset),
                                            data.access_ptr('r',
                                                            offset=data_offset),
                                            0, 1, burst_len, 0, 0))
        with tvm_ib.else_scope():
            data_offset = num_block_col_before_core * num_ele_block_col \
                          + num_dim_block_col_before * param.get("cp_align_len")
            n_burst = num_row_one_dim
            burst_len = num_dim_cur_core
            src_stride = num_dim_block_col - num_dim_cur_core
            args = tvm_ib, param, data, data_ub, data_offset,\
                   0, n_burst, burst_len, src_stride, 0
            _func_gm_to_ub(args)

        # move data_ub to data_res to dst
        num_col_space = num_dim_cur_core*param.get("cp_align_len")
        with tvm_ib.if_scope(num_dim_cur_core < num_dim_cur_block_col):
            num_col = num_col_space
            args = tvm_ib, data_ub, data_res, reg, 0, 0,\
                   num_row_one_dim, num_col, num_col_space
            _ub_to_res(args)

            total_len = num_col*num_row_one_dim
            dst_offset = num_block_col_before_core*num_ele_block_col \
                         + num_dim_block_col_before\
                         * num_row_one_dim*param.get("cp_align_len")
            args = tvm_ib, param, dst, data_res, data_tail, reg,\
                   reg_addr, 1, total_len, dst_offset, 0
            _res_to_gm(args)
        with tvm_ib.else_scope():
            num_col = c_i - num_dim_block_col_before*param.get("cp_align_len")
            args = tvm_ib, data_ub, data_res, reg, 0, 0,\
                   num_row_one_dim, num_col, num_col_space
            _ub_to_res(args)

            total_len = num_col*num_row_one_dim
            reg_addr[4] = total_len
            dst_offset = num_block_col_before_core*num_ele_block_col \
                         + num_dim_block_col_before\
                         * num_row_one_dim*param.get("cp_align_len")
            args = tvm_ib, param, dst, data_res, data_tail, reg,\
                   reg_addr, 2, reg_addr[4], dst_offset, 0
            _res_to_gm(args)
    with tvm_ib.if_scope(num_dim_cur_core > num_dim_cur_block_col):
        num_dim_head = num_dim_cur_block_col
        num_dim_after = num_dim_cur_core - num_dim_head
        reg_addr[0] = num_dim_after
        num_mid_block_col = reg_addr[0] // num_dim_block_col
        num_dim_tail = reg_addr[0] % num_dim_block_col

        # move data for head
        data_offset = num_block_col_before_core * num_ele_block_col \
                      + num_dim_block_col_before * param.get("cp_align_len")
        with tvm_ib.if_scope(num_dim_head > 0):
            # move data to data_ub
            with tvm_ib.if_scope(c_i % param.get("cp_align_len") > 0):
                with tvm_ib.for_range(0, num_row_one_dim,
                                      name="num_r") as num_r:
                    data_offset_cur = data_offset + num_r * c_i
                    ub_offset = num_r * num_dim_head * param.get(
                        "cp_align_len")
                    burst_len = num_dim_head
                    tvm_ib.emit(
                        tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset_cur),
                                        0, 1, burst_len, 0, 0))
            with tvm_ib.else_scope():
                n_burst = num_row_one_dim
                burst_len = num_dim_head
                src_stride = num_dim_block_col - num_dim_head
                args = tvm_ib, param, data, data_ub, data_offset, 0,\
                       n_burst, burst_len, src_stride, 0
                _func_gm_to_ub(args)

            # move data_ub to data_res
            num_col = c_i - num_dim_block_col_before*param.get("cp_align_len")
            num_col_space = num_dim_head*param.get("cp_align_len")
            args = tvm_ib, data_ub, data_res, reg, 0, 0,\
                   num_row_one_dim, num_col, num_col_space
            _ub_to_res(args)

        # move data for middle
        with tvm_ib.if_scope(num_mid_block_col > 0):
            data_offset_mid = (num_block_col_before_core + 1)*num_ele_block_col
            ub_offset_mid = num_dim_head * param.get(
                "cp_align_len") * num_row_one_dim
            burst_len_mid_one = num_mid_block_col*num_ele_block_col\
                                + param.get("cp_align_len") - 1
            reg_addr[6] = burst_len_mid_one
            burst_len_mid = reg_addr[6] // param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset_mid),
                                        data.access_ptr('r',
                                                        offset=data_offset_mid),
                                        0, 1, burst_len_mid, 0, 0))
            # move data_ub to data_res
            res_offset = (c_i - num_dim_block_col_before
                          * param.get("cp_align_len"))*num_row_one_dim
            with tvm_ib.for_range(0, num_mid_block_col, name="num_m")as num_m:
                ub_offset_cur = ub_offset_mid + num_m*num_ele_block_col
                res_offset_cur = res_offset + num_m*num_ele_block_col
                args = tvm_ib, data_ub, data_res, reg, ub_offset_cur,\
                       res_offset_cur, num_row_one_dim, c_i, c_i
                _ub_to_res(args)

        # move data for tail
        with tvm_ib.if_scope(num_dim_tail > 0):
            data_offset_tail = (num_block_col_before_core
                                + num_mid_block_col + 1) * num_ele_block_col
            burst_len_mid_one = num_mid_block_col*num_ele_block_col\
                                + param.get("cp_align_len") - 1
            reg_addr[6] = burst_len_mid_one
            mid_one = (reg_addr[6] // param.get("cp_align_len"))\
                      * param.get("cp_align_len")
            ub_offset_tail = num_dim_head*param.get("cp_align_len")\
                             * num_row_one_dim\
                             + mid_one
            with tvm_ib.if_scope(c_i % param.get("cp_align_len") > 0):
                with tvm_ib.for_range(0, num_row_one_dim,
                                      name="num_r") as num_r:
                    data_offset_cur = data_offset_tail + num_r * c_i
                    ub_offset = ub_offset_tail + num_r*num_dim_tail\
                                * param.get("cp_align_len")
                    burst_len = num_dim_tail
                    tvm_ib.emit(
                        tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset_cur),
                                        0, 1, burst_len, 0, 0))
            with tvm_ib.else_scope():
                n_burst = num_row_one_dim
                burst_len = num_dim_tail
                src_stride = num_dim_block_col - num_dim_tail
                args = tvm_ib, param, data, data_ub, data_offset_tail,\
                       ub_offset_tail, n_burst, burst_len, src_stride, 0
                _func_gm_to_ub(args)

            # move data_ub to data_res
            res_offset_tail = (c_i - num_dim_block_col_before
                               * param.get("cp_align_len")
                               + num_mid_block_col*c_i)*num_row_one_dim
            num_col = num_dim_tail*param.get("cp_align_len")
            reg_addr[7] = num_col
            args = tvm_ib, data_ub, data_res, reg, ub_offset_tail,\
                   res_offset_tail, num_row_one_dim, reg_addr[7], num_col
            _ub_to_res(args)

        # move data_res to dst
        total_len = (c_i - num_dim_block_col_before*param.get("cp_align_len")
                     + num_mid_block_col*c_i + num_dim_tail
                     * param.get("cp_align_len"))*num_row_one_dim
        reg_addr[5] = total_len
        dst_offset = num_block_col_before_core * num_ele_block_col \
                     + num_dim_block_col_before \
                     * num_row_one_dim * param.get("cp_align_len")
        args = tvm_ib, param, dst, data_res, data_tail, reg,\
               reg_addr, 3, reg_addr[5], dst_offset, 0
        _res_to_gm(args)


def _more_dim_ir_0312(dst, data):
    """
    function of making ir node builder for more dim ir 0312 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_more_dim_0312(tvm_ib, data.shape, dst.dtype)
    data_ub = _new_alloc(tvm_ib, dst.dtype, param.get('num_dim_one_core')
                         * param.get("dim_space"),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, param.get('num_dim_one_core')
                          * param.get("dim_space"),
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    data_tail = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                           "data_tail", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (8,), name='reg_addr',
                               scope=cce.scope_reg)

    with tvm_ib.for_range(0, param.get("num_group_index") + 1, name="num_g")\
            as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_g, param.get("num_dim_one_core")
            _func_more_dim_ir_0312(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod")\
                       // param.get("num_dim_one_core")
            num_dim_mod = param.get("num_group_mod")\
                          % param.get("num_dim_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_tail, reg, reg_addr, num_g, param.get(
                               "num_dim_one_core")
                    _func_more_dim_ir_0312(args)
            with tvm_ib.if_scope(num_dim_mod > 0):
                with tvm_ib.if_scope(tvm.all(param.get("block_index")
                                             < (num_core + 1),
                                             param.get("block_index")
                                             > (num_core - 1))):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_tail, reg, reg_addr, num_g, num_dim_mod
                    _func_more_dim_ir_0312(args)

    return tvm_ib.get()


def _get_param_one_dim_0312(tvm_ib, src_shape, dtype):
    """
    calculate parameters for one dim 0312 ir builder make function

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    n_i, _, _, c_i = src_shape
    num_dim_in_data = _ceil_div(c_i, cp_align_len)*n_i
    num_dim_one_core = 1
    num_dim_one_group = num_dim_one_core*device_core_num
    num_group_index = num_dim_in_data // num_dim_one_group
    num_group_mod = num_dim_in_data % num_dim_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "num_dim_one_core": num_dim_one_core,
                 "num_dim_one_group": num_dim_one_group,
                 "num_dim_in_data": num_dim_in_data}

    return param_map


def _reg_mov_batch_one(args):
    """
    reg_mov data in ub for one dim and split dim scene

    """
    tvm_ib, data_ub, data_res, reg, reg_addr, index, ub_offset,\
    res_offset, num_row, num_c, cp_len = args

    ele_reg = 8
    r_cycle = num_row // ele_reg
    r_mod = num_row % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_zero)
                               * cp_len + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_one)
                               * cp_len + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_two)
                               * cp_len + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_three)
                               * cp_len + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_four)
                               * cp_len + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_five)
                               * cp_len + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_six)
                               * cp_len + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_seven)
                               * cp_len + num_c)
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_zero)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_one)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_two)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_three)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_four)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_five)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_six)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_seven)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    reg_addr[index] = r_mod
    with tvm_ib.for_range(0, reg_addr[index], name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (r_cycle*ele_reg + num_er)
                               * cp_len + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=res_offset + (r_cycle*ele_reg
                                                          + num_er)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _func_one_dim_ir_0312(args):
    """
    function of moving data in one dim 0312 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail, reg,\
    reg_addr, num_g = args

    _, h_i, w_i, c_i = data.shape
    num_dim_block_col = _ceil_div(c_i, param.get("cp_align_len"))
    num_ele_block_col = h_i*w_i*c_i
    num_row_one_dim = h_i * w_i
    num_dim_before_core = num_g*param.get("num_dim_one_group")\
                          + param.get("block_index")\
                          * param.get("num_dim_one_core")
    num_block_col_before = num_dim_before_core // num_dim_block_col
    num_dim_col_before = num_dim_before_core % num_dim_block_col
    num_col = tvm.min((num_dim_col_before + 1)*param.get("cp_align_len"), c_i)\
              - num_dim_col_before*param.get("cp_align_len")

    data_offset = num_block_col_before*num_ele_block_col\
                  + num_dim_col_before*param.get("cp_align_len")
    with tvm_ib.if_scope(c_i % param.get("cp_align_len") > 0):
        with tvm_ib.for_range(0, num_row_one_dim, name="num_r") as num_r:
            data_offset_cur = data_offset + num_r*c_i
            ub_offset_cur = num_r*param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset_cur),
                                        data.access_ptr('r',
                                                        offset=data_offset_cur),
                                        0, 1, 1, 0, 0))
    with tvm_ib.else_scope():
        n_burst = num_row_one_dim
        src_stride = num_dim_block_col - 1
        args = tvm_ib, param, data, data_ub, data_offset, 0, n_burst,\
               1, src_stride, 0
        _func_gm_to_ub(args)

    with tvm_ib.for_range(0, num_col, name="num_c") as num_c:
        args = tvm_ib, data_ub, data_res, reg, reg_addr,\
               1, 0, 0, num_row_one_dim, num_c, param.get("cp_align_len")
        _reg_mov_batch_one(args)
        dst_offset = num_block_col_before * num_ele_block_col\
                     + num_dim_col_before*num_row_one_dim\
                     * param.get("cp_align_len")
        dst_offset_cur = dst_offset + num_row_one_dim * num_c
        args = tvm_ib, param, dst, data_res, data_tail, reg,\
               reg_addr, 0, num_row_one_dim, dst_offset_cur, 0
        _res_to_gm(args)


def _one_dim_ir_0312(dst, data):
    """
    function of making ir node builder for one dim 0312 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_one_dim_0312(tvm_ib, data.shape, dst.dtype)
    _, h_i, w_i, _ = data.shape
    num_row_one_dim = h_i * w_i
    data_ub = _new_alloc(tvm_ib, dst.dtype, num_row_one_dim
                         * param.get("cp_align_len"),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, num_row_one_dim,
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    data_tail = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                           "data_tail", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (8,), name='reg_addr',
                               scope=cce.scope_reg)

    with tvm_ib.for_range(0, param.get("num_group_index") + 1, name="num_g")\
            as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_g
            _func_one_dim_ir_0312(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod")\
                       // param.get("num_dim_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_tail, reg, reg_addr, num_g
                    _func_one_dim_ir_0312(args)

    return tvm_ib.get()


def _get_param_one_dim_0312_small(tvm_ib, src_shape, dtype):
    """
    calculate parameters for one dim 0312 small ir builder make function

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    n_i, _, _, c_i = src_shape
    num_dim_in_data = _ceil_div(c_i, cp_align_len)*n_i
    num_dim_one_core = 1
    num_dim_one_group = num_dim_one_core*device_core_num
    num_group_index = num_dim_in_data // num_dim_one_group
    num_group_mod = num_dim_in_data % num_dim_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "num_dim_one_core": num_dim_one_core,
                 "num_dim_one_group": num_dim_one_group,
                 "num_dim_in_data": num_dim_in_data}

    return param_map


def _func_one_dim_ir_0312_small(args):
    """
    function of movint data in one dim 0312 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail, reg,\
    reg_addr, num_g = args

    _, h_i, w_i, c_i = data.shape
    num_dim_block_col = _ceil_div(c_i, param.get("cp_align_len"))
    num_ele_block_col = h_i*w_i*c_i
    num_row_one_dim = h_i * w_i
    num_dim_before_core = num_g*param.get("num_dim_one_group")\
                          + param.get("block_index")\
                          * param.get("num_dim_one_core")
    num_block_col_before = num_dim_before_core // num_dim_block_col
    num_dim_col_before = num_dim_before_core % num_dim_block_col
    num_col = c_i

    data_offset = num_block_col_before*num_ele_block_col

    burst_len_data = num_row_one_dim*c_i
    total_len_data = _ceil_div(burst_len_data, param.get("cp_align_len"))
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, total_len_data, 0, 0))

    with tvm_ib.for_range(0, num_col, name="num_c") as num_c:
        args = tvm_ib, data_ub, data_res, reg, reg_addr,\
               1, 0, 0, num_row_one_dim, num_c, c_i
        _reg_mov_batch_one(args)
        dst_offset = num_block_col_before * num_ele_block_col\
                     + num_dim_col_before*num_row_one_dim\
                     * param.get("cp_align_len")
        dst_offset_cur = dst_offset + num_row_one_dim * num_c
        args = tvm_ib, param, dst, data_res, data_tail, reg,\
               reg_addr, 0, num_row_one_dim, dst_offset_cur, 0
        _res_to_gm(args)


def _one_dim_ir_0312_small(dst, data):
    """
    function of making ir node builder for one dim 0312 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_one_dim_0312_small(tvm_ib, data.shape, dst.dtype)
    _, h_i, w_i, c_i = data.shape
    num_row_one_dim = h_i * w_i
    data_ub = _new_alloc(tvm_ib, dst.dtype, num_row_one_dim*c_i,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, num_row_one_dim,
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    data_tail = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                           "data_tail", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (8,), name='reg_addr',
                               scope=cce.scope_reg)

    with tvm_ib.for_range(0, param.get("num_group_index") + 1, name="num_g")\
            as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_g
            _func_one_dim_ir_0312_small(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod")\
                       // param.get("num_dim_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_tail, reg, reg_addr, num_g
                    _func_one_dim_ir_0312_small(args)

    return tvm_ib.get()


def _get_param_split_dim_0312(tvm_ib, src_shape, dtype):
    """
    calculate parameters for split dim 0312 ir builder make function

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 96
    n_i, h_i, w_i, c_i = src_shape
    num_row_one_dim = h_i*w_i
    num_row_dim_space = _ceil_fill(num_row_one_dim, cp_align_len)
    num_dim_block_col = _ceil_div(c_i, cp_align_len)
    num_row_in_data = num_row_dim_space*num_dim_block_col*n_i\
                      - (num_row_dim_space - num_row_one_dim)
    ub_ele = ub_bytes // float_size
    num_row_one_core_one = ub_ele // (cp_align_len + 1)
    num_row_one_core = (num_row_one_core_one // cp_align_len) * cp_align_len
    num_row_one_group = num_row_one_core * device_core_num
    num_group_index = num_row_in_data // num_row_one_group
    num_group_mod = num_row_in_data % num_row_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "num_row_one_dim": num_row_one_dim,
                 "num_row_one_core": num_row_one_core,
                 "num_row_one_group": num_row_one_group,
                 "num_row_in_data_space": num_row_in_data}

    return param_map


def _reg_mov_batch_one_cp_align(args):
    """
    reg_mov cp_align_len data for batch scene in split dim 0312 function

    """
    tvm_ib, param, data_ub, data_res, reg, ub_offset, res_offset,\
    num_row, num_c = args

    ele_reg = 8
    r_cycle = num_row // ele_reg
    r_mod = num_row % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_zero)
                               * param.get("cp_align_len") + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_one)
                               * param.get("cp_align_len") + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_two)
                               * param.get("cp_align_len") + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_three)
                               * param.get("cp_align_len") + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_four)
                               * param.get("cp_align_len") + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_five)
                               * param.get("cp_align_len") + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_six)
                               * param.get("cp_align_len") + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_seven)
                               * param.get("cp_align_len") + num_c)
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_zero)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg + reg_one)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg + reg_two)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_three)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_four)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_five)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg + reg_six)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_seven)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr(
                'r',
                offset=ub_offset + (r_cycle*ele_reg + num_er)
                * param.get("cp_align_len") + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=res_offset + (
                r_cycle * ele_reg + num_er)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _dst_to_data(args):
    """
    calculate data position according to destination position

    """
    dst_pos, num_ele_block_col, num_ele_dim, num_row_one_dim,\
    cp_align_len = args

    num_block_col_index = dst_pos // num_ele_block_col
    num_ele_cur_block_col = dst_pos % num_ele_block_col
    num_dim_index = num_ele_cur_block_col // num_ele_dim
    num_ele_cur_dim = num_ele_cur_block_col % num_ele_dim
    num_col = num_ele_cur_dim // num_row_one_dim
    num_row = num_ele_cur_dim % num_row_one_dim
    data_pos = num_block_col_index*num_ele_block_col\
               + (num_dim_index*cp_align_len + num_col)\
               * num_row_one_dim + num_row

    return data_pos


def _func_split_dim_ir_0312(args):
    """
    function of moving data in split dim 0312 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail, data_align,\
    reg, reg_two, reg_addr, num_g, num_row_cur_core = args

    _, h_i, w_i, c_i = data.shape
    num_dim_block_col = _ceil_div(c_i, param.get("cp_align_len"))
    num_row_one_dim = h_i * w_i
    num_ele_block_col = h_i*w_i*c_i
    num_row_dim_space = _ceil_fill(num_row_one_dim, param.get("cp_align_len"))
    num_row_before_core = num_g*param.get("num_row_one_group")\
                          + param.get("block_index")\
                          * param.get("num_row_one_core")
    num_dim_before_core = num_row_before_core // num_row_dim_space
    num_block_col_before_core = num_dim_before_core // num_dim_block_col
    num_dim_cur_block_col = num_dim_before_core % num_dim_block_col
    num_row_cur_dim_before = num_row_before_core % num_row_dim_space
    num_row_cur_dim_after = num_row_dim_space - num_row_cur_dim_before

    data_offset = num_block_col_before_core * num_ele_block_col \
                  + num_dim_cur_block_col * param.get("cp_align_len") \
                  + num_row_cur_dim_before * c_i

    with tvm_ib.if_scope(num_row_cur_dim_after >= num_row_cur_core):
        # move data to data_ub
        with tvm_ib.if_scope(c_i % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, num_row_cur_core, name="num_r") as num_r:
                data_offset_cur = data_offset + num_r*c_i
                ub_offset = num_r*param.get("cp_align_len")
                tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset),
                                            data.access_ptr(
                                                'r', offset=data_offset_cur),
                                            0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            n_burst = num_row_cur_core
            src_stride = num_dim_block_col - 1
            args = tvm_ib, param, data, data_ub, data_offset,\
                   0, n_burst, 1, src_stride, 0
            _func_gm_to_ub(args)

        # move data_ub to data_res
        num_col = tvm.min((num_dim_cur_block_col + 1)
                          * param.get("cp_align_len"), c_i)\
                  - num_dim_cur_block_col*param.get("cp_align_len")
        with tvm_ib.for_range(0, num_col, name="num_c") as num_c:
            args = tvm_ib, param, data_ub, data_res, reg, 0, 0,\
                   num_row_cur_core, num_c
            _reg_mov_batch_one_cp_align(args)
            dst_offset = num_block_col_before_core*num_ele_block_col\
                             + (num_dim_cur_block_col*param.get("cp_align_len")
                                + num_c)*num_row_one_dim\
                         + num_row_cur_dim_before
            args = tvm_ib, param, dst, data_res, data_tail, reg,\
                   reg_addr, 1, num_row_cur_core, dst_offset, 0
            _res_to_gm(args)
    with tvm_ib.if_scope(num_row_cur_dim_after < num_row_cur_core):
        num_row_head = num_row_one_dim - num_row_cur_dim_before
        reg_addr[0] = num_row_head
        num_row_head_one = num_row_head + param.get("cp_align_len") - 1
        reg_addr[3] = num_row_head_one
        num_row_head_space = (reg_addr[3] // param.get("cp_align_len"))\
                             * param.get("cp_align_len")
        num_row_tail = num_row_cur_core - num_row_head_space
        reg_addr[7] = num_row_tail

        num_dim_before_tail = num_dim_before_core + 1
        num_block_col_before_tail = num_dim_before_tail // num_dim_block_col
        num_dim_cur_block_tail = num_dim_before_tail % num_dim_block_col

        data_offset_head = num_block_col_before_core * num_ele_block_col\
                           + num_dim_cur_block_col * param.get("cp_align_len")\
                           + num_row_cur_dim_before * c_i
        data_offset_tail = num_block_col_before_tail*num_ele_block_col\
                           + num_dim_cur_block_tail*param.get("cp_align_len")
        ub_offset_tail = num_row_head*param.get("cp_align_len")
        res_offset_tail = num_row_head_space
        # move data to data_ub
        with tvm_ib.if_scope(c_i % param.get("cp_align_len") > 0):
            # move data to data_ub for head
            with tvm_ib.for_range(0, num_row_head, name="num_r") as num_r:
                data_offset_cur = data_offset_head + num_r*c_i
                ub_offset = num_r*param.get("cp_align_len")
                tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset),
                                            data.access_ptr(
                                                'r', offset=data_offset_cur),
                                            0, 1, 1, 0, 0))
            # move data to data_ub for tail
            with tvm_ib.for_range(0, num_row_tail, name="num_rt") as num_rt:
                data_offset_tail_cur = data_offset_tail + num_rt*c_i
                ub_offset_tail_cur = ub_offset_tail + num_rt\
                                     * param.get("cp_align_len")
                tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset_tail_cur),
                                            data.access_ptr(
                                                'r',
                                                offset=data_offset_tail_cur),
                                            0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            # move data to data_ub for head
            src_stride = num_dim_block_col - 1
            args = tvm_ib, param, data, data_ub, data_offset_head,\
                   0, reg_addr[0], 1, src_stride, 0
            _func_gm_to_ub(args)
            # move data to data_ub for tail
            args = tvm_ib, param, data, data_ub, data_offset_tail,\
                   ub_offset_tail, reg_addr[7], 1, src_stride, 0
            _func_gm_to_ub(args)

        # move data_ub to dst for head
        num_col_head = tvm.min((num_dim_cur_block_col + 1)
                               * param.get("cp_align_len"), c_i)\
                       - num_dim_cur_block_col*param.get("cp_align_len")
        reg_addr[5] = num_col_head
        with tvm_ib.for_range(0, reg_addr[5], name="num_ch") as num_ch:
            args = tvm_ib, data_ub, data_res, reg, reg_addr, 9,\
                   0, 0, reg_addr[0], num_ch, param.get("cp_align_len")
            _reg_mov_batch_one(args)
            dst_offset_head = num_block_col_before_core*num_ele_block_col \
                              + (num_dim_cur_block_col*param.get("cp_align_len")
                                 + num_ch) * num_row_one_dim\
                              + num_row_cur_dim_before
            with tvm_ib.if_scope(reg_addr[0] % param.get("cp_align_len") > 0):
                with tvm_ib.if_scope(num_row_head >= param.get("cp_align_len")):
                    row_len_align = num_row_head - param.get("cp_align_len")
                    burst_len_one = row_len_align\
                                    + param.get("cp_align_len") - 1
                    reg_addr[4] = burst_len_one
                    burst_len_head = reg_addr[4] // param.get("cp_align_len")
                    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w',
                                                    offset=dst_offset_head),
                                                data_res.access_ptr("r",
                                                                    offset=0),
                                                0, 1, burst_len_head, 0, 0))
                    args = tvm_ib, data_res, data_tail, reg, 0, 0,\
                           row_len_align, param.get("cp_align_len")
                    _reg_mov_batch_align(args)
                    tvm_ib.emit(
                        tvm.call_extern(
                            dst.dtype, "copy_ubuf_to_gm",
                            dst.access_ptr(
                                'w',
                                offset=dst_offset_head + reg_addr[0]
                                - param.get("cp_align_len")),
                            data_tail.access_ptr("r", offset=0),
                            0, 1, 1, 0, 0))
                with tvm_ib.else_scope():
                    num_ele = param.get("cp_align_len") - num_row_head
                    reg_addr[6] = num_ele
                    with tvm_ib.for_range(0, reg_addr[6], name="num_e")\
                            as num_e:
                        dst_pos = dst_offset_head + num_e
                        num_ele_dim = num_row_one_dim*param.get("cp_align_len")
                        args = dst_pos, num_ele_block_col, num_ele_dim,\
                               num_row_one_dim, param.get("cp_align_len")
                        data_pos = _dst_to_data(args)
                        tvm_ib.emit(
                            tvm.call_extern(data_align.dtype, "copy_gm_to_ubuf",
                                            data_align.access_ptr("w",
                                                                  offset=0),
                                            data.access_ptr('r',
                                                            offset=data_pos),
                                            0, 1, 1, 0, 0))
                        tvm_ib.emit(tvm.call_extern(
                            data_align.dtype, "reg_mov",
                            tvm.call_extern(reg.dtype, "reg", reg[0]),
                            data_align.access_ptr('r',
                                                  offset=0)
                        ))
                        tvm_ib.emit(tvm.call_extern(
                            data_res.dtype, "reg_mov",
                            data_res.access_ptr('w',
                                                offset=num_row_head + num_e),
                            tvm.call_extern(reg.dtype, "reg", reg[0])
                        ))
                    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w',
                                                    offset=dst_offset_head),
                                                data_res.access_ptr("r",
                                                                    offset=0),
                                                0, 1, 1, 0, 0))
            with tvm_ib.else_scope():
                burst_len_head = reg_addr[0] // param.get("cp_align_len")
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w',
                                                offset=dst_offset_head),
                                            data_res.access_ptr("r",
                                                                offset=0),
                                            0, 1, burst_len_head, 0, 0))
        # move data from data_ub to dst for tail
        num_col_tail = tvm.min((num_dim_cur_block_tail + 1)
                               * param.get("cp_align_len"), c_i)\
                       - num_dim_cur_block_tail*param.get("cp_align_len")
        with tvm_ib.for_range(0, num_col_tail, name="num_ct") as num_ct:
            args = tvm_ib, data_ub, data_res, reg, reg_addr, 10,\
                   ub_offset_tail, res_offset_tail, reg_addr[7],\
                   num_ct, param.get("cp_align_len")
            _reg_mov_batch_one(args)
            dst_offset_tail = num_block_col_before_tail * num_ele_block_col \
                              + (num_dim_cur_block_tail * param.get(
                                  "cp_align_len") + num_ct) * num_row_one_dim
            args = tvm_ib, param, dst, data_res, data_tail, reg_two, reg_addr,\
                   2, reg_addr[7], dst_offset_tail, num_row_head_space
            _res_to_gm(args)


def _split_dim_ir_0312(dst, data):
    """
    function of making ir node builder for split dim 0312 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_split_dim_0312(tvm_ib, data.shape, dst.dtype)
    data_ub = _new_alloc(tvm_ib, dst.dtype, param.get("num_row_one_core")
                         * param.get("cp_align_len"),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, param.get("num_row_one_core"),
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    reg_two = tvm_ib.allocate(dst.dtype, (8,), name='reg_two',
                              scope=cce.scope_reg)
    data_tail = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                           "data_tail", scope=cce.scope_ubuf)
    data_align = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                            "data_align", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (12,), name='reg_addr',
                               scope=cce.scope_reg)

    with tvm_ib.for_range(0, param.get("num_group_index") + 1,
                          name="num_g") as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail, \
                   data_align, reg, reg_two, reg_addr, num_g, param.get(
                       "num_row_one_core")
            _func_split_dim_ir_0312(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod") // param.get(
                "num_row_one_core")
            num_row_mod = param.get("num_group_mod") % param.get(
                "num_row_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res, \
                           data_tail, data_align, reg, reg_two, reg_addr,\
                           num_g, param.get("num_row_one_core")
                    _func_split_dim_ir_0312(args)
            with tvm_ib.if_scope(num_row_mod > 0):
                with tvm_ib.if_scope(
                    tvm.all(param.get("block_index") < (num_core + 1),
                            param.get("block_index") > (num_core - 1))):
                    args = tvm_ib, param, data, dst, data_ub, data_res, \
                           data_tail, data_align, reg, reg_two, reg_addr,\
                           num_g, num_row_mod
                    _func_split_dim_ir_0312(args)

    return tvm_ib.get()


def _get_param_split_dim_0312_small(tvm_ib, src_shape, dtype):
    """
    calculate parameters for split dim 0312 small ir builder make function

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 96
    n_i, h_i, w_i, c_i = src_shape
    num_row_one_dim = h_i * w_i
    num_row_dim_space = _ceil_fill(num_row_one_dim, cp_align_len)
    num_dim_block_col = _ceil_div(c_i, cp_align_len)
    num_row_in_data = num_row_dim_space * num_dim_block_col * n_i - (
        num_row_dim_space - num_row_one_dim)
    ub_ele = ub_bytes // float_size
    actual_row_len = c_i
    num_row_one_core_one = ub_ele // (actual_row_len + 1)
    num_row_one_core = (num_row_one_core_one // cp_align_len) * cp_align_len
    num_row_one_group = num_row_one_core * device_core_num
    num_group_index = num_row_in_data // num_row_one_group
    num_group_mod = num_row_in_data % num_row_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "num_row_one_dim": num_row_one_dim,
                 "num_row_one_core": num_row_one_core,
                 "num_row_one_group": num_row_one_group,
                 "num_row_in_data_space": num_row_in_data,
                 "actual_row_len": actual_row_len}

    return param_map


def _func_split_dim_ir_0312_small(args):
    """
    function of moving data for split dim 0312 small scene

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail, data_align, reg,\
    reg_two, reg_addr, num_g, num_row_cur_core = args

    _, h_i, w_i, c_i = data.shape
    num_dim_block_col = _ceil_div(c_i, param.get("cp_align_len"))
    num_row_one_dim = h_i * w_i
    num_ele_block_col = h_i*w_i*c_i
    num_row_dim_space = _ceil_fill(num_row_one_dim, param.get("cp_align_len"))
    num_row_before_core = num_g*param.get("num_row_one_group")\
                          + param.get("block_index")\
                          * param.get("num_row_one_core")
    num_dim_before_core = num_row_before_core // num_row_dim_space
    num_block_col_before_core = num_dim_before_core // num_dim_block_col
    num_row_cur_dim_before = num_row_before_core % num_row_dim_space
    num_row_cur_dim_after = num_row_dim_space - num_row_cur_dim_before

    data_offset = num_block_col_before_core * num_ele_block_col \
                  + num_row_cur_dim_before * c_i

    with tvm_ib.if_scope(num_row_cur_dim_after >= num_row_cur_core):
        # move data to data_ub
        total_len_data = c_i*num_row_cur_core
        burst_len_data = _ceil_div(total_len_data, param.get("cp_align_len"))
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        # move data_ub to data_res
        num_col = c_i
        with tvm_ib.for_range(0, num_col, name="num_c") as num_c:
            args = tvm_ib, data_ub, data_res, reg, reg_addr, 8, 0, 0,\
                   num_row_cur_core, num_c, c_i
            _reg_mov_batch_one(args)

            dst_offset = num_block_col_before_core*num_ele_block_col\
                     + num_c*num_row_one_dim + num_row_cur_dim_before
            args = tvm_ib, param, dst, data_res, data_tail, reg,\
                   reg_addr, 1, num_row_cur_core, dst_offset, 0
            _res_to_gm(args)
    with tvm_ib.if_scope(num_row_cur_dim_after < num_row_cur_core):
        num_row_head = num_row_one_dim - num_row_cur_dim_before
        reg_addr[0] = num_row_head
        num_row_head_one = num_row_head + param.get("cp_align_len") - 1
        reg_addr[3] = num_row_head_one
        num_row_head_space = (reg_addr[3] // param.get("cp_align_len"))\
                             * param.get("cp_align_len")
        num_row_tail = num_row_cur_core - num_row_head_space
        reg_addr[7] = num_row_tail

        num_dim_before_tail = num_dim_before_core + 1
        num_block_col_before_tail = num_dim_before_tail // num_dim_block_col
        num_dim_cur_block_tail = num_dim_before_tail % num_dim_block_col

        data_offset_head = num_block_col_before_core * num_ele_block_col \
                           + num_row_cur_dim_before * c_i
        data_offset_tail = num_block_col_before_tail*num_ele_block_col
        ub_offset_tail_before_len = num_row_head*param.get("actual_row_len")
        ub_offset_tail_one = ub_offset_tail_before_len\
                             + param.get("cp_align_len") - 1
        reg_addr[11] = ub_offset_tail_one
        ub_offset_tail = (reg_addr[11] // param.get("cp_align_len"))\
                         * param.get("cp_align_len")
        res_offset_tail = num_row_head_space
        # move data to data_ub
        total_len_head = c_i*num_row_head
        burst_len_head_one = total_len_head + param.get("cp_align_len") - 1
        reg_addr[13] = burst_len_head_one
        burst_len_head = reg_addr[13] // param.get("cp_align_len")
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset_head),
                                    0, 1, burst_len_head, 0, 0))

        total_len_tail = c_i*num_row_tail
        burst_len_tail_one = total_len_tail + param.get("cp_align_len") - 1
        reg_addr[14] = burst_len_tail_one
        burst_len_tail = reg_addr[14] // param.get("cp_align_len")
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset_tail),
                                    data.access_ptr('r',
                                                    offset=data_offset_tail),
                                    0, 1, burst_len_tail, 0, 0))

        # move data_ub to dst for head
        with tvm_ib.for_range(0, c_i, name="num_ch") as num_ch:
            args = tvm_ib, data_ub, data_res, reg,\
                   reg_addr, 9, 0, 0, reg_addr[0], num_ch, c_i
            _reg_mov_batch_one(args)
            dst_offset_head = num_block_col_before_core*num_ele_block_col \
                              + num_ch*num_row_one_dim + num_row_cur_dim_before
            with tvm_ib.if_scope(reg_addr[0] % param.get("cp_align_len") > 0):
                with tvm_ib.if_scope(num_row_head >= param.get("cp_align_len")):
                    row_len_align = num_row_head - param.get("cp_align_len")
                    burst_len_one = row_len_align\
                                    + param.get("cp_align_len") - 1
                    reg_addr[4] = burst_len_one
                    burst_len_head = reg_addr[4] // param.get("cp_align_len")
                    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w',
                                                    offset=dst_offset_head),
                                                data_res.access_ptr(
                                                    "r", offset=0),
                                                0, 1, burst_len_head, 0, 0))
                    args = tvm_ib, data_res, data_tail,\
                           reg, 0, 0, row_len_align, param.get("cp_align_len")
                    _reg_mov_batch_align(args)

                    tvm_ib.emit(
                        tvm.call_extern(
                            dst.dtype, "copy_ubuf_to_gm",
                            dst.access_ptr(
                                'w',
                                offset=dst_offset_head + reg_addr[0]
                                - param.get("cp_align_len")),
                            data_tail.access_ptr("r", offset=0),
                            0, 1, 1, 0, 0))
                with tvm_ib.else_scope():
                    num_ele = param.get("cp_align_len") - num_row_head
                    reg_addr[6] = num_ele
                    with tvm_ib.for_range(0, reg_addr[6], name="num_e")\
                            as num_e:
                        dst_pos = dst_offset_head + num_e
                        num_ele_dim = num_row_one_dim * param.get(
                            "cp_align_len")
                        args = dst_pos, num_ele_block_col, num_ele_dim,\
                               num_row_one_dim, param.get("cp_align_len")
                        data_pos = _dst_to_data(args)
                        tvm_ib.emit(
                            tvm.call_extern(data_align.dtype, "copy_gm_to_ubuf",
                                            data_align.access_ptr("w",
                                                                  offset=0),
                                            data.access_ptr('r',
                                                            offset=data_pos),
                                            0, 1, 1, 0, 0))
                        tvm_ib.emit(tvm.call_extern(
                            data_align.dtype, "reg_mov",
                            tvm.call_extern(reg.dtype, "reg", reg[0]),
                            data_align.access_ptr('r',
                                                  offset=0)
                        ))
                        tvm_ib.emit(tvm.call_extern(
                            data_res.dtype, "reg_mov",
                            data_res.access_ptr('w',
                                                offset=num_row_head + num_e),
                            tvm.call_extern(reg.dtype, "reg", reg[0])
                        ))
                    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w',
                                                    offset=dst_offset_head),
                                                data_res.access_ptr("r",
                                                                    offset=0),
                                                0, 1, 1, 0, 0))
            with tvm_ib.else_scope():
                burst_len_head = reg_addr[0] // param.get("cp_align_len")
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w',
                                                offset=dst_offset_head),
                                            data_res.access_ptr("r",
                                                                offset=0),
                                            0, 1, burst_len_head, 0, 0))
        # move data_ub to dst for tail
        num_col_tail = c_i
        with tvm_ib.for_range(0, num_col_tail, name="num_ct") as num_ct:
            args = tvm_ib, data_ub, data_res, reg,\
                   reg_addr, 10, ub_offset_tail, res_offset_tail,\
                   reg_addr[7], num_ct, c_i
            _reg_mov_batch_one(args)
            dst_offset_tail = num_block_col_before_tail * num_ele_block_col \
                              + (num_dim_cur_block_tail * param.get(
                                  "cp_align_len") + num_ct) * num_row_one_dim
            args = tvm_ib, param, dst, data_res, data_tail, reg_two,\
                   reg_addr, 2, reg_addr[7], dst_offset_tail, num_row_head_space
            _res_to_gm(args)


def _split_dim_ir_0312_small(dst, data):
    """
    function of making ir node builder for split dim 0312 small scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_split_dim_0312_small(tvm_ib, data.shape, dst.dtype)
    c_i = data.shape[3]
    data_ub = _new_alloc(tvm_ib, dst.dtype,
                         _ceil_fill(param.get("num_row_one_core")*c_i,
                                    param.get("cp_align_len")),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, param.get("num_row_one_core"),
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    reg_two = tvm_ib.allocate(dst.dtype, (8,), name='reg_two',
                              scope=cce.scope_reg)
    data_tail = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                           "data_tail", scope=cce.scope_ubuf)
    data_align = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                            "data_align", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (16,), name='reg_addr',
                               scope=cce.scope_reg)
    with tvm_ib.for_range(0, param.get("num_group_index") + 1,
                          name="num_g") as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail, \
                   data_align, reg, reg_two, reg_addr, num_g, param.get(
                       "num_row_one_core")
            _func_split_dim_ir_0312_small(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod") // param.get(
                "num_row_one_core")
            num_row_mod = param.get("num_group_mod") % param.get(
                "num_row_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res, \
                           data_tail, data_align, reg, reg_two, reg_addr,\
                           num_g, param.get("num_row_one_core")
                    _func_split_dim_ir_0312_small(args)
            with tvm_ib.if_scope(num_row_mod > 0):
                with tvm_ib.if_scope(
                    tvm.all(param.get("block_index") < (num_core + 1),
                            param.get("block_index") > (num_core - 1))):
                    args = tvm_ib, param, data, dst, data_ub, data_res, \
                           data_tail, data_align, reg, reg_two, reg_addr,\
                           num_g, num_row_mod
                    _func_split_dim_ir_0312_small(args)

    return tvm_ib.get()


def _get_param_more_two_dim_10(tvm_ib, src_shape, dtype, core_divide):
    """
    calculate parameters for more two dim 10 ir builder make function

    """
    num, col_len, row_len = src_shape
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 32
    ub_half = ub_bytes // 2
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = ub_half // float_size // core_divide
    two_dim_ele = col_len*row_len
    two_dim_ele_align = _ceil_fill(two_dim_ele, cp_align_len)

    num_two_dim_ub = ub_ele // two_dim_ele_align
    num_two_dim_group = num_two_dim_ub*device_core_num
    num_group_index = num // num_two_dim_group
    num_group_mod = num % num_two_dim_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index, "two_dim_ele": two_dim_ele,
                 "num_two_dim_ub": num_two_dim_ub,
                 "num_two_dim_group": num_two_dim_group}

    return param_map


# pylint: disable=locally-disabled,unused-variable,invalid-name
def _reg_mov_batch_two_10_col(args):
    """
    reg_mov data in ub for two dim 10 col scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, row_len,\
    num_d, num_r, col_len = args

    ele_reg = 8
    r_cycle = col_len // ele_reg
    r_mod = col_len % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + (num_cr*ele_reg + reg_zero)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + (num_cr*ele_reg + reg_one)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + (num_cr*ele_reg + reg_two)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + (num_cr*ele_reg + reg_three)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + (num_cr*ele_reg + reg_four)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + (num_cr*ele_reg + reg_five)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + (num_cr*ele_reg + reg_six)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + (num_cr*ele_reg + reg_seven)*row_len
                                       + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + num_r * col_len
                                        + (num_cr*ele_reg + reg_zero))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + num_r * col_len
                                        + (num_cr*ele_reg + reg_one))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + num_r * col_len
                                        + (num_cr*ele_reg + reg_two))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + num_r * col_len
                                        + (num_cr*ele_reg + reg_three))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + num_r * col_len
                                        + (num_cr*ele_reg + reg_four))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + num_r * col_len
                                        + (num_cr*ele_reg + reg_five))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + num_r * col_len
                                        + (num_cr*ele_reg + reg_six))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + num_r * col_len
                                        + (num_cr*ele_reg + reg_seven))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(num_d * param.get("two_dim_ele")
                                       + (r_cycle*ele_reg + num_er) * row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_d * param.get("two_dim_ele")
                                             + num_r * col_len
                                             + (r_cycle*ele_reg + num_er))),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _reg_mov_batch_two_10_row(args):
    """
    reg_mov data in ub for two dim 10 row scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, col_len,\
    num_d, num_c, row_len = args

    ele_reg = 8
    r_cycle = row_len // ele_reg
    r_mod = row_len % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + num_c*row_len
                                       + (num_cr*ele_reg + reg_zero)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + num_c*row_len
                                       + (num_cr*ele_reg + reg_one)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + num_c*row_len
                                       + (num_cr*ele_reg + reg_two)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + num_c*row_len
                                       + (num_cr*ele_reg + reg_three)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + num_c*row_len
                                       + (num_cr*ele_reg + reg_four)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + num_c*row_len
                                       + (num_cr*ele_reg + reg_five)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + num_c*row_len
                                       + (num_cr*ele_reg + reg_six)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + num_c*row_len
                                       + (num_cr*ele_reg + reg_seven)))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + (num_cr*ele_reg + reg_zero)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + (num_cr*ele_reg + reg_one)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + (num_cr*ele_reg + reg_two)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + (num_cr*ele_reg + reg_three)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + (num_cr*ele_reg + reg_four)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + (num_cr*ele_reg + reg_five)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + (num_cr*ele_reg + reg_six)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + (num_cr*ele_reg + reg_seven)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(num_d * param.get("two_dim_ele")
                                       + num_c * row_len
                                       + (r_cycle*ele_reg + num_er)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_d * param.get("two_dim_ele")
                                             + (r_cycle*ele_reg + num_er)
                                             * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _reg_mov_batch_two_10_align(args):
    """
    reg_mov data in ub for two dim 10 scene

    """
    tvm_ib, param, data_res, data_align, reg, reg_addr, ele_align, cp_len = args

    ele_reg = 8
    r_cycle = cp_len // ele_reg
    r_mod = cp_len % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_res.access_ptr('r',
                                offset=(ele_align + (num_cr*ele_reg
                                                     + reg_zero)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_res.access_ptr('r',
                                offset=(ele_align + (num_cr*ele_reg
                                                     + reg_one)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_res.access_ptr('r',
                                offset=(ele_align + (num_cr*ele_reg
                                                     + reg_two)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_res.access_ptr('r',
                                offset=(ele_align + (num_cr*ele_reg
                                                     + reg_three)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_res.access_ptr('r',
                                offset=(ele_align + (num_cr*ele_reg
                                                     + reg_four)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_res.access_ptr('r',
                                offset=(ele_align + (num_cr*ele_reg
                                                     + reg_five)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_res.access_ptr('r',
                                offset=(ele_align + (num_cr*ele_reg
                                                     + reg_six)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_res.access_ptr('r',
                                offset=(ele_align + (num_cr*ele_reg
                                                     + reg_seven)))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_align.dtype, "reg_mov",
            data_align.access_ptr('w',
                                  offset=(num_cr*ele_reg + reg_zero)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_align.dtype, "reg_mov",
            data_align.access_ptr('w',
                                  offset=(num_cr*ele_reg + reg_one)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_align.dtype, "reg_mov",
            data_align.access_ptr('w',
                                  offset=(num_cr*ele_reg + reg_two)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_align.dtype, "reg_mov",
            data_align.access_ptr('w',
                                  offset=(num_cr*ele_reg + reg_three)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_align.dtype, "reg_mov",
            data_align.access_ptr('w',
                                  offset=(num_cr*ele_reg + reg_four)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_align.dtype, "reg_mov",
            data_align.access_ptr('w',
                                  offset=(num_cr*ele_reg + reg_five)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_align.dtype, "reg_mov",
            data_align.access_ptr('w',
                                  offset=(num_cr*ele_reg + reg_six)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_align.dtype, "reg_mov",
            data_align.access_ptr('w',
                                  offset=(num_cr*ele_reg + reg_seven)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_res.access_ptr('r',
                                offset=(ele_align + (r_cycle*ele_reg + num_er)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_align.dtype, "reg_mov",
            data_align.access_ptr('w', offset=(r_cycle*ele_reg + num_er)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _func_more_two_dim_10(args):
    """
    function of moving data in more two dim 10 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_align, reg, reg_addr,\
    num_g, num_two_dim_cur_core = args

    num, col_len, row_len = data.shape
    num_two_dim_before_core = num_g * param.get("num_two_dim_group")\
                              + param.get("block_index")\
                              * param.get("num_two_dim_ub")
    ele_cur_core = num_two_dim_cur_core*param.get("two_dim_ele")
    # move data from gm to ub
    data_offset = num_two_dim_before_core*param.get("two_dim_ele")
    burst_len_data = _ceil_div(ele_cur_core,
                               param.get("cp_align_len"))
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r', offset=data_offset),
                                0, 1, burst_len_data, 0, 0))
    # reg_mov from data_ub to data_res
    with tvm_ib.if_scope(tvm.all(col_len < 8, row_len >= 8)):
        with tvm_ib.for_range(0, num_two_dim_cur_core, name="num_d") as num_d:
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       col_len, num_d, num_c, row_len
                _reg_mov_batch_two_10_row(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, num_two_dim_cur_core, name="num_d") as num_d:
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       row_len, num_d, num_r, col_len
                _reg_mov_batch_two_10_col(args)

    # move data from data_res to dst
    with tvm_ib.if_scope(ele_cur_core % param.get("cp_align_len") > 0):
        with tvm_ib.if_scope(ele_cur_core > param.get("cp_align_len")):
            ele_align = ele_cur_core - param.get("cp_align_len")
            dst_offset = num_two_dim_before_core * param.get("two_dim_ele")
            burst_len_align = _ceil_div(ele_align, param.get("cp_align_len"))
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len_align, 0, 0))
            args = tvm_ib, param, data_res, data_align, reg, reg_addr,\
                   ele_align, param.get("cp_align_len")
            _reg_mov_batch_two_10_align(args)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset
                                                       + ele_align),
                                        data_align.access_ptr("r", offset=0),
                                        0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            dst_offset = num_two_dim_before_core * param.get("two_dim_ele")
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, 1, 0, 0))

    with tvm_ib.else_scope():
        dst_offset = num_two_dim_before_core*param.get("two_dim_ele")
        burst_len_dst = ele_cur_core // param.get("cp_align_len")
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _more_two_dim_ir_10(dst, data, core_divide):
    """
    function of making ir node builder for more two dim scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_more_two_dim_10(tvm_ib, data.shape,
                                       dst.dtype, core_divide)
    data_ub = _new_alloc(tvm_ib, dst.dtype,
                         _ceil_fill(param.get("num_two_dim_ub")
                                    * param.get("two_dim_ele"),
                                    param.get("cp_align_len")),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype,
                          _ceil_fill(param.get("num_two_dim_ub")
                                     * param.get("two_dim_ele"),
                                     param.get("cp_align_len")),
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    data_align = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                            "data_align", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (8,), name='reg_addr',
                               scope=cce.scope_reg)
    with tvm_ib.for_range(0, param.get("num_group_index") + 1,
                          name="num_g") as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_align,\
                   reg, reg_addr, num_g, param.get("num_two_dim_ub")
            _func_more_two_dim_10(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod") // param.get(
                "num_two_dim_ub")
            num_two_dim_mod = param.get("num_group_mod") % param.get(
                "num_two_dim_ub")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_align, reg, reg_addr,\
                           num_g, param.get("num_two_dim_ub")
                    _func_more_two_dim_10(args)
            with tvm_ib.if_scope(num_two_dim_mod > 0):
                with tvm_ib.if_scope(
                    tvm.all(param.get("block_index") < (num_core + 1),
                            param.get("block_index") > (num_core - 1))):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_align, reg, reg_addr,\
                           num_g, num_two_dim_mod
                    _func_more_two_dim_10(args)

    return tvm_ib.get()


def _get_param_more_dim_10(tvm_ib, src_shape, dtype, core_divide):
    """
    calculate parameters for more dim 10 ir builder make function

    """
    num, col_len, row_len = src_shape
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 32
    ub_half = ub_bytes // 2
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = ub_half // float_size // core_divide
    row_len_one = ub_ele // col_len
    num_row_align_ub = row_len_one // cp_align_len
    num_row_align_dim = _ceil_div(row_len, cp_align_len)
    num_row_align_in_data = num_row_align_dim*num

    num_row_align_group = num_row_align_ub*device_core_num
    num_group_index = num_row_align_in_data // num_row_align_group
    num_group_mod = num_row_align_in_data % num_row_align_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "num_row_align_ub": num_row_align_ub,
                 "num_row_align_dim": num_row_align_dim,
                 "num_row_align_group": num_row_align_group}

    return param_map


def _reg_mov_batch_more_10_row(args):
    """
    reg_mov data in ub for more dim 10 row scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, col_len,\
    num_row_align_cur_core, num_c, row_cur_core_true = args

    ele_reg = 8
    r_cycle = row_cur_core_true // ele_reg
    r_mod = row_cur_core_true % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_align_cur_core
                                       * param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_zero)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_align_cur_core
                                       * param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_one)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_align_cur_core
                                       * param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_two)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_align_cur_core
                                       * param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_three)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_align_cur_core
                                       * param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_four)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_align_cur_core
                                       * param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_five)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_align_cur_core
                                       * param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_six)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_align_cur_core
                                       * param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_seven)))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_zero) * col_len
                                        + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_one) * col_len
                                        + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_two) * col_len
                                        + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_three) * col_len
                                        + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_four) * col_len
                                        + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_five) * col_len
                                        + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_six) * col_len
                                        + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_seven) * col_len
                                        + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_align_cur_core
                                       * param.get("cp_align_len")
                                       + (r_cycle*ele_reg + num_er)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=((r_cycle*ele_reg + num_er)
                                             * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _reg_mov_batch_more_10_col(args):
    """
    reg_mov data in ub for more dim 10 col scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, num_row_align_cur_core,\
    num_r, col_len = args

    ele_reg = 8
    r_cycle = col_len // ele_reg
    r_mod = col_len % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_zero)
                                       * num_row_align_cur_core
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_one)
                                       * num_row_align_cur_core
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_two)
                                       * num_row_align_cur_core
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_three)
                                       * num_row_align_cur_core
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_four)
                                       * num_row_align_cur_core
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_five)
                                       * num_row_align_cur_core
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_six)
                                       * num_row_align_cur_core
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_seven)
                                       * num_row_align_cur_core
                                       * param.get("cp_align_len") + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * col_len + (num_cr*ele_reg
                                                           + reg_zero))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * col_len + (num_cr*ele_reg
                                                           + reg_one))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * col_len + (num_cr*ele_reg
                                                           + reg_two))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * col_len + (num_cr*ele_reg
                                                           + reg_three))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * col_len + (num_cr*ele_reg
                                                           + reg_four))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * col_len + (num_cr*ele_reg
                                                           + reg_five))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * col_len + (num_cr*ele_reg
                                                           + reg_six))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * col_len + (num_cr*ele_reg
                                                           + reg_seven))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=((r_cycle*ele_reg + num_er)
                                       * num_row_align_cur_core
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_r * col_len
                                             + (r_cycle*ele_reg + num_er))),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _reg_mov_batch_more_10_tail_row(args):
    """
    reg_mov data in ub for more 10 dim tail row scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, ub_offset_tail,\
    res_offset_tail, col_len, num_c, row_len_tail = args

    ele_reg = 8
    r_cycle = row_len_tail // ele_reg
    r_mod = row_len_tail % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail + num_c * row_len_tail
                                       + (num_cr*ele_reg + reg_zero)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail + num_c * row_len_tail
                                       + (num_cr*ele_reg + reg_one)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail + num_c * row_len_tail
                                       + (num_cr*ele_reg + reg_two)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail + num_c * row_len_tail
                                       + (num_cr*ele_reg + reg_three)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail + num_c * row_len_tail
                                       + (num_cr*ele_reg + reg_four)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail + num_c * row_len_tail
                                       + (num_cr*ele_reg + reg_five)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail + num_c * row_len_tail
                                       + (num_cr*ele_reg + reg_six)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail + num_c * row_len_tail
                                       + (num_cr*ele_reg + reg_seven)))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail
                                        + (num_cr*ele_reg + reg_zero)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail
                                        + (num_cr*ele_reg + reg_one)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail
                                        + (num_cr*ele_reg + reg_two)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail
                                        + (num_cr*ele_reg + reg_three)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail
                                        + (num_cr*ele_reg + reg_four)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail
                                        + (num_cr*ele_reg + reg_five)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail
                                        + (num_cr*ele_reg + reg_six)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail
                                        + (num_cr*ele_reg + reg_seven)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail + num_c * row_len_tail
                                       + (r_cycle*ele_reg + num_er)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset_tail
                                             + (r_cycle*ele_reg + num_er)
                                             * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _reg_mov_batch_more_10_tail_col(args):
    """
    reg_mov data in ub for more 10 dim tail col scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, ub_offset_tail,\
    res_offset_tail, row_len_tail, num_r, col_len = args

    ele_reg = 8
    r_cycle = col_len // ele_reg
    r_mod = col_len % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail
                                       + (num_cr*ele_reg + reg_zero)
                                       * row_len_tail + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail
                                       + (num_cr*ele_reg + reg_one)
                                       * row_len_tail + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail
                                       + (num_cr*ele_reg + reg_two)
                                       * row_len_tail + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail
                                       + (num_cr*ele_reg + reg_three)
                                       * row_len_tail + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail
                                       + (num_cr*ele_reg + reg_four)
                                       * row_len_tail + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail
                                       + (num_cr*ele_reg + reg_five)
                                       * row_len_tail + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail
                                       + (num_cr*ele_reg + reg_six)
                                       * row_len_tail + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail
                                       + (num_cr*ele_reg + reg_seven)
                                       * row_len_tail + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail + num_r * col_len
                                        + (num_cr*ele_reg + reg_zero))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail + num_r * col_len
                                        + (num_cr*ele_reg + reg_one))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail + num_r * col_len
                                        + (num_cr*ele_reg + reg_two))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail + num_r * col_len
                                        + (num_cr*ele_reg + reg_three))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail + num_r * col_len
                                        + (num_cr*ele_reg + reg_four))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail + num_r * col_len
                                        + (num_cr*ele_reg + reg_five))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail + num_r * col_len
                                        + (num_cr*ele_reg + reg_six))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail + num_r * col_len
                                        + (num_cr*ele_reg + reg_seven))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail
                                       + (r_cycle*ele_reg + num_er)
                                       * row_len_tail + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset_tail + num_r * col_len
                                             + (r_cycle*ele_reg + num_er))),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _func_more_dim_10(args):
    """
    function of moving data in more dim 10 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_align, reg, reg_addr,\
    num_g, num_row_align_cur_core = args

    num, col_len, row_len = data.shape
    two_dim_ele = col_len*row_len
    num_row_align_before_core = num_g * param.get("num_row_align_group")\
                                + param.get("block_index")\
                                * param.get("num_row_align_ub")
    num_two_dim_before_core = num_row_align_before_core\
                              // param.get("num_row_align_dim")
    num_align_cur_dim_before = num_row_align_before_core\
                               % param.get("num_row_align_dim")
    num_align_cur_dim = param.get("num_row_align_dim")\
                        - num_align_cur_dim_before

    with tvm_ib.if_scope(num_align_cur_dim >= num_row_align_cur_core):
        # move data from gm to ub
        data_offset = num_two_dim_before_core*two_dim_ele\
                      + num_align_cur_dim_before*param.get("cp_align_len")
        burst_len_data = num_row_align_cur_core
        with tvm_ib.if_scope(row_len % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                data_offset_cur = data_offset + num_c * row_len
                ub_offset_cur = num_c * num_row_align_cur_core\
                                * param.get("cp_align_len")
                tvm_ib.emit(
                    tvm.call_extern(
                        data_ub.dtype, "copy_gm_to_ubuf",
                        data_ub.access_ptr("w", offset=ub_offset_cur),
                        data.access_ptr(
                            'r', offset=data_offset_cur),
                        0, 1, burst_len_data, 0, 0))
        with tvm_ib.else_scope():
            n_burst = col_len
            src_stride = param.get("num_row_align_dim")\
                         - num_row_align_cur_core
            args = tvm_ib, param, data, data_ub, data_offset, 0, n_burst,\
                   burst_len_data, src_stride, 0
            _func_gm_to_ub(args)

        # move data from data_ub to data_res
        row_end = tvm.min((num_align_cur_dim_before + num_row_align_cur_core)
                          * param.get("cp_align_len"), row_len)
        row_cur_core_true = row_end - num_align_cur_dim_before\
                            * param.get("cp_align_len")
        reg_addr[4] = row_cur_core_true
        with tvm_ib.if_scope(tvm.all(col_len < 8, row_cur_core_true >= 8)):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       col_len, num_row_align_cur_core, num_c, reg_addr[4]
                _reg_mov_batch_more_10_row(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, row_cur_core_true, name="num_r") as num_r:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       num_row_align_cur_core, num_r, col_len
                _reg_mov_batch_more_10_col(args)

        # move data from data_res to dst
        row_ele = row_cur_core_true*col_len
        reg_addr[0] = row_ele
        dst_offset = num_two_dim_before_core * two_dim_ele \
                     + num_align_cur_dim_before \
                     * param.get("cp_align_len") * col_len
        with tvm_ib.if_scope(reg_addr[0] % param.get("cp_align_len") > 0):
            with tvm_ib.if_scope(row_ele > param.get("cp_align_len")):
                row_align = row_ele - param.get("cp_align_len")
                burst_len_dst = _ceil_div(row_align, param.get("cp_align_len"))
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr("r", offset=0),
                                            0, 1, burst_len_dst, 0, 0))
                args = tvm_ib, param, data_res, data_align, reg, reg_addr,\
                       row_align, param.get("cp_align_len")
                _reg_mov_batch_two_10_align(args)
                reg_addr[2] = row_align
                tvm_ib.emit(
                    tvm.call_extern(
                        dst.dtype, "copy_ubuf_to_gm",
                        dst.access_ptr(
                            'w', offset=dst_offset + reg_addr[2]),
                        data_align.access_ptr("r", offset=0),
                        0, 1, 1, 0, 0))
            with tvm_ib.else_scope():
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr("r", offset=0),
                                            0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            burst_len_dst = reg_addr[0] // param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))
    with tvm_ib.if_scope(num_align_cur_dim < num_row_align_cur_core):
        num_row_align_head = num_align_cur_dim
        num_row_align_tail = num_row_align_cur_core - num_align_cur_dim
        # move data from gm to ub for head
        data_offset_head = num_two_dim_before_core*two_dim_ele \
                           + num_align_cur_dim_before*param.get("cp_align_len")
        burst_len_data = num_row_align_head
        with tvm_ib.if_scope(row_len % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                data_offset_cur = data_offset_head + num_c*row_len
                ub_offset_cur = num_c*num_row_align_head*param.get("cp_align_len")
                tvm_ib.emit(
                    tvm.call_extern(
                        data_ub.dtype, "copy_gm_to_ubuf",
                        data_ub.access_ptr("w", offset=ub_offset_cur),
                        data.access_ptr(
                            'r', offset=data_offset_cur),
                        0, 1, burst_len_data, 0, 0))
        with tvm_ib.else_scope():
            n_burst = col_len
            src_stride = param.get("num_row_align_dim") - num_row_align_head
            args = tvm_ib, param, data, data_ub, data_offset_head, 0, n_burst,\
                   burst_len_data, src_stride, 0
            _func_gm_to_ub(args)
        # move data from data_ub to data_res for head
        row_end = tvm.min((num_align_cur_dim_before + num_row_align_head)
                          * param.get("cp_align_len"), row_len)
        row_cur_core_true = row_end - num_align_cur_dim_before\
                            * param.get("cp_align_len")
        reg_addr[5] = row_cur_core_true
        with tvm_ib.if_scope(tvm.all(col_len < 8, row_cur_core_true >= 8)):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       col_len, num_row_align_head, num_c, reg_addr[5]
                _reg_mov_batch_more_10_row(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, row_cur_core_true, name="num_r") as num_r:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       num_row_align_head, num_r, col_len
                _reg_mov_batch_more_10_col(args)

        # move data from gm to ub for tail
        row_len_tail = num_row_align_tail*param.get("cp_align_len")
        reg_addr[6] = row_len_tail
        num_two_dim_before_tail = num_two_dim_before_core + 1
        data_offset_tail = num_two_dim_before_tail*two_dim_ele
        burst_len_data = num_row_align_tail
        ub_offset_tail = col_len*num_row_align_head*param.get("cp_align_len")
        with tvm_ib.if_scope(row_len % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                data_offset_cur = data_offset_tail + num_c*row_len
                ub_offset_cur = ub_offset_tail + num_c*row_len_tail
                tvm_ib.emit(
                    tvm.call_extern(
                        data_ub.dtype, "copy_gm_to_ubuf",
                        data_ub.access_ptr("w", offset=ub_offset_cur),
                        data.access_ptr(
                            'r', offset=data_offset_cur),
                        0, 1, burst_len_data, 0, 0))
        with tvm_ib.else_scope():
            n_burst = col_len
            src_stride = param.get("num_row_align_dim") - num_row_align_tail
            args = tvm_ib, param, data, data_ub, data_offset_tail,\
                   ub_offset_tail, n_burst, burst_len_data, src_stride, 0
            _func_gm_to_ub(args)
        # move data from data_ub to data_res for tail
        res_offset_tail = row_cur_core_true*col_len
        with tvm_ib.if_scope(tvm.all(col_len < 8, row_len_tail >= 8)):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       ub_offset_tail,\
                       res_offset_tail, col_len, num_c, reg_addr[6]
                _reg_mov_batch_more_10_tail_row(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, row_len_tail, name="num_r") as num_r:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       ub_offset_tail,\
                       res_offset_tail, row_len_tail, num_r, col_len
                _reg_mov_batch_more_10_tail_col(args)
        # move data from data_res to dst for head and tail
        all_ele = col_len*(row_cur_core_true + row_len_tail)
        reg_addr[1] = all_ele
        dst_offset = num_two_dim_before_core*two_dim_ele\
                     + num_align_cur_dim_before\
                     * param.get("cp_align_len")*col_len
        with tvm_ib.if_scope(reg_addr[1] % param.get("cp_align_len") > 0):
            with tvm_ib.if_scope(all_ele > param.get("cp_align_len")):
                ele_align = all_ele - param.get("cp_align_len")
                burst_len_align = _ceil_div(ele_align,
                                            param.get("cp_align_len"))
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr("r", offset=0),
                                            0, 1, burst_len_align, 0, 0))
                with tvm_ib.for_range(0, param.get("cp_align_len"),
                                      name="num_a") as num_a:
                    tvm_ib.emit(tvm.call_extern(
                        data_res.dtype, "reg_mov",
                        tvm.call_extern(reg.dtype, "reg", reg[0]),
                        data_res.access_ptr('r',
                                            offset=(ele_align + num_a))
                    ))
                    tvm_ib.emit(tvm.call_extern(
                        data_align.dtype, "reg_mov",
                        data_align.access_ptr('w', offset=num_a),
                        tvm.call_extern(reg.dtype, "reg", reg[0])
                    ))
                reg_addr[3] = ele_align
                tvm_ib.emit(
                    tvm.call_extern(
                        dst.dtype, "copy_ubuf_to_gm",
                        dst.access_ptr(
                            'w', offset=dst_offset + reg_addr[3]),
                        data_align.access_ptr("r", offset=0),
                        0, 1, 1, 0, 0))
            with tvm_ib.else_scope():
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr("r", offset=0),
                                            0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            burst_len_dst = reg_addr[1] // param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))


def _more_dim_ir_10(dst, data, core_divide):
    """
    function of making ir node builder for more dim 10 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_more_dim_10(tvm_ib, data.shape, dst.dtype, core_divide)
    num, col_len, row_len = data.shape
    data_ub = _new_alloc(tvm_ib, dst.dtype,
                         param.get("num_row_align_ub")
                         * param.get("cp_align_len") * col_len,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype,
                          param.get("num_row_align_ub")
                          * param.get("cp_align_len") * col_len,
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    data_align = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                            "data_align", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (8,), name='reg_addr',
                               scope=cce.scope_reg)
    with tvm_ib.for_range(0, param.get("num_group_index") + 1,
                          name="num_g") as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_align,\
                   reg, reg_addr, num_g, param.get("num_row_align_ub")
            _func_more_dim_10(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod") // param.get(
                "num_row_align_ub")
            num_row_align_mod = param.get("num_group_mod") % param.get(
                "num_row_align_ub")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_align, \
                           reg, reg_addr, num_g, param.get("num_row_align_ub")
                    _func_more_dim_10(args)
            with tvm_ib.if_scope(num_row_align_mod > 0):
                with tvm_ib.if_scope(
                    tvm.all(param.get("block_index") < (num_core + 1),
                            param.get("block_index") > (num_core - 1))):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_align, \
                           reg, reg_addr, num_g, num_row_align_mod
                    _func_more_dim_10(args)

    return tvm_ib.get()


def _get_param_split_dim_10(tvm_ib, src_shape, dtype, core_divide):
    """
    calculate parameters for split dim 10 ir builder make function

    """
    num, col_len, row_len = src_shape
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 32 - 32 * cp_align_len
    ub_half = ub_bytes // 2
    ub_ele = ub_half // float_size // core_divide
    row_len_align = _ceil_fill(row_len, cp_align_len)
    col_len_one_core = (ub_ele // row_len_align // cp_align_len)*cp_align_len
    col_len_one_group = col_len_one_core*device_core_num
    col_len_align = _ceil_fill(col_len, cp_align_len)
    col_len_in_data_align = num*col_len_align

    num_group_index = col_len_in_data_align // col_len_one_group
    num_group_mod = col_len_in_data_align % col_len_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "col_len_one_core": col_len_one_core,
                 "col_len_one_group": col_len_one_group,
                 "row_len_align": row_len_align}

    return param_map


def _reg_mov_batch_split_10_tail_row(args):
    """
    reg_mov data in ub for split dim 10 tail row scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, num_col_len_cur_core,\
    num_c, row_len_true, row_len = args

    ele_reg = 8
    r_cycle = row_len_true // ele_reg
    r_mod = row_len_true % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(num_c * row_len
                                       + (num_cr*ele_reg + reg_zero)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(num_c * row_len
                                       + (num_cr*ele_reg + reg_one)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(num_c * row_len
                                       + (num_cr*ele_reg + reg_two)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(num_c * row_len
                                       + (num_cr*ele_reg + reg_three)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(num_c * row_len
                                       + (num_cr*ele_reg + reg_four)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(num_c * row_len
                                       + (num_cr*ele_reg + reg_five)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(num_c * row_len
                                       + (num_cr*ele_reg + reg_six)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(num_c * row_len
                                       + (num_cr*ele_reg + reg_seven)))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_zero)
                                        * num_col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_one)
                                        * num_col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_two)
                                        * num_col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_three)
                                        * num_col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_four)
                                        * num_col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_five)
                                        * num_col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_six)
                                        * num_col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_seven)
                                        * num_col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(num_c * row_len
                                       + (r_cycle*ele_reg + num_er)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=((r_cycle*ele_reg + num_er)
                                             * num_col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _reg_mov_batch_split_10_tail_col(args):
    """
    reg_mov data in ub for split dim tail col scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, row_len, num_r,\
    num_col_true, num_col_len_cur_core = args

    ele_reg = 8
    r_cycle = num_col_true // ele_reg
    r_mod = num_col_true % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=((num_cr * ele_reg + reg_zero)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=((num_cr * ele_reg + reg_one)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=((num_cr * ele_reg + reg_two)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=((num_cr * ele_reg + reg_three)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=((num_cr * ele_reg + reg_four)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=((num_cr * ele_reg + reg_five)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=((num_cr * ele_reg + reg_six)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=((num_cr * ele_reg + reg_seven)*row_len
                                       + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * num_col_len_cur_core
                                        + (num_cr * ele_reg + reg_zero))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * num_col_len_cur_core
                                        + (num_cr * ele_reg + reg_one))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * num_col_len_cur_core
                                        + (num_cr * ele_reg + reg_two))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * num_col_len_cur_core
                                        + (num_cr * ele_reg + reg_three))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * num_col_len_cur_core
                                        + (num_cr * ele_reg + reg_four))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * num_col_len_cur_core
                                        + (num_cr * ele_reg + reg_five))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * num_col_len_cur_core
                                        + (num_cr * ele_reg + reg_six))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * num_col_len_cur_core
                                        + (num_cr * ele_reg + reg_seven))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=((r_cycle*ele_reg + num_er)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_r * num_col_len_cur_core
                                             + (r_cycle * ele_reg + num_er))),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _func_split_dim_10(args):
    """
    function of moving data in split dim 10 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_align, data_tail, reg,\
    reg_addr, num_g, num_col_len_cur_core = args

    num, col_len, row_len = data.shape
    two_dim_ele = col_len*row_len
    col_len_align = _ceil_fill(col_len, param.get("cp_align_len"))
    num_col_len_before_core = num_g * param.get("col_len_one_group")\
                              + param.get("block_index")\
                              * param.get("col_len_one_core")
    num_dim_before_core = num_col_len_before_core // col_len_align
    num_col_len_dim_before = num_col_len_before_core % col_len_align
    num_col_len_cur_dim_align = col_len_align - num_col_len_dim_before
    num_col_len_cur_dim_true = col_len - num_col_len_dim_before

    with tvm_ib.if_scope(num_col_len_cur_dim_align > num_col_len_cur_core):
        data_offset = num_dim_before_core * two_dim_ele\
                      + row_len * num_col_len_dim_before
        burst_len_data = _ceil_div(num_col_len_cur_core * row_len,
                                   param.get("cp_align_len"))
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        with tvm_ib.if_scope(tvm.all(num_col_len_cur_core < 8, row_len >= 8)):
            with tvm_ib.for_range(0, num_col_len_cur_core,
                                  name="num_c") as num_c:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       num_col_len_cur_core, num_c, row_len, row_len
                _reg_mov_batch_split_10_tail_row(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       row_len, num_r, num_col_len_cur_core,\
                       num_col_len_cur_core
                _reg_mov_batch_split_10_tail_col(args)
        burst_len_dst = num_col_len_cur_core // param.get("cp_align_len")
        with tvm_ib.if_scope(col_len % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                dst_offset_cur = num_dim_before_core*two_dim_ele\
                                 + num_col_len_dim_before + num_r*col_len
                res_offset_cur = num_r*num_col_len_cur_core
                tvm_ib.emit(
                    tvm.call_extern(
                        dst.dtype, "copy_ubuf_to_gm",
                        dst.access_ptr(
                            'w', offset=dst_offset_cur),
                        data_res.access_ptr(
                            "r", offset=res_offset_cur),
                        0, 1, burst_len_dst, 0, 0))
        with tvm_ib.else_scope():
            dst_offset = num_dim_before_core*two_dim_ele\
                         + num_col_len_dim_before
            n_burst = row_len
            dst_stride = (col_len - num_col_len_cur_core)\
                         // param.get("cp_align_len")
            args = tvm_ib, param, dst, data_res, dst_offset, 0, n_burst, \
                   burst_len_dst, 0, dst_stride
            _func_ub_to_gm(args)
    with tvm_ib.if_scope(num_col_len_cur_dim_align <= num_col_len_cur_core):
        num_col_len_head_align = num_col_len_cur_dim_align
        num_col_len_head_true = num_col_len_cur_dim_true
        reg_addr[0] = num_col_len_head_true
        # move data for head
        # move data from gm to ub
        data_offset = num_dim_before_core * two_dim_ele\
                      + row_len * num_col_len_dim_before
        burst_len_data = _ceil_div(row_len*num_col_len_head_true,
                                   param.get("cp_align_len"))
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))
        # move data from data_ub to data_res
        with tvm_ib.if_scope(tvm.all(num_col_len_head_true < 8, row_len >= 8)):
            with tvm_ib.for_range(0, num_col_len_head_true,
                                  name="num_c") as num_c:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       num_col_len_head_align, num_c, row_len, row_len
                _reg_mov_batch_split_10_tail_row(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       row_len, num_r, reg_addr[0], num_col_len_head_align
                _reg_mov_batch_split_10_tail_col(args)
        # move data from data_res to dst
        with tvm_ib.if_scope(col_len % param.get("cp_align_len") > 0):
            with tvm_ib.if_scope(num_col_len_head_true
                                 > param.get("cp_align_len")):
                col_len_align = num_col_len_head_true\
                                - param.get("cp_align_len")
                reg_addr[5] = col_len_align
                with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                    dst_offset_cur = num_dim_before_core*two_dim_ele\
                                     + num_col_len_dim_before + num_r*col_len
                    res_offset_cur = num_r*num_col_len_head_align
                    burst_len_dst = _ceil_div(col_len_align,
                                              param.get("cp_align_len"))
                    tvm_ib.emit(
                        tvm.call_extern(
                            dst.dtype, "copy_ubuf_to_gm",
                            dst.access_ptr(
                                'w', offset=dst_offset_cur),
                            data_res.access_ptr(
                                "r", offset=res_offset_cur),
                            0, 1, burst_len_dst, 0, 0))
                    ele_len = res_offset_cur + reg_addr[5]
                    args = tvm_ib, param, data_res, data_align, reg, reg_addr,\
                           ele_len, param.get("cp_align_len")
                    _reg_mov_batch_two_10_align(args)
                    tvm_ib.emit(
                        tvm.call_extern(
                            dst.dtype, "copy_ubuf_to_gm",
                            dst.access_ptr(
                                'w', offset=dst_offset_cur + reg_addr[5]),
                            data_align.access_ptr(
                                "r", offset=0),
                            0, 1, 1, 0, 0))
            with tvm_ib.else_scope():
                num_ele_align = param.get("cp_align_len")\
                                - num_col_len_head_true
                reg_addr[6] = num_ele_align
                with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                    with tvm_ib.if_scope(num_r < (row_len - 1)):
                        with tvm_ib.if_scope(row_len
                                             % param.get("cp_align_len") > 0):
                            with tvm_ib.for_range(0, num_ele_align,
                                                  name="num_e") as num_e:
                                tail_offset_cur = num_e\
                                                  * param.get("cp_align_len")
                                data_offset_cur = num_dim_before_core\
                                                  * two_dim_ele\
                                                  + num_e*row_len + num_r + 1
                                tvm_ib.emit(
                                    tvm.call_extern(
                                        data_tail.dtype,
                                        "copy_gm_to_ubuf",
                                        data_tail.access_ptr(
                                            "w", offset=tail_offset_cur),
                                        data.access_ptr(
                                            'r', offset=data_offset_cur),
                                        0, 1, 1, 0, 0))
                        with tvm_ib.else_scope():
                            data_offset = num_dim_before_core*two_dim_ele\
                                          + num_r + 1
                            n_burst_tail = reg_addr[6]
                            src_stride = row_len // param.get("cp_align_len")\
                                         - 1
                            args = tvm_ib, param, data, data_tail, data_offset,\
                                   0, reg_addr[6], 1, src_stride, 0
                            _func_gm_to_ub(args)

                    with tvm_ib.else_scope():
                        with tvm_ib.if_scope(row_len
                                             % param.get("cp_align_len") > 0):
                            with tvm_ib.for_range(0, num_ele_align,
                                                  name="num_e") as num_e:
                                tail_offset_cur = num_e\
                                                  * param.get("cp_align_len")
                                data_offset_cur = (num_dim_before_core + 1)\
                                                  * two_dim_ele + num_e*row_len
                                tvm_ib.emit(
                                    tvm.call_extern(
                                        data_tail.dtype,
                                        "copy_gm_to_ubuf",
                                        data_tail.access_ptr(
                                            "w", offset=tail_offset_cur),
                                        data.access_ptr(
                                            'r', offset=data_offset_cur),
                                        0, 1, 1, 0, 0))
                        with tvm_ib.else_scope():
                            data_offset = (num_dim_before_core + 1)*two_dim_ele
                            n_burst_tail = reg_addr[6]
                            src_stride = row_len // param.get("cp_align_len")\
                                         - 1
                            args = tvm_ib, param, data, data_tail, data_offset,\
                                   0, n_burst_tail, 1, src_stride, 0
                            _func_gm_to_ub(args)
                    with tvm_ib.for_range(0, num_ele_align, name="num_ae")\
                            as num_ae:
                        tvm_ib.emit(tvm.call_extern(
                            data_tail.dtype, "reg_mov",
                            tvm.call_extern(reg.dtype, "reg", reg[0]),
                            data_tail.access_ptr(
                                'r',
                                offset=(num_ae * param.get("cp_align_len")))
                        ))
                        tvm_ib.emit(tvm.call_extern(
                            data_res.dtype, "reg_mov",
                            data_res.access_ptr(
                                'w', offset=num_r * num_col_len_head_align
                                + num_col_len_head_true + num_ae),
                            tvm.call_extern(reg.dtype, "reg", reg[0])
                        ))
                    dst_offset_cur = num_dim_before_core*two_dim_ele\
                                     + num_r*col_len + num_col_len_dim_before
                    res_offset_cur = num_r*num_col_len_head_align
                    tvm_ib.emit(
                        tvm.call_extern(
                            dst.dtype, "copy_ubuf_to_gm",
                            dst.access_ptr('w', offset=dst_offset_cur),
                            data_res.access_ptr("r", offset=res_offset_cur),
                            0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            dst_offset = num_dim_before_core * two_dim_ele\
                         + num_col_len_dim_before
            n_burst = row_len
            burst_len_dst = reg_addr[0] // param.get("cp_align_len")
            reg_addr[1] = col_len - num_col_len_head_true
            dst_stride = reg_addr[1] // param.get("cp_align_len")
            args = tvm_ib, param, dst, data_res, dst_offset, 0, n_burst, \
                   burst_len_dst, 0, dst_stride
            _func_ub_to_gm(args)

        # move data for tail
        num_col_len_tail = num_col_len_cur_core - num_col_len_head_align
        reg_addr[3] = num_col_len_tail
        with tvm_ib.if_scope(num_col_len_tail > 0):
            # move data from gm to ub
            ub_offset = num_col_len_head_align * row_len
            data_offset = (num_dim_before_core + 1)*two_dim_ele
            reg_addr[2] = num_col_len_tail*row_len
            burst_len_tail = reg_addr[2] // param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_tail, 0, 0))
            # move data from data_ub to data_res
            res_offset = num_col_len_head_align*row_len
            with tvm_ib.if_scope(tvm.all(num_col_len_tail < 8, row_len >= 8)):
                with tvm_ib.for_range(0, num_col_len_tail,
                                      name="num_c") as num_c:
                    args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                           ub_offset,\
                           res_offset, num_col_len_tail, num_c, row_len
                    _reg_mov_batch_more_10_tail_row(args)
            with tvm_ib.else_scope():
                with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                    args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                           ub_offset,\
                           res_offset, row_len, num_r, reg_addr[3]
                    _reg_mov_batch_more_10_tail_col(args)
            # move data from data_res to dst
            burst_len_dst = reg_addr[3] // param.get("cp_align_len")
            with tvm_ib.if_scope(col_len % param.get("cp_align_len") > 0):
                with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                    dst_offset_cur = (num_dim_before_core + 1) * two_dim_ele\
                                     + num_r * col_len
                    res_offset_cur = res_offset + num_r*num_col_len_tail
                    tvm_ib.emit(
                        tvm.call_extern(
                            dst.dtype, "copy_ubuf_to_gm",
                            dst.access_ptr(
                                'w', offset=dst_offset_cur),
                            data_res.access_ptr(
                                "r", offset=res_offset_cur),
                            0, 1, burst_len_dst, 0, 0))
            with tvm_ib.else_scope():
                dst_offset = (num_dim_before_core + 1)*two_dim_ele
                n_burst = row_len
                reg_addr[4] = col_len - num_col_len_tail
                dst_stride = reg_addr[4] // param.get("cp_align_len")
                args = tvm_ib, param, dst, data_res, dst_offset,\
                       res_offset, n_burst, \
                       burst_len_dst, 0, dst_stride
                _func_ub_to_gm(args)


def _split_dim_ir_10(dst, data, core_divide):
    """
    function of making ir node builder for split dim 10 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_split_dim_10(tvm_ib, data.shape, dst.dtype, core_divide)
    data_ub = _new_alloc(tvm_ib, dst.dtype,
                         param.get("col_len_one_core")
                         * param.get("row_len_align"),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype,
                          param.get("col_len_one_core")
                          * param.get("row_len_align"),
                          "data_res", scope=cce.scope_ubuf)
    data_align = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                            "data_align", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype,
                           param.get('cp_align_len')
                           * param.get("cp_align_len"),
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    reg_addr = tvm_ib.allocate("int32", (8,), name='reg_addr',
                               scope=cce.scope_reg)
    with tvm_ib.for_range(0, param.get("num_group_index") + 1,
                          name="num_g") as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_align,\
                   data_tail, reg,\
                   reg_addr, num_g, param.get("col_len_one_core")
            _func_split_dim_10(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod") // param.get(
                "col_len_one_core")
            num_col_len_mod = param.get("num_group_mod") % param.get(
                "col_len_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_align, data_tail, reg, \
                           reg_addr, num_g, param.get("col_len_one_core")
                    _func_split_dim_10(args)
            with tvm_ib.if_scope(num_col_len_mod > 0):
                with tvm_ib.if_scope(
                    tvm.all(param.get("block_index") < (num_core + 1),
                            param.get("block_index") > (num_core - 1))):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_align, data_tail, reg, \
                           reg_addr, num_g, num_col_len_mod
                    _func_split_dim_10(args)

    return tvm_ib.get()


def _get_param_large_two_dim_10(tvm_ib, src_shape, dtype, core_divide):
    """
    calculate parameters for large two dim 10 ir builder make function

    """
    num, col_len, row_len = src_shape
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 32 - 32*cp_align_len
    ub_half = ub_bytes // 2
    ub_ele = ub_half // float_size // core_divide
    row_len_align = _ceil_fill(row_len, cp_align_len)
    col_len_align = _ceil_fill(col_len, cp_align_len)
    col_len_one_core = (ub_ele // cp_align_len // cp_align_len)*cp_align_len
    col_len_one_group = col_len_one_core*device_core_num
    col_len_in_data = (row_len_align // cp_align_len)*col_len_align*num
    num_group_index = col_len_in_data // col_len_one_group
    num_group_mod = col_len_in_data % col_len_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "col_len_one_core": col_len_one_core,
                 "col_len_one_group": col_len_one_group,
                 "row_len_align": row_len_align}

    return param_map


def _reg_mov_batch_large_10_tail_row(args):
    """
    reg_mov data in ub for large two dim 10 tail row scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, ub_offset,\
    res_offset, col_len_cur_core, num_c, row_true = args

    ele_reg = 8
    r_cycle = row_true // ele_reg
    r_mod = row_true % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(ub_offset
                                       + num_c*param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_zero)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(ub_offset
                                       + num_c*param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_one)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(ub_offset
                                       + num_c*param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_two)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(ub_offset
                                       + num_c*param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_three)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(ub_offset
                                       + num_c*param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_four)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(ub_offset
                                       + num_c*param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_five)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(ub_offset
                                       + num_c*param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_six)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(ub_offset
                                       + num_c*param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_seven)))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset
                                        + (num_cr*ele_reg + reg_zero)
                                        * col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset
                                        + (num_cr*ele_reg + reg_one)
                                        * col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset
                                        + (num_cr*ele_reg + reg_two)
                                        * col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset
                                        + (num_cr*ele_reg + reg_three)
                                        * col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset
                                        + (num_cr*ele_reg + reg_four)
                                        * col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset
                                        + (num_cr*ele_reg + reg_five)
                                        * col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset
                                        + (num_cr*ele_reg + reg_six)
                                        * col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset
                                        + (num_cr*ele_reg + reg_seven)
                                        * col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(ub_offset
                                       + num_c*param.get("cp_align_len")
                                       + (r_cycle*ele_reg + num_er)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset
                                             + (r_cycle*ele_reg + num_er)
                                             * col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _reg_mov_batch_large_10_tail_col(args):
    """
    reg_mov data in ub for large two dim 10 tail col scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, ub_offset, res_offset,\
    row_true, num_r, col_len_cur_core = args

    ele_reg = 8
    r_cycle = col_len_cur_core // ele_reg
    r_mod = col_len_cur_core % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_zero)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_one)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_two)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_three)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_four)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_five)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_six)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_seven)
                                       * param.get("cp_align_len") + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset + num_r * col_len_cur_core
                                        + (num_cr*ele_reg + reg_zero))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset + num_r * col_len_cur_core
                                        + (num_cr*ele_reg + reg_one))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset + num_r * col_len_cur_core
                                        + (num_cr*ele_reg + reg_two))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset + num_r * col_len_cur_core
                                        + (num_cr*ele_reg + reg_three))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset + num_r * col_len_cur_core
                                        + (num_cr*ele_reg + reg_four))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset + num_r * col_len_cur_core
                                        + (num_cr*ele_reg + reg_five))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset + num_r * col_len_cur_core
                                        + (num_cr*ele_reg + reg_six))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset + num_r * col_len_cur_core
                                        + (num_cr*ele_reg + reg_seven))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (r_cycle*ele_reg + num_er)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset
                                             + num_r*col_len_cur_core
                                             + (r_cycle*ele_reg + num_er))),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _func_large_two_dim_10(args):
    """
    function of moving data in large two dim 10 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_align, data_tail, reg,\
    reg_addr, num_g, col_len_cur_core = args

    num, col_len, row_len = data.shape
    two_dim_ele = col_len*row_len
    row_len_align = _ceil_fill(row_len, param.get("cp_align_len"))
    col_len_align = _ceil_fill(col_len, param.get("cp_align_len"))
    num_col_len_before_core = num_g*param.get("col_len_one_group")\
                              + param.get("block_index")\
                              * param.get("col_len_one_core")
    num_col_len_align_two_dim = (row_len_align // param.get("cp_align_len"))\
                                * col_len_align
    num_two_dim_before_core = num_col_len_before_core\
                              // num_col_len_align_two_dim
    num_col_len_two_dim_before = num_col_len_before_core\
                                 % num_col_len_align_two_dim
    num_dim_before_cur_two = num_col_len_two_dim_before // col_len_align
    num_col_len_cur_dim_before = num_col_len_two_dim_before % col_len_align
    num_col_len_cur_dim_align = col_len_align - num_col_len_cur_dim_before
    num_col_len_cur_dim_true = col_len - num_col_len_cur_dim_before

    with tvm_ib.if_scope(num_col_len_cur_dim_align > col_len_cur_core):
        # move data from gm to ub
        data_offset = num_two_dim_before_core * two_dim_ele \
                      + num_col_len_cur_dim_before * row_len \
                      + num_dim_before_cur_two * param.get("cp_align_len")
        with tvm_ib.if_scope(row_len % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, col_len_cur_core, name="num_cl") as num_cl:
                data_offset_cur = data_offset + num_cl*row_len
                ub_offset_cur = num_cl*param.get("cp_align_len")
                tvm_ib.emit(
                    tvm.call_extern(
                        data_ub.dtype, "copy_gm_to_ubuf",
                        data_ub.access_ptr(
                            "w", offset=ub_offset_cur),
                        data.access_ptr(
                            'r', offset=data_offset_cur),
                        0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            n_burst = col_len_cur_core
            src_stride = row_len // param.get("cp_align_len") - 1
            args = tvm_ib, param, data, data_ub, data_offset, 0,\
                   n_burst, 1, src_stride, 0
            _func_gm_to_ub(args)
        # move data from data_ub to data_res
        row_end = tvm.min((num_dim_before_cur_two + 1)
                          * param.get("cp_align_len"), row_len)
        row_true = row_end - (num_dim_before_cur_two*param.get("cp_align_len"))
        reg_addr[7] = row_true
        with tvm_ib.for_range(0, row_true, name="num_r") as num_r:
            args = tvm_ib, param, data_ub, data_res, reg, reg_addr, 0, 0,\
                   row_true, num_r, col_len_cur_core
            _reg_mov_batch_large_10_tail_col(args)
        # move data from data_res to dst
        dst_offset = num_two_dim_before_core * two_dim_ele\
                     + num_dim_before_cur_two * param.get("cp_align_len")\
                     * col_len\
                     + num_col_len_cur_dim_before
        burst_len_dst = col_len_cur_core // param.get("cp_align_len")
        with tvm_ib.if_scope(col_len % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, row_true, name="num_rt") as num_rt:
                dst_offset_cur = dst_offset + num_rt*col_len
                res_offset_cur = num_rt*col_len_cur_core
                tvm_ib.emit(
                    tvm.call_extern(
                        dst.dtype, "copy_ubuf_to_gm",
                        dst.access_ptr(
                            'w', offset=dst_offset_cur),
                        data_res.access_ptr(
                            "r", offset=res_offset_cur),
                        0, 1, burst_len_dst, 0, 0))
        with tvm_ib.else_scope():
            n_burst = row_true
            reg_addr[0] = col_len - col_len_cur_core
            dst_stride = reg_addr[0] // param.get("cp_align_len")
            args = tvm_ib, param, dst, data_res, dst_offset, 0, reg_addr[7],\
                   burst_len_dst, 0, dst_stride
            _func_ub_to_gm(args)
    with tvm_ib.if_scope(num_col_len_cur_dim_align <= col_len_cur_core):
        # move data for head
        num_col_len_head_align = num_col_len_cur_dim_align
        num_col_len_head_true = num_col_len_cur_dim_true
        reg_addr[1] = num_col_len_head_true
        # move data from gm to ub
        data_offset = num_two_dim_before_core * two_dim_ele \
                      + num_col_len_cur_dim_before * row_len \
                      + num_dim_before_cur_two * param.get("cp_align_len")
        with tvm_ib.if_scope(row_len % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, num_col_len_head_true,
                                  name="num_cl") as num_cl:
                data_offset_cur = data_offset + num_cl*row_len
                ub_offset_cur = num_cl*param.get("cp_align_len")
                tvm_ib.emit(
                    tvm.call_extern(
                        data_ub.dtype, "copy_gm_to_ubuf",
                        data_ub.access_ptr(
                            "w", offset=ub_offset_cur),
                        data.access_ptr(
                            'r', offset=data_offset_cur),
                        0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            n_burst = num_col_len_head_true
            src_stride = row_len // param.get("cp_align_len") - 1
            args = tvm_ib, param, data, data_ub, data_offset, 0,\
                   reg_addr[1], 1, src_stride, 0
            _func_gm_to_ub(args)
        # move data from data_ub to data_res
        row_end = tvm.min((num_dim_before_cur_two + 1)
                          * param.get("cp_align_len"), row_len)
        row_true = row_end - (num_dim_before_cur_two
                              * param.get("cp_align_len"))
        reg_addr[9] = row_true
        with tvm_ib.for_range(0, row_true, name="num_r") as num_r:
            args = tvm_ib, param, data_ub, data_res, reg, reg_addr, \
                   param.get("cp_align_len"), num_r, reg_addr[1],\
                   num_col_len_head_align
            _reg_mov_batch_split_10_tail_col(args)
        # move data from data_res to dst
        dst_offset = num_two_dim_before_core * two_dim_ele\
                     + num_dim_before_cur_two * param.get("cp_align_len")\
                     * col_len\
                     + num_col_len_cur_dim_before
        with tvm_ib.if_scope(col_len % param.get("cp_align_len") > 0):
            with tvm_ib.if_scope(num_col_len_head_true
                                 > param.get("cp_align_len")):
                col_len_head_align = num_col_len_head_true\
                                     - param.get("cp_align_len")
                reg_addr[6] = col_len_head_align
                burst_len_align = _ceil_div(col_len_head_align,
                                            param.get("cp_align_len"))
                with tvm_ib.for_range(0, row_true, name="num_r") as num_r:
                    dst_offset_cur = dst_offset + num_r*col_len
                    res_offset_cur = num_r*num_col_len_head_align
                    tvm_ib.emit(
                        tvm.call_extern(
                            dst.dtype, "copy_ubuf_to_gm",
                            dst.access_ptr(
                                'w', offset=dst_offset_cur),
                            data_res.access_ptr(
                                "r", offset=res_offset_cur),
                            0, 1, burst_len_align, 0, 0))
                    ele_len = res_offset_cur + reg_addr[6]
                    args = tvm_ib, param, data_res, data_align, reg, reg_addr,\
                           ele_len, param.get("cp_align_len")
                    _reg_mov_batch_two_10_align(args)
                    tvm_ib.emit(
                        tvm.call_extern(
                            dst.dtype, "copy_ubuf_to_gm",
                            dst.access_ptr(
                                'w', offset=dst_offset_cur + reg_addr[6]),
                            data_align.access_ptr(
                                "r", offset=0),
                            0, 1, 1, 0, 0))
            with tvm_ib.else_scope():
                num_ele_align = param.get("cp_align_len")\
                                - num_col_len_head_true
                row_now_align = (num_dim_before_cur_two + 1)\
                                * param.get("cp_align_len")
                reg_addr[8] = num_ele_align

                with tvm_ib.if_scope(row_now_align < row_len_align):
                    with tvm_ib.for_range(0, row_true, name="num_r") as num_r:
                        data_offset_align = num_two_dim_before_core\
                                            * two_dim_ele\
                                            + num_dim_before_cur_two\
                                            * param.get("cp_align_len")\
                                            + num_r + 1
                        with tvm_ib.if_scope(
                            row_len % param.get("cp_align_len") > 0):
                            with tvm_ib.for_range(0, num_ele_align,
                                                  name="num_e") as num_e:
                                tail_offset_cur = num_e * param.get(
                                    "cp_align_len")
                                data_offset_align_cur = data_offset_align\
                                                        + num_e * row_len
                                tvm_ib.emit(
                                    tvm.call_extern(
                                        data_tail.dtype,
                                        "copy_gm_to_ubuf",
                                        data_tail.access_ptr(
                                            "w",
                                            offset=tail_offset_cur),
                                        data.access_ptr(
                                            'r',
                                            offset=data_offset_align_cur),
                                        0, 1, 1, 0, 0))
                        with tvm_ib.else_scope():
                            n_burst_align = num_ele_align
                            src_stride = row_len // param.get(
                                "cp_align_len") - 1
                            args = tvm_ib, param, data, data_tail,\
                                   data_offset_align, 0, reg_addr[8], 1,\
                                   src_stride, 0
                            _func_gm_to_ub(args)

                        with tvm_ib.for_range(0, num_ele_align,
                                              name="num_ae") as num_ae:
                            tvm_ib.emit(tvm.call_extern(
                                data_tail.dtype, "reg_mov",
                                tvm.call_extern(reg.dtype, "reg",
                                                reg[0]),
                                data_tail.access_ptr(
                                    'r',
                                    offset=(num_ae
                                            * param.get("cp_align_len")))
                            ))
                            tvm_ib.emit(tvm.call_extern(
                                data_res.dtype, "reg_mov",
                                data_res.access_ptr(
                                    'w',
                                    offset=(num_r*num_col_len_head_align
                                            + num_col_len_head_true
                                            + num_ae)),
                                tvm.call_extern(reg.dtype, "reg",
                                                reg[0])
                            ))
                        dst_offset_cur = dst_offset + num_r * col_len
                        res_offset_cur = num_r * num_col_len_head_align
                        tvm_ib.emit(
                            tvm.call_extern(
                                dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr(
                                    'w', offset=dst_offset_cur),
                                data_res.access_ptr(
                                    "r", offset=res_offset_cur),
                                0, 1, 1, 0, 0))
                with tvm_ib.else_scope():
                    with tvm_ib.for_range(0, row_true, name="num_r") as num_r:
                        with tvm_ib.if_scope(num_r < (row_true - 1)):
                            data_offset_align = num_two_dim_before_core\
                                                * two_dim_ele\
                                                + num_dim_before_cur_two\
                                                * param.get("cp_align_len")\
                                                + num_r + 1
                            with tvm_ib.if_scope(row_len
                                                 % param.get("cp_align_len")
                                                 > 0):
                                with tvm_ib.for_range(0, num_ele_align,
                                                      name="num_e") as num_e:
                                    tail_offset_cur = num_e\
                                                      * param.get(
                                                          "cp_align_len")
                                    data_offset_align_cur = data_offset_align\
                                                            + num_e*row_len
                                    tvm_ib.emit(
                                        tvm.call_extern(
                                            data_tail.dtype,
                                            "copy_gm_to_ubuf",
                                            data_tail.access_ptr(
                                                "w",
                                                offset=tail_offset_cur),
                                            data.access_ptr(
                                                'r',
                                                offset=data_offset_align_cur),
                                            0, 1, 1, 0, 0))
                            with tvm_ib.else_scope():
                                n_burst_align = num_ele_align
                                src_stride = row_len // param.get(
                                    "cp_align_len") - 1
                                args = tvm_ib, param, data, data_tail,\
                                       data_offset_align, 0, reg_addr[8], 1,\
                                       src_stride, 0
                                _func_gm_to_ub(args)
                        with tvm_ib.else_scope():
                            data_offset_align = (num_two_dim_before_core + 1)\
                                                * two_dim_ele
                            with tvm_ib.if_scope(
                                row_len % param.get("cp_align_len") > 0):
                                with tvm_ib.for_range(0, num_ele_align,
                                                      name="num_e") as num_e:
                                    tail_offset_cur = num_e * param.get(
                                        "cp_align_len")
                                    data_offset_align_cur = data_offset_align\
                                                            + num_e * row_len
                                    tvm_ib.emit(
                                        tvm.call_extern(
                                            data_tail.dtype,
                                            "copy_gm_to_ubuf",
                                            data_tail.access_ptr(
                                                "w",
                                                offset=tail_offset_cur),
                                            data.access_ptr(
                                                'r',
                                                offset=data_offset_align_cur),
                                            0, 1, 1, 0, 0))
                            with tvm_ib.else_scope():
                                n_burst_align = num_ele_align
                                src_stride = row_len // param.get(
                                    "cp_align_len") - 1
                                args = tvm_ib, param, data, data_tail,\
                                       data_offset_align, 0, reg_addr[8], 1,\
                                       src_stride, 0
                                _func_gm_to_ub(args)
                        with tvm_ib.for_range(0, num_ele_align,
                                              name="num_ae") as num_ae:
                            tvm_ib.emit(tvm.call_extern(
                                data_tail.dtype, "reg_mov",
                                tvm.call_extern(reg.dtype, "reg",
                                                reg[0]),
                                data_tail.access_ptr('r',
                                                     offset=(num_ae * param.get(
                                                         "cp_align_len")))
                            ))
                            tvm_ib.emit(
                                tvm.call_extern(
                                    data_res.dtype, "reg_mov",
                                    data_res.access_ptr(
                                        'w',
                                        offset=(num_r * num_col_len_head_align
                                                + num_col_len_head_true
                                                + num_ae)),
                                    tvm.call_extern(reg.dtype, "reg", reg[0])))
                        dst_offset_cur = dst_offset + num_r * col_len
                        res_offset_cur = num_r * num_col_len_head_align
                        tvm_ib.emit(
                            tvm.call_extern(
                                dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w', offset=dst_offset_cur),
                                data_res.access_ptr("r", offset=res_offset_cur),
                                0, 1, 1, 0, 0))

        with tvm_ib.else_scope():
            n_burst = row_true
            burst_len_dst = reg_addr[1] // param.get("cp_align_len")
            reg_addr[2] = col_len - num_col_len_head_true
            dst_stride = reg_addr[2] // param.get("cp_align_len")
            args = tvm_ib, param, dst, data_res, dst_offset, 0, reg_addr[9], \
                   burst_len_dst, 0, dst_stride
            _func_ub_to_gm(args)

        # move data for tail
        num_col_len_tail = col_len_cur_core - num_col_len_head_align
        with tvm_ib.if_scope(num_col_len_tail > 0):
            num_col_len_before_tail = num_g * param.get("col_len_one_group") \
                                      + param.get("block_index")\
                                      * param.get("col_len_one_core")\
                                      + num_col_len_head_align
            reg_addr[3] = num_col_len_before_tail
            num_col_len_align_two_dim = (row_len_align // param.get(
                "cp_align_len")) * col_len_align
            num_two_dim_before_tail = reg_addr[3] // num_col_len_align_two_dim
            num_col_len_two_dim_tail_before = reg_addr[3]\
                                              % num_col_len_align_two_dim
            num_dim_before_cur_two_tail = num_col_len_two_dim_tail_before\
                                          // col_len_align

            reg_addr[4] = num_col_len_tail
            ub_offset = num_col_len_head_align * param.get("cp_align_len")
            res_offset = num_col_len_head_align * param.get("cp_align_len")

            # move data from gm to ub
            data_offset = num_two_dim_before_tail*two_dim_ele\
                          + num_dim_before_cur_two_tail\
                          * param.get("cp_align_len")
            with tvm_ib.if_scope(row_len % param.get("cp_align_len") > 0):
                with tvm_ib.for_range(0, num_col_len_tail,
                                      name="num_cl") as num_cl:
                    data_offset_cur = data_offset + num_cl * row_len
                    ub_offset_cur = ub_offset + num_cl * param.get(
                        "cp_align_len")
                    tvm_ib.emit(
                        tvm.call_extern(
                            data_ub.dtype, "copy_gm_to_ubuf",
                            data_ub.access_ptr(
                                "w", offset=ub_offset_cur),
                            data.access_ptr(
                                'r', offset=data_offset_cur),
                            0, 1, 1, 0, 0))
            with tvm_ib.else_scope():
                n_burst = num_col_len_tail
                src_stride = row_len // param.get("cp_align_len") - 1
                args = tvm_ib, param, data, data_ub, data_offset, ub_offset,\
                       reg_addr[4], 1, src_stride, 0
                _func_gm_to_ub(args)
            # move data from data_ub to data_res
            row_end = tvm.min(
                (num_dim_before_cur_two_tail + 1) * param.get("cp_align_len"),
                row_len)
            row_true = row_end - (num_dim_before_cur_two_tail
                                  * param.get("cp_align_len"))
            reg_addr[10] = row_true
            with tvm_ib.for_range(0, row_true, name="num_r") as num_r:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr, \
                       ub_offset, res_offset, row_true, num_r, reg_addr[4]
                _reg_mov_batch_large_10_tail_col(args)
            # move data from data_res to dst
            dst_offset = num_two_dim_before_tail * two_dim_ele \
                         + num_dim_before_cur_two_tail\
                         * param.get("cp_align_len") * col_len
            burst_len_dst = reg_addr[4] // param.get("cp_align_len")
            with tvm_ib.if_scope(col_len % param.get("cp_align_len") > 0):
                with tvm_ib.for_range(0, row_true, name="num_r") as num_r:
                    dst_offset_cur = dst_offset + num_r * col_len
                    res_offset_cur = res_offset + num_r * num_col_len_tail
                    tvm_ib.emit(
                        tvm.call_extern(
                            dst.dtype, "copy_ubuf_to_gm",
                            dst.access_ptr(
                                'w', offset=dst_offset_cur),
                            data_res.access_ptr(
                                "r", offset=res_offset_cur),
                            0, 1, burst_len_dst, 0, 0))
            with tvm_ib.else_scope():
                n_burst = row_true
                reg_addr[5] = col_len - num_col_len_tail
                dst_stride = reg_addr[5] // param.get(
                    "cp_align_len")
                args = tvm_ib, param, dst, data_res, dst_offset,\
                       res_offset, reg_addr[10],\
                       burst_len_dst, 0, dst_stride
                _func_ub_to_gm(args)


def _large_two_dim_ir_10(dst, data, core_divide):
    """
    function of making ir node builder for large two dim 10 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_large_two_dim_10(tvm_ib, data.shape,
                                        dst.dtype, core_divide)
    data_ub = _new_alloc(tvm_ib, dst.dtype,
                         param.get("col_len_one_core")
                         * param.get("cp_align_len"),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype,
                          param.get("col_len_one_core")
                          * param.get("cp_align_len"),
                          "data_res", scope=cce.scope_ubuf)
    data_align = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                            "data_align", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype,
                           param.get('cp_align_len')
                           * param.get("cp_align_len"),
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    reg_addr = tvm_ib.allocate("int32", (16,), name='reg_addr',
                               scope=cce.scope_reg)
    with tvm_ib.for_range(0, param.get("num_group_index") + 1,
                          name="num_g") as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_align,\
                   data_tail, reg, reg_addr, num_g,\
                   param.get("col_len_one_core")
            _func_large_two_dim_10(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod") // param.get(
                "col_len_one_core")
            num_col_len_mod = param.get("num_group_mod") % param.get(
                "col_len_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_align, data_tail, reg, \
                           reg_addr, num_g, param.get("col_len_one_core")
                    _func_large_two_dim_10(args)
            with tvm_ib.if_scope(num_col_len_mod > 0):
                with tvm_ib.if_scope(
                    tvm.all(param.get("block_index") < (num_core + 1),
                            param.get("block_index") > (num_core - 1))):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_align, data_tail, reg, \
                           reg_addr, num_g, num_col_len_mod
                    _func_large_two_dim_10(args)

    return tvm_ib.get()


def _reg_mov_batch_small_shape_102(args):
    """
    reg_mov data in ub for small shape 102 scene

    """
    tvm_ib, data_ub, data_res, reg, reg_addr, col_len, row_len,\
    num_c, num_r, ele_len = args

    ele_reg = 4
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3

    tvm_ib.emit(tvm.call_extern(
        data_ub.dtype, "reg_mov",
        tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
        data_ub.access_ptr('r',
                           offset=(num_c * row_len * ele_len
                                   + num_r * ele_len + reg_zero))
    ))
    tvm_ib.emit(tvm.call_extern(
        data_ub.dtype, "reg_mov",
        tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
        data_ub.access_ptr('r',
                           offset=(num_c * row_len * ele_len
                                   + num_r * ele_len + reg_one))
    ))
    tvm_ib.emit(tvm.call_extern(
        data_ub.dtype, "reg_mov",
        tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
        data_ub.access_ptr('r',
                           offset=(num_c * row_len * ele_len
                                   + num_r * ele_len + reg_two))
    ))
    tvm_ib.emit(tvm.call_extern(
        data_ub.dtype, "reg_mov",
        tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
        data_ub.access_ptr('r',
                           offset=(num_c * row_len * ele_len
                                   + num_r * ele_len + reg_three))
    ))

    tvm_ib.emit(tvm.call_extern(
        data_res.dtype, "reg_mov",
        data_res.access_ptr('w',
                            offset=(num_r * col_len * ele_len
                                    + num_c * ele_len + reg_zero)),
        tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
    ))
    tvm_ib.emit(tvm.call_extern(
        data_res.dtype, "reg_mov",
        data_res.access_ptr('w',
                            offset=(num_r * col_len * ele_len
                                    + num_c * ele_len + reg_one)),
        tvm.call_extern(reg.dtype, "reg", reg[reg_one])
    ))
    tvm_ib.emit(tvm.call_extern(
        data_res.dtype, "reg_mov",
        data_res.access_ptr('w',
                            offset=(num_r * col_len * ele_len
                                    + num_c * ele_len + reg_two)),
        tvm.call_extern(reg.dtype, "reg", reg[reg_two])
    ))
    tvm_ib.emit(tvm.call_extern(
        data_res.dtype, "reg_mov",
        data_res.access_ptr('w',
                            offset=(num_r * col_len * ele_len
                                    + num_c * ele_len + reg_three)),
        tvm.call_extern(reg.dtype, "reg", reg[reg_three])
    ))


def _small_shape_ir_102(dst, data):
    """
    function of making ir node builder for small shape 102 scene

    """
    tvm_ib = tvm.ir_builder.create()
    ub_bytes = UB_SIZE_B - 32
    ub_half = ub_bytes // 2
    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = ub_half // float_size
    src_shape = data.shape
    shape_ele = functools_reduce(lambda x, y: x*y, src_shape[:])
    col_len, row_len, ele_len = data.shape
    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    reg_addr = tvm_ib.allocate("int32", (8,), name='reg_addr',
                               scope=cce.scope_reg)

    burst_len = _ceil_div(shape_ele, cp_align_len)
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w",
                                                   offset=0),
                                data.access_ptr('r',
                                                offset=0),
                                0, 1, burst_len, 0, 0))

    with tvm_ib.if_scope(ele_len == 4):
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                args = tvm_ib, data_ub, data_res, reg, reg_addr, col_len,\
                       row_len, num_c, num_r, ele_len
                _reg_mov_batch_small_shape_102(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                with tvm_ib.for_range(0, ele_len, name="num_e") as num_e:
                    tvm_ib.emit(tvm.call_extern(
                        data_ub.dtype, "reg_mov",
                        tvm.call_extern(reg.dtype, "reg", reg[0]),
                        data_ub.access_ptr('r',
                                           offset=(num_c*row_len*ele_len
                                                   + num_r*ele_len + num_e))
                    ))
                    tvm_ib.emit(tvm.call_extern(
                        data_res.dtype, "reg_mov",
                        data_res.access_ptr(
                            'w',
                            offset=(num_r*col_len*ele_len
                                    + num_c*ele_len + num_e)),
                        tvm.call_extern(reg.dtype, "reg", reg[0])
                    ))
    tvm_ib.emit(
        tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                        dst.access_ptr('w',
                                       offset=0),
                        data_res.access_ptr("r",
                                            offset=0),
                        0, 1, burst_len, 0, 0))

    return tvm_ib.get()


def _vconv_for_fp32_0312_one(args):
    """
    function of vnchwconv for 0312 float32 special one scene

    """
    tvm_ib, addr_array, addr_array_buf, one_begin, two_begin,\
    repeat_vconv, src_stride_vconv, dst_stride_vconv, c_sub_align_div = args

    src0_offset = 8*0
    src1_offset = 8*1
    dst0_offset = 8*2
    dst1_offset = 8*3
    src_gap = 32*16*c_sub_align_div
    src_eight_gap = src_gap*8
    dst_gap = 32
    dst_eight_gap = dst_gap*8

    with tvm_ib.for_range(0, 8, name="i") as i:
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src0_offset + i]),
                                    one_begin + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src1_offset + i]),
                                    one_begin + src_eight_gap
                                    + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst0_offset + i]),
                                    two_begin + i * dst_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst1_offset + i]),
                                    two_begin + dst_eight_gap
                                    + i * dst_gap))

    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA0",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA1",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src1_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA2",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA3",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst1_offset)))

    tvm_ib.emit(tvm.call_extern("int32",
                                "scatter_vnchwconv_b16",
                                "VA2",
                                "VA0",
                                repeat_vconv,
                                dst_stride_vconv,
                                src_stride_vconv))


def _vconv_for_fp32_0312_two(args):
    """
    function of vnchwconv for 0312 float32 special two scene

    """
    tvm_ib, addr_array, addr_array_buf, one_begin, two_begin,\
    repeat_vconv, src_stride_vconv, dst_stride_vconv = args

    src0_offset = 8*0
    src1_offset = 8*1
    dst0_offset = 8*2
    dst1_offset = 8*3
    src_gap = 32
    src_eight_gap = src_gap*8
    dst_gap = 64
    dst_eight_gap = dst_gap*8

    with tvm_ib.for_range(0, 8, name="i") as i:
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src0_offset + i]),
                                    one_begin + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src1_offset + i]),
                                    one_begin + src_eight_gap
                                    + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst0_offset + i]),
                                    two_begin + i * dst_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst1_offset + i]),
                                    two_begin + dst_eight_gap
                                    + i * dst_gap))

    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA0",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA1",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src1_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA2",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA3",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst1_offset)))

    tvm_ib.emit(tvm.call_extern("int32",
                                "scatter_vnchwconv_b16",
                                "VA2",
                                "VA0",
                                repeat_vconv,
                                dst_stride_vconv,
                                src_stride_vconv))


def _mov_0312_256_vconv_fp32(dst, data, row_zu):
    """
    function of making ir node builder for 0312 float32 special scene

    """
    tvm_ib = tvm.ir_builder.create()
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 32
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_one = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_one", scope=cce.scope_ubuf)
    data_two = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_two", scope=cce.scope_ubuf)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i, h_i, w_i, c_i = data.shape

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)
    num_block_one_dim = device_core_num // n_i
    num_dim = block_index // num_block_one_dim
    num_block = block_index % num_block_one_dim
    col_len_block = h_i*w_i // num_block_one_dim

    c_sub_align = _ceil_fill(c_i, cp_align_len)
    c_sub_align_div = _ceil_div(c_i, cp_align_len)
    vconv_col_group = c_sub_align // cp_align_len
    ele_256_ub = 256*c_sub_align
    num_256_ub = ub_ele // ele_256_ub
    num_256_shape = h_i * w_i // 256 // num_block_one_dim
    ub_loop = num_256_shape // num_256_ub
    num_256_mod = num_256_shape % num_256_ub

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        col_group = num_256_ub*256 // row_zu
        vconv_group = num_256_ub

        for num_rz in range(row_zu):
            data_offset = num_dim*h_i*w_i*c_i + num_block*col_len_block*c_i\
                          + num_u*num_256_ub*256*c_i + num_rz * c_i
            ub_offset = num_rz * c_sub_align
            n_burst = col_group
            burst_len_data = c_sub_align // cp_align_len
            src_stride = (row_zu * c_i - c_sub_align) // cp_align_len
            dst_stride = (row_zu - 1) * c_sub_align // cp_align_len
            args = tvm_ib, data, data_one, data_offset, ub_offset, n_burst, \
                   burst_len_data, src_stride, dst_stride, cp_align_len
            _func_gm_to_ub_align(args)

        with tvm_ib.for_range(0, vconv_col_group, name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                one_begin = (num_vg * 256 * c_sub_align + num_vc * 8)\
                            * float_size
                two_begin = (ub_ele + num_vc * vconv_group * 256 * cp_align_len
                             + num_vg * 256 * cp_align_len) * float_size
                repeat_vconv = 16
                src_stride_vconv = c_sub_align_div
                dst_stride_vconv = 16
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin,\
                       repeat_vconv, src_stride_vconv, dst_stride_vconv,\
                       c_sub_align_div
                _vconv_for_fp32_0312_one(args)

        with tvm_ib.for_range(0, vconv_col_group, name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                for num_c in range(8):
                    two_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 256 * cp_align_len + num_c * 8 * 2
                    one_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 32 * cp_align_len\
                                 + num_c * 8 * 32 * vconv_group
                    n_burst = 16
                    burst_len = 2
                    src_stride = 14
                    tvm_ib.emit(
                        tvm.call_extern(data_one.dtype, "copy_ubuf_to_ubuf",
                                        data_one.access_ptr("w",
                                                            offset=one_offset),
                                        data_two.access_ptr('r',
                                                            offset=two_offset),
                                        0, n_burst, burst_len, src_stride, 0))

        with tvm_ib.for_range(0, 2, name="num_h") as num_h:
            one_begin = (num_h * 8 * 16) * float_size
            two_begin = (ub_ele + num_h * 8) * float_size
            repeat_vconv = 8 * vconv_group * vconv_col_group
            src_stride_vconv = 32
            dst_stride_vconv = 32
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_for_fp32_0312_two(args)

        dst_offset = num_dim*h_i*w_i*c_i + num_block*col_len_block\
                     + num_u*num_256_ub*256
        n_burst_dst = c_i
        burst_len_dst = num_256_ub*256 // cp_align_len
        dst_stride = (h_i*w_i - num_256_ub*256) // cp_align_len
        args = tvm_ib, dst, data_two, dst_offset, 0, n_burst_dst,\
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)

    with tvm_ib.if_scope(num_256_mod > 0):
        col_group = num_256_mod * 256 // row_zu
        vconv_group = num_256_mod

        for num_rz in range(row_zu):
            data_offset = num_dim*h_i*w_i*c_i + num_block*col_len_block*c_i\
                          + ub_loop * num_256_ub * 256 * c_i + num_rz * c_i
            ub_offset = num_rz * c_sub_align
            n_burst = col_group
            burst_len_data = c_sub_align // cp_align_len
            src_stride = (row_zu * c_i - c_sub_align) // cp_align_len
            dst_stride = (row_zu - 1) * c_sub_align // cp_align_len
            args = tvm_ib, data, data_one, data_offset, ub_offset, n_burst, \
                   burst_len_data, src_stride, dst_stride, cp_align_len
            _func_gm_to_ub_align(args)

        with tvm_ib.for_range(0, vconv_col_group, name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                one_begin = (num_vg * 256 * c_sub_align + num_vc * 8)\
                            * float_size
                two_begin = (ub_ele + num_vc * vconv_group * 256 * cp_align_len
                             + num_vg * 256 * cp_align_len) * float_size
                repeat_vconv = 16
                src_stride_vconv = c_sub_align_div
                dst_stride_vconv = 16
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin,\
                       repeat_vconv, src_stride_vconv, dst_stride_vconv,\
                       c_sub_align_div
                _vconv_for_fp32_0312_one(args)

        with tvm_ib.for_range(0, vconv_col_group, name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                for num_c in range(8):
                    two_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 256 * cp_align_len + num_c * 8 * 2
                    one_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 32 * cp_align_len\
                                 + num_c * 8 * 32 * vconv_group
                    n_burst = 16
                    burst_len = 2
                    src_stride = 14
                    tvm_ib.emit(
                        tvm.call_extern(data_one.dtype, "copy_ubuf_to_ubuf",
                                        data_one.access_ptr("w",
                                                            offset=one_offset),
                                        data_two.access_ptr('r',
                                                            offset=two_offset),
                                        0, n_burst, burst_len, src_stride, 0))

        with tvm_ib.for_range(0, 2, name="num_h") as num_h:
            one_begin = (num_h * 8 * 16) * float_size
            two_begin = (ub_ele + num_h * 8) * float_size
            repeat_vconv = 8 * vconv_group * vconv_col_group
            src_stride_vconv = 32
            dst_stride_vconv = 32
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_for_fp32_0312_two(args)

        dst_offset = num_dim*h_i*w_i*c_i + num_block*col_len_block\
                     + ub_loop * num_256_ub * 256
        n_burst_dst = c_i
        burst_len_dst = num_256_mod * 256 // cp_align_len
        dst_stride = (h_i * w_i - num_256_mod * 256) // cp_align_len
        args = tvm_ib, dst, data_two, dst_offset, 0, n_burst_dst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)

    return tvm_ib.get()


def _vconv_for_fp32_0231_two(args):
    """
    function of vnchwconv for 0231 float32 special two scene

    """
    tvm_ib, addr_array, addr_array_buf, one_begin, two_begin,\
    repeat_vconv, src_stride_vconv, dst_stride_vconv = args

    src0_offset = 8*0
    src1_offset = 8*1
    dst0_offset = 8*2
    dst1_offset = 8*3
    src_gap = 64
    src_eight_gap = src_gap*8
    dst_gap = 32
    dst_eight_gap = dst_gap*8

    with tvm_ib.for_range(0, 8, name="i") as i:
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src0_offset + i]),
                                    one_begin + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src1_offset + i]),
                                    one_begin + src_eight_gap
                                    + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst0_offset + i]),
                                    two_begin + i * dst_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst1_offset + i]),
                                    two_begin + dst_eight_gap
                                    + i * dst_gap))

    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA0",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA1",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src1_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA2",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA3",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst1_offset)))

    tvm_ib.emit(tvm.call_extern("int32",
                                "scatter_vnchwconv_b16",
                                "VA2",
                                "VA0",
                                repeat_vconv,
                                dst_stride_vconv,
                                src_stride_vconv))


def _vconv_for_fp32_0231_one(args):
    """
    function of vnchwconv for 0231 float32 special one scene

    """
    tvm_ib, addr_array, addr_array_buf, one_begin, two_begin,\
    repeat_vconv, src_stride_vconv, dst_stride_vconv, c_sub_align_div = args

    src0_offset = 8*0
    src1_offset = 8*1
    dst0_offset = 8*2
    dst1_offset = 8*3
    src_gap = 32
    src_eight_gap = src_gap*8
    dst_gap = 32*16*c_sub_align_div
    dst_eight_gap = dst_gap*8

    with tvm_ib.for_range(0, 8, name="i") as i:
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src0_offset + i]),
                                    one_begin + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src1_offset + i]),
                                    one_begin + src_eight_gap
                                    + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst0_offset + i]),
                                    two_begin + i * dst_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst1_offset + i]),
                                    two_begin + dst_eight_gap
                                    + i * dst_gap))

    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA0",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA1",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src1_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA2",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA3",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst1_offset)))

    tvm_ib.emit(tvm.call_extern("int32",
                                "scatter_vnchwconv_b16",
                                "VA2",
                                "VA0",
                                repeat_vconv,
                                dst_stride_vconv,
                                src_stride_vconv))


def _mov_0231_256_vconv_fp32(dst, data, row_zu):
    """
    function of making ir node builder for 0231 float32 special scene

    """
    tvm_ib = tvm.ir_builder.create()
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 32
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_one = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_one", scope=cce.scope_ubuf)
    data_two = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_two", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i, c_i, h_i, w_i = data.shape

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)
    num_block_one_dim = device_core_num // n_i
    num_dim = block_index // num_block_one_dim
    num_block = block_index % num_block_one_dim
    col_len_block = h_i*w_i // num_block_one_dim

    c_small = (c_i // cp_align_len)*cp_align_len
    c_sub_align = _ceil_fill(c_small, cp_align_len)
    c_sub_align_div = _ceil_div(c_small, cp_align_len)
    vconv_col_group = c_sub_align // cp_align_len
    ele_256_ub = 256*c_sub_align
    num_256_ub = ub_ele // ele_256_ub
    num_256_shape = h_i * w_i // 256 // num_block_one_dim
    ub_loop = num_256_shape // num_256_ub
    num_256_mod = num_256_shape % num_256_ub

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        col_group = num_256_ub * 256 // row_zu
        vconv_group = num_256_ub

        data_offset = num_dim * h_i * w_i * c_i + num_block * col_len_block\
                      + num_u * num_256_ub * 256
        n_burst_data = c_small
        burst_len_data = num_256_ub*256 // cp_align_len
        src_stride = (h_i*w_i - num_256_ub*256) // cp_align_len
        args = tvm_ib, data, data_one, data_offset, 0, n_burst_data, \
               burst_len_data, src_stride, 0, cp_align_len
        _func_gm_to_ub_align(args)

        with tvm_ib.for_range(0, 2, name="num_h") as num_h:
            one_begin = (num_h * 8) * float_size
            two_begin = (ub_ele + num_h * 8 * 16) * float_size
            repeat_vconv = 8 * vconv_group * vconv_col_group
            src_stride_vconv = 32
            dst_stride_vconv = 32
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_for_fp32_0231_two(args)

        with tvm_ib.for_range(0, vconv_col_group, name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                for num_c in range(8):
                    two_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 32 * cp_align_len\
                                 + num_c * 8 * 32 * vconv_group
                    one_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 256 * cp_align_len + num_c * 8 * 2
                    n_burst = 16
                    burst_len = 2
                    dst_stride = 14
                    tvm_ib.emit(
                        tvm.call_extern(data_one.dtype, "copy_ubuf_to_ubuf",
                                        data_one.access_ptr("w",
                                                            offset=one_offset),
                                        data_two.access_ptr('r',
                                                            offset=two_offset),
                                        0, n_burst, burst_len, 0, dst_stride))

        with tvm_ib.for_range(0, vconv_col_group, name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                one_begin = (num_vc * vconv_group * 256 * cp_align_len
                             + num_vg * 256 * cp_align_len) * float_size
                two_begin = (ub_ele + num_vg * 256 * c_sub_align + num_vc * 8)\
                            * float_size
                repeat_vconv = 16
                src_stride_vconv = 16
                dst_stride_vconv = c_sub_align_div
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin,\
                       repeat_vconv, src_stride_vconv, dst_stride_vconv,\
                       c_sub_align_div
                _vconv_for_fp32_0231_one(args)

        for num_rz in range(row_zu):
            dst_offset = num_dim * h_i * w_i * c_i\
                         + num_block * col_len_block * c_i \
                         + num_u * num_256_ub * 256 * c_i + num_rz * c_i
            res_offset = num_rz * c_sub_align
            n_burst = col_group
            burst_len_dst = c_sub_align // cp_align_len
            src_stride = (row_zu - 1) * c_sub_align // cp_align_len
            dst_stride = (row_zu * c_i - c_sub_align) // cp_align_len
            args = tvm_ib, dst, data_two, dst_offset, res_offset, n_burst,\
                   burst_len_dst, src_stride, dst_stride, cp_align_len
            _func_ub_to_gm_align(args)

        # move data for after cp_align_len
        c_align = c_i - cp_align_len
        vconv_col_group_align = 1
        c_sub_align_div_align = 1
        c_sub_align_align = 8
        data_offset = num_dim * h_i * w_i * c_i + num_block * col_len_block\
                      + num_u * num_256_ub * 256 + c_align*h_i*w_i
        n_burst_data = cp_align_len
        burst_len_data = num_256_ub * 256 // cp_align_len
        src_stride = (h_i * w_i - num_256_ub * 256) // cp_align_len
        args = tvm_ib, data, data_one, data_offset, 0, n_burst_data,\
               burst_len_data, src_stride, 0, cp_align_len
        _func_gm_to_ub_align(args)

        with tvm_ib.for_range(0, 2, name="num_h") as num_h:
            one_begin = (num_h * 8) * float_size
            two_begin = (ub_ele + num_h * 8 * 16) * float_size
            repeat_vconv = 8 * vconv_group * vconv_col_group_align
            src_stride_vconv = 32
            dst_stride_vconv = 32
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin,\
                   repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_for_fp32_0231_two(args)

        with tvm_ib.for_range(0, vconv_col_group_align, name="num_vc")\
                as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                for num_c in range(8):
                    two_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 32 * cp_align_len\
                                 + num_c * 8 * 32 * vconv_group
                    one_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 256 * cp_align_len + num_c * 8 * 2
                    n_burst = 16
                    burst_len = 2
                    dst_stride = 14
                    tvm_ib.emit(
                        tvm.call_extern(data_one.dtype, "copy_ubuf_to_ubuf",
                                        data_one.access_ptr("w",
                                                            offset=one_offset),
                                        data_two.access_ptr('r',
                                                            offset=two_offset),
                                        0, n_burst, burst_len, 0, dst_stride))

        with tvm_ib.for_range(0, vconv_col_group_align, name="num_vc")\
                as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                one_begin = (num_vc * vconv_group * 256 * cp_align_len
                             + num_vg * 256 * cp_align_len) * float_size
                two_begin = (ub_ele + num_vg * 256 * c_sub_align_align
                             + num_vc * 8) * float_size
                repeat_vconv = 16
                src_stride_vconv = 16
                dst_stride_vconv = c_sub_align_div_align
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin,\
                       repeat_vconv, src_stride_vconv, dst_stride_vconv,\
                       c_sub_align_div_align
                _vconv_for_fp32_0231_one(args)

        for num_rz in range(row_zu):
            dst_offset = num_dim * h_i * w_i * c_i\
                         + num_block * col_len_block * c_i \
                         + num_u * num_256_ub * 256 * c_i\
                         + num_rz * c_i + c_align
            res_offset = num_rz * c_sub_align_align
            n_burst = col_group
            burst_len_dst = c_sub_align_align // cp_align_len
            src_stride = (row_zu - 1) * c_sub_align_align // cp_align_len
            dst_stride = (row_zu * c_i - c_sub_align_align) // cp_align_len
            args = tvm_ib, dst, data_two, dst_offset, res_offset, n_burst, \
                   burst_len_dst, src_stride, dst_stride, cp_align_len
            _func_ub_to_gm_align(args)

    with tvm_ib.if_scope(num_256_mod > 0):
        col_group = num_256_mod * 256 // row_zu
        vconv_group = num_256_mod

        data_offset = num_dim * h_i * w_i * c_i + num_block * col_len_block\
                      + ub_loop * num_256_ub * 256
        n_burst_data = c_small
        burst_len_data = num_256_mod * 256 // cp_align_len
        src_stride = (h_i * w_i - num_256_mod * 256) // cp_align_len
        args = tvm_ib, data, data_one, data_offset, 0, n_burst_data, \
               burst_len_data, src_stride, 0, cp_align_len
        _func_gm_to_ub_align(args)

        with tvm_ib.for_range(0, 2, name="num_h") as num_h:
            one_begin = (num_h * 8) * float_size
            two_begin = (ub_ele + num_h * 8 * 16) * float_size
            repeat_vconv = 8 * vconv_group * vconv_col_group
            src_stride_vconv = 32
            dst_stride_vconv = 32
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_for_fp32_0231_two(args)

        with tvm_ib.for_range(0, vconv_col_group, name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                for num_c in range(8):
                    two_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 32 * cp_align_len\
                                 + num_c * 8 * 32 * vconv_group
                    one_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 256 * cp_align_len + num_c * 8 * 2
                    n_burst = 16
                    burst_len = 2
                    dst_stride = 14
                    tvm_ib.emit(
                        tvm.call_extern(data_one.dtype, "copy_ubuf_to_ubuf",
                                        data_one.access_ptr("w",
                                                            offset=one_offset),
                                        data_two.access_ptr('r',
                                                            offset=two_offset),
                                        0, n_burst, burst_len, 0, dst_stride))

        with tvm_ib.for_range(0, vconv_col_group, name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                one_begin = (num_vc * vconv_group * 256 * cp_align_len
                             + num_vg * 256 * cp_align_len) * float_size
                two_begin = (ub_ele + num_vg * 256 * c_sub_align + num_vc * 8)\
                            * float_size
                repeat_vconv = 16
                src_stride_vconv = 16
                dst_stride_vconv = c_sub_align_div
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin,\
                       repeat_vconv, src_stride_vconv, dst_stride_vconv,\
                       c_sub_align_div
                _vconv_for_fp32_0231_one(args)

        for num_rz in range(row_zu):
            dst_offset = num_dim * h_i * w_i * c_i\
                         + num_block * col_len_block * c_i\
                         + ub_loop * num_256_ub * 256 * c_i + num_rz * c_i
            res_offset = num_rz * c_sub_align
            n_burst = col_group
            burst_len_dst = c_sub_align // cp_align_len
            src_stride = (row_zu - 1) * c_sub_align // cp_align_len
            dst_stride = (row_zu * c_i - c_sub_align) // cp_align_len
            args = tvm_ib, dst, data_two, dst_offset, res_offset, n_burst,\
                   burst_len_dst, src_stride, dst_stride, cp_align_len
            _func_ub_to_gm_align(args)

        # move data for after cp_align_len
        c_align = c_i - cp_align_len
        vconv_col_group_align = 1
        c_sub_align_div_align = 1
        c_sub_align_align = 8
        data_offset = num_dim * h_i * w_i * c_i + num_block * col_len_block\
                      + ub_loop * num_256_ub * 256 + c_align * h_i * w_i
        n_burst_data = cp_align_len
        burst_len_data = num_256_mod * 256 // cp_align_len
        src_stride = (h_i * w_i - num_256_mod * 256) // cp_align_len
        args = tvm_ib, data, data_one, data_offset, 0, n_burst_data, \
                   burst_len_data, src_stride, 0, cp_align_len
        _func_gm_to_ub_align(args)

        with tvm_ib.for_range(0, 2, name="num_h") as num_h:
            one_begin = (num_h * 8) * float_size
            two_begin = (ub_ele + num_h * 8 * 16) * float_size
            repeat_vconv = 8 * vconv_group * vconv_col_group_align
            src_stride_vconv = 32
            dst_stride_vconv = 32
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin,\
                       repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_for_fp32_0231_two(args)

        with tvm_ib.for_range(0, vconv_col_group_align,
                              name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                for num_c in range(8):
                    two_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 32 * cp_align_len\
                                 + num_c * 8 * 32 * vconv_group
                    one_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 256 * cp_align_len + num_c * 8 * 2
                    n_burst = 16
                    burst_len = 2
                    dst_stride = 14
                    tvm_ib.emit(
                        tvm.call_extern(data_one.dtype, "copy_ubuf_to_ubuf",
                                        data_one.access_ptr("w",
                                                            offset=one_offset),
                                        data_two.access_ptr('r',
                                                            offset=two_offset),
                                        0, n_burst, burst_len, 0,
                                        dst_stride))

        with tvm_ib.for_range(0, vconv_col_group_align,
                              name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                one_begin = (num_vc * vconv_group * 256 * cp_align_len
                             + num_vg * 256 * cp_align_len) * float_size
                two_begin = (ub_ele + num_vg * 256 * c_sub_align_align
                             + num_vc * 8) * float_size
                repeat_vconv = 16
                src_stride_vconv = 16
                dst_stride_vconv = c_sub_align_div_align
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin,\
                           repeat_vconv, src_stride_vconv, dst_stride_vconv,\
                       c_sub_align_div_align
                _vconv_for_fp32_0231_one(args)

        for num_rz in range(row_zu):
            dst_offset = num_dim * h_i * w_i * c_i\
                         + num_block * col_len_block * c_i \
                         + ub_loop * num_256_ub * 256 * c_i\
                         + num_rz * c_i + c_align
            res_offset = num_rz * c_sub_align_align
            n_burst = col_group
            burst_len_dst = c_sub_align_align // cp_align_len
            src_stride = (row_zu - 1) * c_sub_align_align // cp_align_len
            dst_stride = (row_zu * c_i - c_sub_align_align) // cp_align_len
            args = tvm_ib, dst, data_two, dst_offset, res_offset, n_burst, \
                       burst_len_dst, src_stride, dst_stride, cp_align_len
            _func_ub_to_gm_align(args)

    return tvm_ib.get()


def _vconv_one(args):
    """
    function of vnchwconv for _func_vconv_fp16

    """
    tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
    repeat_vconv, src_stride_vconv, dst_stride_vconv, r_zu, c_zu = args

    src0_offset = 8 * 0
    src1_offset = 8 * 1
    dst0_offset = 8 * 2
    dst1_offset = 8 * 3
    src_gap = 32 * r_zu
    src_eight_gap = src_gap * 8
    dst_gap = 32 * c_zu
    dst_eight_gap = dst_gap * 8

    with tvm_ib.for_range(0, 8, name="i") as i:
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src0_offset + i]),
                                    one_begin + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src1_offset + i]),
                                    one_begin + src_eight_gap
                                    + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst0_offset + i]),
                                    two_begin + i * dst_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst1_offset + i]),
                                    two_begin + dst_eight_gap
                                    + i * dst_gap))

    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA0",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA1",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src1_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA2",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA3",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst1_offset)))
    with tvm_ib.if_scope(repeat_vconv == 1):
        tvm_ib.emit(tvm.call_extern("int32",
                                    "scatter_vnchwconv_b16",
                                    "VA2",
                                    "VA0",
                                    1,
                                    0,
                                    0))
    with tvm_ib.else_scope():
        tvm_ib.emit(tvm.call_extern("int32",
                                    "scatter_vnchwconv_b16",
                                    "VA2",
                                    "VA0",
                                    repeat_vconv,
                                    dst_stride_vconv,
                                    src_stride_vconv))


def _func_two_permute_align_small_fp16(args):
    """
    function of moving data for two permute align small fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    n_index = num_g * device_core_num + block_index
    data_offset = n_index * col_len * row_len
    burst_len_data = col_len * row_len // cp_align_len
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    c_zu = col_len // 16
    r_zu = row_len // 16
    with tvm_ib.if_scope(row_len >= col_len):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    dst_offset = n_index * col_len * row_len
    burst_len_dst = col_len * row_len // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, 1, burst_len_dst, 0, 0))


def _two_permute_align_small_fp16(dst, data):
    """
    function of making ir node builder for permute align small fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_permute_align_small_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_permute_align_small_fp16(args)

    return tvm_ib.get()


def _func_two_permute_align_split_row_fp16(args):
    """
    function of moving data for two permute align split row fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    row_len_ub = (ub_ele // col_len // cp_align_len) * cp_align_len
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    n_index = num_g * device_core_num + block_index

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:

        data_offset = n_index * col_len * row_len + num_u * row_len_ub
        n_burst = col_len
        burst_len_data = row_len_ub // cp_align_len
        src_stride = (row_len - row_len_ub) // cp_align_len
        args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
               burst_len_data, src_stride, 0, cp_align_len
        _func_gm_to_ub_align(args)

        c_zu = col_len // 16
        r_zu = row_len_ub // 16
        with tvm_ib.if_scope(row_len_ub >= col_len):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len_ub * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        dst_offset = n_index * col_len * row_len + num_u * col_len * row_len_ub
        burst_len_dst = (col_len * row_len_ub) // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))
    with tvm_ib.if_scope(ub_mod > 0):
        data_offset = n_index * col_len * row_len + ub_loop * row_len_ub
        n_burst = col_len
        burst_len_data = ub_mod // cp_align_len
        src_stride = (row_len - ub_mod) // cp_align_len
        args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
               burst_len_data, src_stride, 0, cp_align_len
        _func_gm_to_ub_align(args)

        c_zu = col_len // 16
        r_zu = ub_mod // 16
        with tvm_ib.if_scope(ub_mod >= col_len):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * ub_mod * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        dst_offset = n_index * col_len * row_len\
                     + ub_loop * col_len * row_len_ub
        burst_len_dst = (col_len * ub_mod) // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _two_permute_align_split_row_fp16(dst, data):
    """
    function of making ir node builder for permute align split row fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_permute_align_split_row_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_permute_align_split_row_fp16(args)

    return tvm_ib.get()


def _move_for_permute_split_row_fp16_fencore(args):
    """
    function of moving data for two permute align split row fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    float_size, cp_align_len, ub_ele, n_index, col_len,\
    row_len, row_len_begin, row_len_now = args

    data_offset = n_index * col_len * row_len + row_len_begin
    n_burst = col_len
    burst_len_data = row_len_now // cp_align_len
    src_stride = (row_len - row_len_now) // cp_align_len
    args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
           burst_len_data, src_stride, 0, cp_align_len
    _func_gm_to_ub_align(args)

    c_zu = col_len // 16
    r_zu = row_len_now // 16
    with tvm_ib.if_scope(row_len_now >= col_len):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len_now * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    dst_offset = n_index * col_len * row_len + col_len * row_len_begin
    burst_len_dst = (col_len * row_len_now) // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, 1, burst_len_dst, 0, 0))


def _func_two_permute_align_split_row_fp16_fencore_nomod(args):
    """
    function of two permute align split row fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    row_len_now = row_len_ub
    row_len_begin = fen_index * row_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
           col_len, row_len, row_len_begin, row_len_now
    _move_for_permute_split_row_fp16_fencore(args)


def _func_two_permute_align_split_row_fp16_fencore_mod(args):
    """
    function of two permute align split row fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        row_len_now = row_len_ub
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index,\
               col_len, row_len, row_len_begin, row_len_now
        _move_for_permute_split_row_fp16_fencore(args)
    with tvm_ib.else_scope():
        row_len_now = ub_mod
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
               col_len, row_len, row_len_begin, row_len_now
        _move_for_permute_split_row_fp16_fencore(args)


def _two_permute_align_split_row_fp16_fencore(dst, data):
    """
    function of making ir node builder
    for permute align split row fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    row_len_ub = (ub_ele // col_len // cp_align_len) * cp_align_len
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_permute_align_split_row_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_permute_align_split_row_fp16_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_permute_align_split_row_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_permute_align_split_row_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_permute_align_split_col_fp16(args):
    """
    function of moving data for permute align split col fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    col_len_ub = (ub_ele // row_len // cp_align_len) * cp_align_len
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    n_index = num_g * device_core_num + block_index

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:

        data_offset = n_index * col_len * row_len\
                      + num_u * col_len_ub * row_len
        burst_len_data = (col_len_ub * row_len) // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        c_zu = col_len_ub // 16
        r_zu = row_len // 16
        with tvm_ib.if_scope(row_len >= col_len_ub):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len_ub * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        dst_offset = n_index * col_len * row_len + num_u * col_len_ub
        n_burst = row_len
        burst_len_dst = col_len_ub // cp_align_len
        dst_stride = (col_len - col_len_ub) // cp_align_len
        args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)

    with tvm_ib.if_scope(ub_mod > 0):
        data_offset = n_index * col_len * row_len\
                      + ub_loop * col_len_ub * row_len
        burst_len_data = (ub_mod * row_len) // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        c_zu = ub_mod // 16
        r_zu = row_len // 16
        with tvm_ib.if_scope(row_len >= ub_mod):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_mod * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        dst_offset = n_index * col_len * row_len + ub_loop * col_len_ub
        n_burst = row_len
        burst_len_dst = ub_mod // cp_align_len
        dst_stride = (col_len - ub_mod) // cp_align_len
        args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)


def _two_permute_align_split_col_fp16(dst, data):
    """
    function of making ir node builder for permute align split col fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_permute_align_split_col_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_permute_align_split_col_fp16(args)

    return tvm_ib.get()


def _move_for_permute_split_col_fp16_fencore(args):
    """
    function of moving data for permute align split col fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf, \
    float_size, cp_align_len, ub_ele, n_index, col_len, \
    row_len, col_len_begin, col_len_now = args

    data_offset = n_index * col_len * row_len \
                  + col_len_begin * row_len
    burst_len_data = (col_len_now * row_len) // cp_align_len
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    c_zu = col_len_now // 16
    r_zu = row_len // 16
    with tvm_ib.if_scope(row_len >= col_len_now):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len_now * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    dst_offset = n_index * col_len * row_len + col_len_begin
    n_burst = row_len
    burst_len_dst = col_len_now // cp_align_len
    dst_stride = (col_len - col_len_now) // cp_align_len
    args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
           burst_len_dst, 0, dst_stride, cp_align_len
    _func_ub_to_gm_align(args)


def _func_two_permute_align_split_col_fp16_fencore_nomod(args):
    """
    function for permute align split col fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    col_len_now = col_len_ub
    col_len_begin = fen_index * col_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
           col_len, row_len, col_len_begin, col_len_now
    _move_for_permute_split_col_fp16_fencore(args)


def _func_two_permute_align_split_col_fp16_fencore_mod(args):
    """
    function for permute align split col fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        col_len_now = col_len_ub
        col_len_begin = fen_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index,\
               col_len, row_len, col_len_begin, col_len_now
        _move_for_permute_split_col_fp16_fencore(args)

    with tvm_ib.else_scope():
        col_len_now = ub_mod
        col_len_begin = fen_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
               col_len, row_len, col_len_begin, col_len_now
        _move_for_permute_split_col_fp16_fencore(args)


def _two_permute_align_split_col_fp16_fencore(dst, data):
    """
    function of making ir node builder
    for permute align split col fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    col_len_ub = (ub_ele // row_len // cp_align_len) * cp_align_len
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_permute_align_split_col_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_permute_align_split_col_fp16_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_permute_align_split_col_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_permute_align_split_col_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_permute_align_large_fp16(args):
    """
    function of moving data for permute align large fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    row_zu = row_len // 16
    col_16_ele = col_len * 16
    ub_loop = col_16_ele // ub_ele
    ub_mod = col_16_ele % ub_ele
    ub_col = ub_ele // 16
    row_ub = 16
    ub_col_mod = ub_mod // 16

    n_index = num_g * device_core_num + block_index

    with tvm_ib.for_range(0, row_zu, name="num_rowz") as num_rowz:
        with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:

            data_offset = n_index * col_len * row_len\
                          + num_u * ub_col * row_len + num_rowz * row_ub
            n_burst = ub_col
            burst_len_data = row_ub // cp_align_len
            src_stride = (row_len - row_ub) // cp_align_len
            args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
                   burst_len_data, src_stride, 0, cp_align_len
            _func_gm_to_ub_align(args)

            c_zu = ub_col // 16
            r_zu = row_ub // 16
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_col * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

            dst_offset = n_index * col_len * row_len\
                         + num_rowz * row_ub * col_len + num_u * ub_col
            n_burst = row_ub
            burst_len_dst = ub_col // cp_align_len
            dst_stride = (col_len - ub_col) // cp_align_len
            args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
                   burst_len_dst, 0, dst_stride, cp_align_len
            _func_ub_to_gm_align(args)
        with tvm_ib.if_scope(ub_col_mod > 0):
            data_offset = n_index * col_len * row_len \
                          + ub_loop * ub_col * row_len + num_rowz * row_ub
            n_burst = ub_col_mod
            burst_len_data = row_ub // cp_align_len
            src_stride = (row_len - row_ub) // cp_align_len
            args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
                   burst_len_data, src_stride, 0, cp_align_len
            _func_gm_to_ub_align(args)

            c_zu = ub_col_mod // 16
            r_zu = row_ub // 16
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_col_mod * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

            dst_offset = n_index * col_len * row_len \
                         + num_rowz * row_ub * col_len + ub_loop * ub_col
            n_burst = row_ub
            burst_len_dst = ub_col_mod // cp_align_len
            dst_stride = (col_len - ub_col_mod) // cp_align_len
            args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
                   burst_len_dst, 0, dst_stride, cp_align_len
            _func_ub_to_gm_align(args)


def _two_permute_align_large_fp16(dst, data):
    """
    function of making ir node builder for permute align large fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_permute_align_large_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_permute_align_large_fp16(args)

    return tvm_ib.get()


def _move_for_permute_large_fp16_fencore(args):
    """
    function of moving data for permute align large fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    ub_ele, float_size, cp_align_len, col_len, row_len, n_index,\
    row_index, row_ub, col_len_now, col_len_begin = args

    data_offset = n_index * col_len * row_len \
                  + col_len_begin * row_len + row_index * row_ub
    n_burst = col_len_now
    burst_len_data = row_ub // cp_align_len
    src_stride = (row_len - row_ub) // cp_align_len
    args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
           burst_len_data, src_stride, 0, cp_align_len
    _func_gm_to_ub_align(args)

    c_zu = col_len_now // 16
    r_zu = row_ub // 16
    with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
        one_begin = (num_rz * 16) * float_size
        two_begin = (ub_ele + num_rz * col_len_now * 16) * float_size
        repeat_vconv = c_zu
        src_stride_vconv = 16 * r_zu
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, \
               two_begin, repeat_vconv, src_stride_vconv, \
               dst_stride_vconv, r_zu, c_zu
        _vconv_one(args)

    dst_offset = n_index * col_len * row_len \
                 + row_index * row_ub * col_len + col_len_begin
    n_burst = row_ub
    burst_len_dst = col_len_now // cp_align_len
    dst_stride = (col_len - col_len_now) // cp_align_len
    args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
           burst_len_dst, 0, dst_stride, cp_align_len
    _func_ub_to_gm_align(args)


def _func_two_permute_align_large_fp16_fencore_nomod(args):
    """
    function for permute align large fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_zu, \
    row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    col_len_now = ub_col
    col_len_begin = col_index * ub_col
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
           row_len, n_index, row_index, row_ub, col_len_now, col_len_begin
    _move_for_permute_large_fp16_fencore(args)


def _func_two_permute_align_large_fp16_fencore_mod(args):
    """
    function for permute align large fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_zu, \
    row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(col_index < col_fen - 1):
        col_len_now = ub_col
        col_len_begin = col_index * ub_col
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len,\
               row_len, n_index, row_index, row_ub, col_len_now, col_len_begin
        _move_for_permute_large_fp16_fencore(args)
    with tvm_ib.else_scope():
        col_len_now = ub_col_mod
        col_len_begin = col_index * ub_col
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
               row_len, n_index, row_index, row_ub, col_len_now, col_len_begin
        _move_for_permute_large_fp16_fencore(args)


def _two_permute_align_large_fp16_fencore(dst, data):
    """
    function of making ir node builder
    for permute align large fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    row_zu = row_len // 16
    col_16_ele = col_len * 16
    ub_loop = col_16_ele // ub_ele
    ub_mod = col_16_ele % ub_ele
    ub_col = ub_ele // 16
    row_ub = 16
    ub_col_mod = ub_mod // 16

    with tvm_ib.if_scope(ub_col_mod > 0):
        col_fen = ub_loop + 1
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_zu, \
                   row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, num_g
            _func_two_permute_align_large_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_zu, \
                   row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, num_g
                _func_two_permute_align_large_fp16_fencore_mod(args)
    with tvm_ib.else_scope():
        col_fen = ub_loop
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_zu, \
                   row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, num_g
            _func_two_permute_align_large_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, row_zu, \
                       row_ub, fen_n, ub_loop, ub_col, ub_col_mod,\
                       col_fen, num_g
                _func_two_permute_align_large_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _set_mask(length):
    """
    calculate MASK in cce

    Parameters
    ----------
    length : int
        calculate length

    Returns
    -------
    mask : tuple of int
        low and high bit of mask.
    """
    length = int(length)
    mask1 = 2**max(length - 64, 0) - 1  # high 64bits
    mask2 = 2**min(length, 64) - 1  # low 64bits
    return mask1, mask2


def _func_two_col_align_little_fp16(args):
    """
    function for col align little fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    dim_ele = col_len * row_len
    dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
    dim_zu = dim_ele_align // 16

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    data_offset = n_index * col_len * row_len
    burst_len_data = _ceil_div(dim_ele, cp_align_len)
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(row_len <= 31):
        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            add_zu = col_len // 8
            add_mod = col_len % 8
            with tvm_ib.if_scope(add_zu > 0):
                res_offset = num_r * 16
                ub_offset = num_r * 16 * col_len
                repeat = add_zu
                srcm0 = row_len
                dstm0 = 1
                srcm1 = srcm0 * 8
                dstm1 = 8
                mask1, mask2 = _set_mask(128)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)
            with tvm_ib.if_scope(add_mod > 0):
                res_offset = num_r * 16 + add_zu * 8 * 16 * row_len
                ub_offset = num_r * 16 * col_len + add_zu * 8 * 16
                repeat = 1
                srcm0 = row_len
                dstm0 = 1
                srcm1 = 0
                dstm1 = 0
                mask_len = add_mod * 16
                mask1, mask2 = _set_mask(mask_len)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)

        tvm_ib.emit(tvm.call_extern(
            dst.dtype, "set_vector_mask",
            tvm.const(-1, dtype="uint64"),
            tvm.const(-1, dtype="uint64")))

    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * col_len
            n_burst = col_len
            burst_len = 1
            src_stride = row_len - 1
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

    dim_ele = col_len * row_len
    dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
    dim_zu = dim_ele_align // 16

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    dst_offset = n_index * col_len * row_len
    burst_len_dst = dim_ele // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, 1, burst_len_dst, 0, 0))


def _two_col_align_little_fp16(dst, data):
    """
    function of making ir node builder for col align little fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_col_align_little_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_col_align_little_fp16(args)

    return tvm_ib.get()


def _func_two_col_align_small_fp16(args):
    """
    function of moving data for col align small fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
        data_offset = n_index * col_len * row_len + num_c * row_len
        ub_offset = num_c * row_len_align
        burst_len_data = _ceil_div(row_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    c_zu = col_len // 16
    r_zu = row_len_align // 16
    with tvm_ib.if_scope(row_len_align >= col_len):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len_align * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    dst_offset = n_index * col_len * row_len
    burst_len_dst = (col_len * row_len) // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, 1, burst_len_dst, 0, 0))


def _two_col_align_small_fp16(dst, data):
    """
    function of making ir node builder for col align small fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_col_align_small_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_col_align_small_fp16(args)

    return tvm_ib.get()


def _func_two_col_align_split_row_fp16(args):
    """
    function of moving data for col align split row fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    row_len_ub = (ub_ele // col_len // cp_align_len) * cp_align_len
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len + num_c * row_len\
                          + num_u * row_len_ub
            ub_offset = num_c * row_len_ub
            burst_len_data = row_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = col_len // 16
        r_zu = row_len_ub // 16
        with tvm_ib.if_scope(row_len_ub >= col_len):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len_ub * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        dst_offset = n_index * col_len * row_len + num_u * col_len * row_len_ub
        burst_len_dst = (col_len * row_len_ub) // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))

    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)

        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len + num_c * row_len\
                          + ub_loop * row_len_ub
            ub_offset = num_c * ub_mod_align
            burst_len_data = _ceil_div(ub_mod, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = col_len // 16
        r_zu = ub_mod_align // 16
        with tvm_ib.if_scope(ub_mod_align >= col_len):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * ub_mod_align * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        dst_offset = n_index * col_len * row_len\
                     + ub_loop * col_len * row_len_ub
        burst_len_dst = (col_len * ub_mod) // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _two_col_align_split_row_fp16(dst, data):
    """
    function of making ir node builder for col align split row fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_col_align_split_row_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_col_align_split_row_fp16(args)

    return tvm_ib.get()


def _move_for_col_align_split_row_fp16_fencore(args):
    """
    function of moving data for col align split row fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    col_len, row_len, cp_align_len, float_size, ub_ele, n_index,\
    row_len_ub, row_len_begin, row_len_now = args

    with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
        data_offset = n_index * col_len * row_len + num_c * row_len \
                      + row_len_begin
        ub_offset = num_c * row_len_now
        burst_len_data = row_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    c_zu = col_len // 16
    r_zu = row_len_now // 16
    with tvm_ib.if_scope(row_len_now >= col_len):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len_now * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    dst_offset = n_index * col_len * row_len + row_len_begin * col_len
    burst_len_dst = (col_len * row_len_now) // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, 1, burst_len_dst, 0, 0))


def _func_two_col_align_split_row_fp16_fencore_nomod(args):
    """
    function for col align split row fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    row_len_now = row_len_ub
    row_len_begin = fen_index * row_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
           col_len, row_len, cp_align_len, float_size, ub_ele, n_index,\
           row_len_ub, row_len_begin, row_len_now
    _move_for_col_align_split_row_fp16_fencore(args)


def _func_two_col_align_split_row_fp16_fencore_mod(args):
    """
    function for col align split row fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        row_len_now = row_len_ub
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, col_len, row_len, cp_align_len, float_size,\
               ub_ele, n_index, row_len_ub, row_len_begin, row_len_now
        _move_for_col_align_split_row_fp16_fencore(args)
    with tvm_ib.else_scope():
        row_len_now = _ceil_fill(ub_mod, cp_align_len)
        row_len_begin = row_len - row_len_now
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, col_len, row_len, cp_align_len, float_size, \
               ub_ele, n_index, row_len_ub, row_len_begin, row_len_now
        _move_for_col_align_split_row_fp16_fencore(args)


def _two_col_align_split_row_fp16_fencore(dst, data):
    """
    function of making ir node builder
    for two col align split row fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    row_len_ub = (ub_ele // col_len // cp_align_len) * cp_align_len
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_col_align_split_row_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_col_align_split_row_fp16_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_col_align_split_row_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_col_align_split_row_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_col_align_split_col_fp16(args):
    """
    function of moving data for col align split col fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)

    col_len_ub = (ub_ele // row_len_align // cp_align_len) * cp_align_len
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, col_len_ub, name="num_cl") as num_cl:
            data_offset = n_index * col_len * row_len \
                          + num_u * col_len_ub * row_len + num_cl * row_len
            ub_offset = num_cl * row_len_align
            burst_len_data = _ceil_div(row_len, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = col_len_ub // 16
        r_zu = row_len_align // 16
        with tvm_ib.if_scope(row_len_align >= col_len_ub):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len_align * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len_ub * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        dst_offset = n_index * col_len * row_len + num_u * col_len_ub
        n_burst = row_len
        burst_len_dst = col_len_ub // cp_align_len
        dst_stride = (col_len - col_len_ub) // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, n_burst, burst_len_dst, 0, dst_stride))

    with tvm_ib.if_scope(ub_mod > 0):
        with tvm_ib.for_range(0, ub_mod, name="num_cl") as num_cl:
            data_offset = n_index * col_len * row_len \
                          + ub_loop * col_len_ub * row_len + num_cl * row_len
            ub_offset = num_cl * row_len_align
            burst_len_data = _ceil_div(row_len, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = ub_mod // 16
        r_zu = row_len_align // 16
        with tvm_ib.if_scope(row_len_align >= ub_mod):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len_align * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_mod * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        dst_offset = n_index * col_len * row_len + ub_loop * col_len_ub
        n_burst = row_len
        burst_len_dst = ub_mod // cp_align_len
        dst_stride = (col_len - ub_mod) // cp_align_len
        args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)


def _two_col_align_split_col_fp16(dst, data):
    """
    function of making ir node builder for col align split col fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_col_align_split_col_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_col_align_split_col_fp16(args)

    return tvm_ib.get()


def _move_for_col_align_split_col_fp16_fencore(args):
    """
    function of moving data for col align split col fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    ub_ele, cp_align_len, float_size, col_len, row_len, row_len_align,\
    n_index, col_len_ub, col_len_now, col_len_begin = args

    with tvm_ib.for_range(0, col_len_now, name="num_cl") as num_cl:
        data_offset = n_index * col_len * row_len \
                      + col_len_begin * row_len + num_cl * row_len
        ub_offset = num_cl * row_len_align
        burst_len_data = _ceil_div(row_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    c_zu = col_len_now // 16
    r_zu = row_len_align // 16
    with tvm_ib.if_scope(row_len_align >= col_len_now):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len_align * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len_now * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    dst_offset = n_index * col_len * row_len + col_len_begin
    n_burst = row_len
    burst_len_dst = col_len_now // cp_align_len
    dst_stride = (col_len - col_len_now) // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, n_burst, burst_len_dst, 0, dst_stride))


def _func_two_col_align_split_col_fp16_fencore_nomod(args):
    """
    function for col align split col fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    col_len_now = col_len_ub
    col_len_begin = fen_index * col_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, ub_ele, cp_align_len, float_size, \
           col_len, row_len, row_len_align, n_index, \
           col_len_ub, col_len_now, col_len_begin
    _move_for_col_align_split_col_fp16_fencore(args)


def _func_two_col_align_split_col_fp16_fencore_mod(args):
    """
    function for col align split col fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        col_len_now = col_len_ub
        col_len_begin = fen_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, ub_ele, cp_align_len, float_size,\
               col_len, row_len, row_len_align, n_index,\
               col_len_ub, col_len_now, col_len_begin
        _move_for_col_align_split_col_fp16_fencore(args)

    with tvm_ib.else_scope():
        col_len_now = _ceil_fill(ub_mod, cp_align_len)
        col_len_begin = col_len - col_len_now
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, cp_align_len, float_size, \
               col_len, row_len, row_len_align, n_index, \
               col_len_ub, col_len_now, col_len_begin
        _move_for_col_align_split_col_fp16_fencore(args)


def _two_col_align_split_col_fp16_fencore(dst, data):
    """
    function of making ir node builder
    for col align split col fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)
    col_len_ub = (ub_ele // row_len_align // cp_align_len) * cp_align_len
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_col_align_split_col_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_col_align_split_col_fp16_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_col_align_split_col_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_col_align_split_col_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_col_align_split_col_fp16_new(args):
    """
    function for col align split col fp16 new scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    new_space_ele_split_col = _ceil_fill(row_len * 16, 16) * 16
    num_col_len_ub = ub_ele // new_space_ele_split_col
    col_len_ub = num_col_len_ub * 16
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        data_offset = n_index * col_len * row_len\
                      + num_u * col_len_ub * row_len
        burst_len_data = col_len_ub * row_len // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        dim_ele_align = col_len_ub * row_len
        dim_zu = dim_ele_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.if_scope(row_len <= 31):
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                add_zu = col_len_ub // 8
                add_mod = col_len_ub % 8
                with tvm_ib.if_scope(add_zu > 0):
                    res_offset = num_r * 16
                    ub_offset = num_r * 16 * col_len_ub
                    repeat = add_zu
                    srcm0 = row_len
                    dstm0 = 1
                    srcm1 = srcm0 * 8
                    dstm1 = 8
                    mask1, mask2 = _set_mask(128)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)
                with tvm_ib.if_scope(add_mod > 0):
                    res_offset = num_r * 16 + add_zu * 8 * 16 * row_len
                    ub_offset = num_r * 16 * col_len_ub + add_zu * 8 * 16
                    repeat = 1
                    srcm0 = row_len
                    dstm0 = 1
                    srcm1 = 0
                    dstm1 = 0
                    mask_len = add_mod * 16
                    mask1, mask2 = _set_mask(mask_len)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)

            tvm_ib.emit(tvm.call_extern(
                dst.dtype, "set_vector_mask",
                tvm.const(-1, dtype="uint64"),
                tvm.const(-1, dtype="uint64")))

        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                res_offset = num_r * 16
                ub_offset = num_r * 16 * col_len_ub
                n_burst = col_len_ub
                burst_len = 1
                src_stride = row_len - 1
                dst_stride = 0
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        dst_offset = n_index * col_len * row_len + num_u * col_len_ub
        n_burst = row_len
        burst_len_dst = col_len_ub // cp_align_len
        dst_stride = (col_len - col_len_ub) // cp_align_len
        args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)

    with tvm_ib.if_scope(ub_mod > 0):
        data_offset = n_index * col_len * row_len \
                      + ub_loop * col_len_ub * row_len
        burst_len_data = ub_mod * row_len // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        dim_ele_align = ub_mod * row_len
        dim_zu = dim_ele_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.if_scope(row_len <= 31):
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                add_zu = ub_mod // 8
                add_mod = ub_mod % 8
                with tvm_ib.if_scope(add_zu > 0):
                    res_offset = num_r * 16
                    ub_offset = num_r * 16 * ub_mod
                    repeat = add_zu
                    srcm0 = row_len
                    dstm0 = 1
                    srcm1 = srcm0 * 8
                    dstm1 = 8
                    mask1, mask2 = _set_mask(128)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)
                with tvm_ib.if_scope(add_mod > 0):
                    res_offset = num_r * 16 + add_zu * 8 * 16 * row_len
                    ub_offset = num_r * 16 * ub_mod + add_zu * 8 * 16
                    repeat = 1
                    srcm0 = row_len
                    dstm0 = 1
                    srcm1 = 0
                    dstm1 = 0
                    mask_len = add_mod * 16
                    mask1, mask2 = _set_mask(mask_len)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)

            tvm_ib.emit(tvm.call_extern(
                dst.dtype, "set_vector_mask",
                tvm.const(-1, dtype="uint64"),
                tvm.const(-1, dtype="uint64")))

        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                res_offset = num_r * 16
                ub_offset = num_r * 16 * ub_mod
                n_burst = ub_mod
                burst_len = 1
                src_stride = row_len - 1
                dst_stride = 0
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        dst_offset = n_index * col_len * row_len + ub_loop * col_len_ub
        n_burst = row_len
        burst_len_dst = ub_mod // cp_align_len
        dst_stride = (col_len - ub_mod) // cp_align_len
        args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)


def _two_col_align_split_col_fp16_new(dst, data):
    """
    function of making ir node builder for col align split col fp16 new scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_col_align_split_col_fp16_new(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_col_align_split_col_fp16_new(args)

    return tvm_ib.get()


def _move_for_col_align_split_col_fp16_new_fencore(args):
    """
    function of moving data for col align split col fp16 new fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    ub_ele, cp_align_len, float_size, col_len, row_len, row_len_align,\
    n_index, col_len_ub, col_len_now, col_len_begin = args

    data_offset = n_index * col_len * row_len \
                  + col_len_begin * row_len
    burst_len_data = col_len_now * row_len // cp_align_len
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    dim_ele_align = col_len_now * row_len
    dim_zu = dim_ele_align // 16

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(row_len <= 31):
        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            add_zu = col_len_now // 8
            add_mod = col_len_now % 8
            with tvm_ib.if_scope(add_zu > 0):
                res_offset = num_r * 16
                ub_offset = num_r * 16 * col_len_now
                repeat = add_zu
                srcm0 = row_len
                dstm0 = 1
                srcm1 = srcm0 * 8
                dstm1 = 8
                mask1, mask2 = _set_mask(128)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)
            with tvm_ib.if_scope(add_mod > 0):
                res_offset = num_r * 16 + add_zu * 8 * 16 * row_len
                ub_offset = num_r * 16 * col_len_now + add_zu * 8 * 16
                repeat = 1
                srcm0 = row_len
                dstm0 = 1
                srcm1 = 0
                dstm1 = 0
                mask_len = add_mod * 16
                mask1, mask2 = _set_mask(mask_len)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)

        tvm_ib.emit(tvm.call_extern(
            dst.dtype, "set_vector_mask",
            tvm.const(-1, dtype="uint64"),
            tvm.const(-1, dtype="uint64")))

    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * col_len_now
            n_burst = col_len_now
            burst_len = 1
            src_stride = row_len - 1
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    dst_offset = n_index * col_len * row_len + col_len_begin
    n_burst = row_len
    burst_len_dst = col_len_now // cp_align_len
    dst_stride = (col_len - col_len_now) // cp_align_len
    args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
           burst_len_dst, 0, dst_stride, cp_align_len
    _func_ub_to_gm_align(args)


def _func_two_col_align_split_col_fp16_new_fencore_nomod(args):
    """
    function for col align split col fp16 new fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    col_len_now = col_len_ub
    col_len_begin = fen_index * col_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, ub_ele, cp_align_len, float_size, \
           col_len, row_len, row_len_align, n_index, \
           col_len_ub, col_len_now, col_len_begin
    _move_for_col_align_split_col_fp16_new_fencore(args)


def _func_two_col_align_split_col_fp16_new_fencore_mod(args):
    """
    function for col align split col fp16 new fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        col_len_now = col_len_ub
        col_len_begin = fen_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, ub_ele, cp_align_len, float_size,\
               col_len, row_len, row_len_align, n_index,\
               col_len_ub, col_len_now, col_len_begin
        _move_for_col_align_split_col_fp16_new_fencore(args)

    with tvm_ib.else_scope():
        col_len_now = _ceil_fill(ub_mod, cp_align_len)
        col_len_begin = col_len - col_len_now
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, cp_align_len, float_size, \
               col_len, row_len, row_len_align, n_index, \
               col_len_ub, col_len_now, col_len_begin
        _move_for_col_align_split_col_fp16_new_fencore(args)


def _two_col_align_split_col_fp16_new_fencore(dst, data):
    """
    function of making ir node builder
    for col align split col fp16 new fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i, col_len, row_len = data.shape
    new_space_ele_split_col = _ceil_fill(row_len * 16, 16) * 16
    num_col_len_ub = ub_ele // new_space_ele_split_col
    col_len_ub = num_col_len_ub * 16
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_col_align_split_col_fp16_new_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_col_align_split_col_fp16_new_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_col_align_split_col_fp16_new_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_col_align_split_col_fp16_new_fencore_nomod(args)

    return tvm_ib.get()


def _move_data_large(args):
    """
    function of moving data for large scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    cp_align_len, col_len, row_len, ub_ele, float_size, row_ub, ub_loop,\
    ub_col, ub_col_mod, n_index, num_rowz, row_len_now = args

    row_len_now_align = _ceil_fill(row_len_now, cp_align_len)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, ub_col, name="num_uc") as num_uc:
            data_offset = n_index * col_len * row_len\
                          + (num_u * ub_col + num_uc) * row_len\
                          + num_rowz * row_ub
            ub_offset = num_uc * row_len_now_align
            burst_len_data = _ceil_div(row_len_now, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = ub_col // 16
        r_zu = row_len_now_align // 16
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * ub_col * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

        dst_offset = n_index * col_len * row_len\
                     + num_rowz * row_ub * col_len + num_u * ub_col
        n_burst = row_len_now
        burst_len_dst = ub_col // cp_align_len
        dst_stride = (col_len - ub_col) // cp_align_len
        args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)

    with tvm_ib.if_scope(ub_col_mod > 0):
        with tvm_ib.for_range(0, ub_col_mod, name="num_uc") as num_uc:
            data_offset = n_index * col_len * row_len\
                          + (ub_loop * ub_col + num_uc) * row_len\
                          + num_rowz * row_ub
            ub_offset = num_uc * row_len_now_align
            burst_len_data = _ceil_div(row_len_now, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = ub_col_mod // 16
        r_zu = row_len_now_align // 16
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * ub_col_mod * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

        dst_offset = n_index * col_len * row_len\
                     + num_rowz * row_ub * col_len + ub_loop * ub_col
        n_burst = row_len_now
        burst_len_dst = ub_col_mod // cp_align_len
        dst_stride = (col_len - ub_col_mod) // cp_align_len
        args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)


def _func_two_col_align_large_fp16(args):
    """
    function of moving data for col align large fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)

    row_zu = row_len_align // 16
    col_16_ele = col_len * 16
    ub_loop = col_16_ele // ub_ele
    ub_mod = col_16_ele % ub_ele
    ub_col = ub_ele // 16
    row_ub = 16
    ub_col_mod = ub_mod // 16

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, row_zu, name="num_rowz") as num_rowz:
        with tvm_ib.if_scope(num_rowz < (row_zu - 1)):
            row_len_now = row_ub
            args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
                   addr_array_buf, cp_align_len, col_len, row_len, ub_ele,\
                   float_size, row_ub, ub_loop, ub_col, ub_col_mod, n_index,\
                   num_rowz, row_len_now
            _move_data_large(args)

        with tvm_ib.else_scope():
            row_len_now = row_len - (row_zu - 1) * row_ub
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, cp_align_len, col_len, row_len, ub_ele, \
                   float_size, row_ub, ub_loop, ub_col, ub_col_mod, n_index, \
                   num_rowz, row_len_now
            _move_data_large(args)


def _two_col_align_large_fp16(dst, data):
    """
    function of making ir node builder for col align large fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_col_align_large_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_col_align_large_fp16(args)

    return tvm_ib.get()


def _move_data_large_fencore(args):
    """
    function of moving data for large fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    cp_align_len, col_len, row_len, ub_ele, float_size, row_ub, ub_loop,\
    ub_col, ub_col_mod, n_index, num_rowz, row_len_now = args

    row_len_now_align = _ceil_fill(row_len_now, cp_align_len)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, ub_col, name="num_uc") as num_uc:
            data_offset = n_index * col_len * row_len\
                          + (num_u * ub_col + num_uc) * row_len\
                          + num_rowz * row_ub
            ub_offset = num_uc * row_len_now_align
            burst_len_data = _ceil_div(row_len_now, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = ub_col // 16
        r_zu = row_len_now_align // 16
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * ub_col * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

        dst_offset = n_index * col_len * row_len\
                     + num_rowz * row_ub * col_len + num_u * ub_col
        n_burst = row_len_now
        burst_len_dst = ub_col // cp_align_len
        dst_stride = (col_len - ub_col) // cp_align_len
        args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)

    with tvm_ib.if_scope(ub_col_mod > 0):
        with tvm_ib.for_range(0, ub_col_mod, name="num_uc") as num_uc:
            data_offset = n_index * col_len * row_len\
                          + (ub_loop * ub_col + num_uc) * row_len\
                          + num_rowz * row_ub
            ub_offset = num_uc * row_len_now_align
            burst_len_data = _ceil_div(row_len_now, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = ub_col_mod // 16
        r_zu = row_len_now_align // 16
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * ub_col_mod * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

        dst_offset = n_index * col_len * row_len\
                     + num_rowz * row_ub * col_len + ub_loop * ub_col
        n_burst = row_len_now
        burst_len_dst = ub_col_mod // cp_align_len
        dst_stride = (col_len - ub_col_mod) // cp_align_len
        args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)


def _move_for_col_align_large_fp16_fencore(args):
    """
    function of moving data for col align large fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, \
    addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
    row_len, n_index, row_index, row_ub, \
    row_len_now, col_len_now, col_len_begin = args

    row_len_now_align = _ceil_fill(row_len_now, cp_align_len)

    with tvm_ib.for_range(0, col_len_now, name="num_uc") as num_uc:
        data_offset = n_index * col_len * row_len \
                      + (col_len_begin + num_uc) * row_len \
                      + row_index * row_ub
        ub_offset = num_uc * row_len_now_align
        burst_len_data = _ceil_div(row_len_now, cp_align_len)
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    c_zu = col_len_now // 16
    r_zu = row_len_now_align // 16
    with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
        one_begin = (num_rz * 16) * float_size
        two_begin = (ub_ele + num_rz * col_len_now * 16) * float_size
        repeat_vconv = c_zu
        src_stride_vconv = 16 * r_zu
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, \
               two_begin, repeat_vconv, src_stride_vconv, \
               dst_stride_vconv, r_zu, c_zu
        _vconv_one(args)

    dst_offset = n_index * col_len * row_len \
                 + row_index * row_ub * col_len + col_len_begin
    n_burst = row_len_now
    burst_len_dst = col_len_now // cp_align_len
    dst_stride = (col_len - col_len_now) // cp_align_len
    args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
           burst_len_dst, 0, dst_stride, cp_align_len
    _func_ub_to_gm_align(args)


def _func_two_col_align_large_fp16_fencore_nomod(args):
    """
    function for col align large fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, \
    row_ub, row_zu, fen_n, col_fen, ub_col, ub_col_mod,\
    num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(row_index < row_zu - 1):
        row_len_now = row_ub
        col_len_now = ub_col
        col_len_begin = col_index * ub_col
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
               row_len, n_index, row_index, row_ub, \
               row_len_now, col_len_now, col_len_begin
        _move_for_col_align_large_fp16_fencore(args)
    with tvm_ib.else_scope():
        row_len_now = row_len - (row_zu - 1) * row_ub
        col_len_now = ub_col
        col_len_begin = col_index * ub_col
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
               row_len, n_index, row_index, row_ub, \
               row_len_now, col_len_now, col_len_begin
        _move_for_col_align_large_fp16_fencore(args)


def _func_two_col_align_large_fp16_fencore_mod(args):
    """
    function for col align large fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, \
    row_ub, row_zu, fen_n, col_fen, ub_col, ub_col_mod,\
    num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(row_index < row_zu - 1):
        with tvm_ib.if_scope(col_index < col_fen - 1):
            row_len_now = row_ub
            col_len_now = ub_col
            col_len_begin = col_index * ub_col
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len,\
                   col_len, row_len, n_index, row_index, row_ub,\
                   row_len_now, col_len_now, col_len_begin
            _move_for_col_align_large_fp16_fencore(args)
        with tvm_ib.else_scope():
            row_len_now = row_ub
            col_len_now = ub_col_mod
            col_len_begin = col_index * ub_col
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len,\
                   col_len, row_len, n_index, row_index, row_ub,\
                   row_len_now, col_len_now, col_len_begin
            _move_for_col_align_large_fp16_fencore(args)
    with tvm_ib.else_scope():
        with tvm_ib.if_scope(col_index < col_fen - 1):
            row_len_now = row_len - (row_zu - 1) * row_ub
            col_len_now = ub_col
            col_len_begin = col_index * ub_col
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len,\
                   col_len, row_len, n_index, row_index, row_ub,\
                   row_len_now, col_len_now, col_len_begin
            _move_for_col_align_large_fp16_fencore(args)
        with tvm_ib.else_scope():
            row_len_now = row_len - (row_zu - 1) * row_ub
            col_len_now = ub_col_mod
            col_len_begin = col_index * ub_col
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len,\
                   col_len, row_len, n_index, row_index, row_ub,\
                   row_len_now, col_len_now, col_len_begin
            _move_for_col_align_large_fp16_fencore(args)


def _two_col_align_large_fp16_fencore(dst, data):
    """
    function of making ir node builder for col align large fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)

    row_zu = row_len_align // 16
    col_16_ele = col_len * 16
    ub_loop = col_16_ele // ub_ele
    ub_mod = col_16_ele % ub_ele
    ub_col = ub_ele // 16
    row_ub = 16
    ub_col_mod = ub_mod // 16

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_col_mod > 0):
        col_fen = ub_loop + 1
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, \
                   row_ub, row_zu, fen_n, col_fen, ub_col, ub_col_mod, num_g
            _func_two_col_align_large_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, \
                       row_ub, row_zu, fen_n, col_fen,\
                       ub_col, ub_col_mod, group_index
                _func_two_col_align_large_fp16_fencore_mod(args)
    with tvm_ib.else_scope():
        col_fen = ub_loop
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, \
                   row_ub, row_zu, fen_n, col_fen, ub_col, ub_col_mod, num_g
            _func_two_col_align_large_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, \
                       row_ub, row_zu, fen_n, col_fen,\
                       ub_col, ub_col_mod, group_index
                _func_two_col_align_large_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_row_align_little_fp16(args):
    """
    function of moving data for row align little fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    dim_ele = col_len * row_len
    dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
    dim_zu = dim_ele_align // 16

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    data_offset = n_index * col_len * row_len
    burst_len_data = _ceil_div(dim_ele, cp_align_len)
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(col_len <= 31):
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            add_zu = row_len // 8
            add_mod = row_len % 8
            with tvm_ib.if_scope(add_zu > 0):
                res_offset = num_c * 16 * row_len
                ub_offset = num_c * 16
                repeat = add_zu
                srcm0 = 1
                dstm0 = col_len
                srcm1 = 8
                dstm1 = dstm0 * 8
                mask1, mask2 = _set_mask(128)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)
            with tvm_ib.if_scope(add_mod > 0):
                res_offset = num_c * 16 * row_len + add_zu * 8 * 16
                ub_offset = num_c * 16 + add_zu * 8 * 16 * col_len
                repeat = 1
                srcm0 = 1
                dstm0 = col_len
                srcm1 = 0
                dstm1 = 0
                mask_len = add_mod * 16
                mask1, mask2 = _set_mask(mask_len)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)

        tvm_ib.emit(tvm.call_extern(
            dst.dtype, "set_vector_mask",
            tvm.const(-1, dtype="uint64"),
            tvm.const(-1, dtype="uint64")))

    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            res_offset = num_c * 16 * row_len
            ub_offset = num_c * 16
            n_burst = row_len
            burst_len = 1
            src_stride = 0
            dst_stride = col_len - 1
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

    dim_ele = col_len * row_len
    dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
    dim_zu = dim_ele_align // 16

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    dst_offset = n_index * col_len * row_len
    burst_len_dst = dim_ele // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, 1, burst_len_dst, 0, 0))


def _two_row_align_little_fp16(dst, data):
    """
    function of making ir node builder for row align little fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_row_align_little_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_row_align_little_fp16(args)

    return tvm_ib.get()


def _func_two_row_align_small_fp16(args):
    """
    function of moving data for row align large small fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    col_len_align = _ceil_fill(col_len, cp_align_len)

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    data_offset = n_index * col_len * row_len
    burst_len_data = col_len * row_len // cp_align_len
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    c_zu = col_len_align // 16
    r_zu = row_len // 16
    with tvm_ib.if_scope(row_len >= col_len_align):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                   two_begin, repeat_vconv, src_stride_vconv,\
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len_align * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                   two_begin, repeat_vconv, src_stride_vconv,\
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    with tvm_ib.for_range(0, (row_len - 1), name="num_r") as num_r:
        dst_offset = n_index * col_len * row_len + num_r * col_len
        res_offset = num_r * col_len_align
        burst_len_dst = _ceil_div(col_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r",
                                                        offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))

    move_len = col_len - cp_align_len
    dst_offset = n_index * col_len * row_len + (row_len - 1) * col_len
    with tvm_ib.if_scope(move_len > 0):
        res_offset = (row_len - 1) * col_len_align
        burst_len_dst = _ceil_div(move_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r",
                                                        offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))
    with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_res.access_ptr(
                'r', offset=(row_len - 1) * col_len_align + move_len + num_a)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr(
                'w', offset=num_a),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset + move_len),
                                data_tail.access_ptr("r", offset=0),
                                0, 1, 1, 0, 0))


def _two_row_align_small_fp16(dst, data):
    """
    function of making ir node builder for row align small fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_row_align_small_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_row_align_small_fp16(args)

    return tvm_ib.get()


def _func_two_row_align_split_row_fp16(args):
    """
    function of moving data for row align split row fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    col_len_align = _ceil_fill(col_len, cp_align_len)

    row_len_ub = (ub_ele // col_len_align // cp_align_len) * cp_align_len
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    n_index = num_g * device_core_num + block_index
    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        data_offset = n_index * col_len * row_len + num_u * row_len_ub
        n_burst = col_len
        burst_len_data = row_len_ub // cp_align_len
        src_stride = (row_len - row_len_ub) // cp_align_len
        args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
               burst_len_data, src_stride, 0, cp_align_len
        _func_gm_to_ub_align(args)

        c_zu = col_len_align // 16
        r_zu = row_len_ub // 16
        with tvm_ib.if_scope(row_len_ub >= col_len_align):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len_ub * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len_align * 16)\
                            * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        with tvm_ib.if_scope(ub_mod > 0):
            with tvm_ib.for_range(0, row_len_ub, name="num_rl") as num_rl:
                dst_offset = n_index * col_len * row_len\
                             + (num_u * row_len_ub + num_rl) * col_len
                res_offset = num_rl * col_len_align
                burst_len_dst = _ceil_div(col_len, cp_align_len)
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))
        with tvm_ib.else_scope():
            with tvm_ib.if_scope(num_u < ub_loop - 1):
                with tvm_ib.for_range(0, row_len_ub, name="num_rl") as num_rl:
                    dst_offset = n_index * col_len * row_len \
                                 + (num_u * row_len_ub + num_rl) * col_len
                    res_offset = num_rl * col_len_align
                    burst_len_dst = _ceil_div(col_len, cp_align_len)
                    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w', offset=dst_offset),
                                                data_res.access_ptr(
                                                    "r", offset=res_offset),
                                                0, 1, burst_len_dst, 0, 0))

            with tvm_ib.else_scope():
                with tvm_ib.for_range(0, (row_len_ub - 1), name="num_rl")\
                        as num_rl:
                    dst_offset = n_index * col_len * row_len \
                                 + (num_u * row_len_ub + num_rl) * col_len
                    res_offset = num_rl * col_len_align
                    burst_len_dst = _ceil_div(col_len, cp_align_len)
                    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w', offset=dst_offset),
                                                data_res.access_ptr(
                                                    "r", offset=res_offset),
                                                0, 1, burst_len_dst, 0, 0))

                move_len = col_len - cp_align_len
                dst_offset = n_index * col_len * row_len \
                             + (num_u * row_len_ub + row_len_ub - 1)\
                             * col_len
                res_offset = (row_len_ub - 1) * col_len_align
                burst_len_dst = _ceil_div(move_len, cp_align_len)
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))
                with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
                    tvm_ib.emit(tvm.call_extern(
                        data_res.dtype, "reg_mov",
                        tvm.call_extern(reg.dtype, "reg", reg[0]),
                        data_res.access_ptr(
                            'r',
                            offset=((row_len_ub - 1) * col_len_align
                                    + move_len + num_a))
                    ))
                    tvm_ib.emit(tvm.call_extern(
                        data_tail.dtype, "reg_mov",
                        data_tail.access_ptr(
                            'w', offset=num_a),
                        tvm.call_extern(reg.dtype, "reg", reg[0])
                    ))
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w',
                                                offset=dst_offset + move_len),
                                            data_tail.access_ptr(
                                                "r", offset=0),
                                            0, 1, 1, 0, 0))

    with tvm_ib.if_scope(ub_mod > 0):
        data_offset = n_index * col_len * row_len + ub_loop * row_len_ub
        n_burst = col_len
        burst_len_data = ub_mod // cp_align_len
        src_stride = (row_len - ub_mod) // cp_align_len
        args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
               burst_len_data, src_stride, 0, cp_align_len
        _func_gm_to_ub_align(args)

        c_zu = col_len_align // 16
        r_zu = ub_mod // 16
        with tvm_ib.if_scope(ub_mod >= col_len_align):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * ub_mod * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len_align * 16)\
                            * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        with tvm_ib.for_range(0, (ub_mod - 1), name="num_rl") as num_rl:
            dst_offset = n_index * col_len * row_len \
                         + (ub_loop * row_len_ub + num_rl) * col_len
            res_offset = num_rl * col_len_align
            burst_len_dst = _ceil_div(col_len, cp_align_len)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

        move_len = col_len - cp_align_len
        dst_offset = n_index * col_len * row_len \
                     + (ub_loop * row_len_ub + ub_mod - 1) * col_len
        res_offset = (ub_mod - 1) * col_len_align
        burst_len_dst = _ceil_div(move_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))
        with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_res.access_ptr(
                    'r',
                    offset=(ub_mod - 1) * col_len_align + move_len + num_a)
            ))
            tvm_ib.emit(tvm.call_extern(
                data_tail.dtype, "reg_mov",
                data_tail.access_ptr(
                    'w', offset=num_a),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr(
                                        'w',
                                        offset=dst_offset + move_len),
                                    data_tail.access_ptr(
                                        "r", offset=0),
                                    0, 1, 1, 0, 0))


def _two_row_align_split_row_fp16(dst, data):
    """
    function of making ir node builder for row align split row fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_row_align_split_row_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_row_align_split_row_fp16(args)

    return tvm_ib.get()


def _move_for_row_align_split_row_fp16_fencore_mod(args):
    """
    function of moving data for row align split row fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, cp_align_len, float_size, ub_ele, \
    col_len, row_len, n_index, row_len_ub, \
    row_len_begin, row_len_now, ub_mod, fen_n, fen_index = args

    col_len_align = _ceil_fill(col_len, cp_align_len)

    data_offset = n_index * col_len * row_len + row_len_begin
    n_burst = col_len
    burst_len_data = row_len_now // cp_align_len
    src_stride = (row_len - row_len_now) // cp_align_len
    args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
           burst_len_data, src_stride, 0, cp_align_len
    _func_gm_to_ub_align(args)

    c_zu = col_len_align // 16
    r_zu = row_len_now // 16
    with tvm_ib.if_scope(row_len_now >= col_len_align):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len_now * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len_align * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    with tvm_ib.for_range(0, (row_len_now - 1),
                          name="num_rl") as num_rl:
        dst_offset = n_index * col_len * row_len \
                     + (row_len_begin + num_rl) * col_len
        res_offset = num_rl * col_len_align
        burst_len_dst = _ceil_div(col_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))

    move_len = col_len - cp_align_len
    dst_offset = n_index * col_len * row_len \
                 + (row_len_begin + row_len_now - 1) * col_len
    res_offset = (row_len_now - 1) * col_len_align
    burst_len_dst = _ceil_div(move_len, cp_align_len)
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, 1, burst_len_dst, 0, 0))
    with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_res.access_ptr(
                'r', offset=((row_len_now - 1) * col_len_align
                             + move_len + num_a))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr(
                'w', offset=num_a),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset + move_len),
                                data_tail.access_ptr(
                                    "r", offset=0),
                                0, 1, 1, 0, 0))


def _func_two_row_align_split_row_fp16_fencore_nomod(args):
    """
    function for row align split row fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    row_len_now = row_len_ub
    row_len_begin = fen_index * row_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
           addr_array, addr_array_buf, cp_align_len, float_size, ub_ele, \
           col_len, row_len, n_index, row_len_ub, \
           row_len_begin, row_len_now, ub_mod, fen_n, fen_index
    _move_for_row_align_split_row_fp16_fencore_mod(args)


def _func_two_row_align_split_row_fp16_fencore_mod(args):
    """
    function for row align split row fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        row_len_now = row_len_ub
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
               addr_array, addr_array_buf, cp_align_len, float_size,\
               ub_ele, col_len, row_len, n_index, row_len_ub, \
               row_len_begin, row_len_now, ub_mod, fen_n, fen_index
        _move_for_row_align_split_row_fp16_fencore_mod(args)
    with tvm_ib.else_scope():
        row_len_now = ub_mod
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
               addr_array, addr_array_buf, cp_align_len, float_size,\
               ub_ele, col_len, row_len, n_index, row_len_ub, \
               row_len_begin, row_len_now, ub_mod, fen_n, fen_index
        _move_for_row_align_split_row_fp16_fencore_mod(args)


def _two_row_align_split_row_fp16_fencore(dst, data):
    """
    function of making ir node builder
    for row align split row fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    col_len_align = _ceil_fill(col_len, cp_align_len)

    row_len_ub = (ub_ele // col_len_align // cp_align_len) * cp_align_len
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_row_align_split_row_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_row_align_split_row_fp16_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_row_align_split_row_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_row_align_split_row_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_vadds(args):
    """
    function of moving data with vadds function

    """
    tvm_ib, data_ub, data_res, ub_offset, res_offset,\
    repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len = args
    max_r = 255

    with tvm_ib.if_scope(repeat <= max_r):
        with tvm_ib.if_scope(repeat == 1):
            tvm_ib.emit(tvm.call_extern(data_res.dtype, "vadds",
                                        data_res.access_ptr("w",
                                                            offset=res_offset),
                                        data_ub.access_ptr('r',
                                                           offset=ub_offset),
                                        0, repeat, dstm0, srcm0, 0, 0))
        with tvm_ib.else_scope():
            tvm_ib.emit(tvm.call_extern(data_res.dtype, "vadds",
                                        data_res.access_ptr("w",
                                                            offset=res_offset),
                                        data_ub.access_ptr('r',
                                                           offset=ub_offset),
                                        0, repeat, dstm0, srcm0, dstm1, srcm1))
    with tvm_ib.else_scope():
        zu_repeat = repeat // max_r
        mod_repeat = repeat % max_r
        with tvm_ib.for_range(0, zu_repeat, name="num_zr") as num_zr:
            ub_offset_cur = ub_offset + num_zr*max_r*srcm1*cp_align_len
            res_offset_cur = res_offset + num_zr*max_r*dstm1*cp_align_len
            tvm_ib.emit(
                tvm.call_extern(
                    data_res.dtype, "vadds",
                    data_res.access_ptr("w", offset=res_offset_cur),
                    data_ub.access_ptr('r', offset=ub_offset_cur),
                    0, max_r, dstm0, srcm0, dstm1, srcm1))
        with tvm_ib.if_scope(mod_repeat > 0):
            ub_offset_cur = ub_offset + zu_repeat*max_r*srcm1*cp_align_len
            res_offset_cur = res_offset + zu_repeat*max_r*dstm1*cp_align_len
            with tvm_ib.if_scope(mod_repeat == 1):
                tvm_ib.emit(
                    tvm.call_extern(
                        data_res.dtype, "vadds",
                        data_res.access_ptr("w", offset=res_offset_cur),
                        data_ub.access_ptr('r', offset=ub_offset_cur),
                        0, mod_repeat, dstm0, srcm0, 0, 0))
            with tvm_ib.else_scope():
                tvm_ib.emit(
                    tvm.call_extern(
                        data_res.dtype, "vadds",
                        data_res.access_ptr("w", offset=res_offset_cur),
                        data_ub.access_ptr('r', offset=ub_offset_cur),
                        0, mod_repeat, dstm0, srcm0, dstm1, srcm1))


def _func_two_row_align_split_row_fp16_new(args):
    """
    function of moving data for row align split row fp16 new scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    new_space_ele_split_row = _ceil_fill(col_len * 16, 16) * 16
    num_row_len_ub = ub_ele // new_space_ele_split_row
    row_len_ub = num_row_len_ub * 16
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len \
                          + num_c * row_len + num_u * row_len_ub
            ub_offset = num_c * row_len_ub
            burst_len_data = row_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = col_len * row_len_ub
        dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
        dim_zu = dim_ele_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.if_scope(col_len <= 31):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                add_zu = row_len_ub // 8
                add_mod = row_len_ub % 8
                with tvm_ib.if_scope(add_zu > 0):
                    res_offset = num_c * 16 * row_len_ub
                    ub_offset = num_c * 16
                    repeat = add_zu
                    srcm0 = 1
                    dstm0 = col_len
                    srcm1 = 8
                    dstm1 = dstm0 * 8
                    mask1, mask2 = _set_mask(128)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)
                with tvm_ib.if_scope(add_mod > 0):
                    res_offset = num_c * 16 * row_len_ub + add_zu * 8 * 16
                    ub_offset = num_c * 16 + add_zu * 8 * 16 * col_len
                    repeat = 1
                    srcm0 = 1
                    dstm0 = col_len
                    srcm1 = 0
                    dstm1 = 0
                    mask_len = add_mod * 16
                    mask1, mask2 = _set_mask(mask_len)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)

            tvm_ib.emit(tvm.call_extern(
                dst.dtype, "set_vector_mask",
                tvm.const(-1, dtype="uint64"),
                tvm.const(-1, dtype="uint64")))

        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                res_offset = num_c * 16 * row_len_ub
                ub_offset = num_c * 16
                n_burst = row_len_ub
                burst_len = 1
                src_stride = 0
                dst_stride = col_len - 1
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        dst_offset = n_index * col_len * row_len \
                     + num_u * row_len_ub * col_len
        burst_len_dst = col_len * row_len_ub // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))
    with tvm_ib.if_scope(ub_mod > 0):
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len \
                          + num_c * row_len + ub_loop * row_len_ub
            ub_offset = num_c * ub_mod
            burst_len_data = ub_mod // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = col_len * ub_mod
        dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
        dim_zu = dim_ele_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.if_scope(col_len <= 31):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                add_zu = ub_mod // 8
                add_mod = ub_mod % 8
                with tvm_ib.if_scope(add_zu > 0):
                    res_offset = num_c * 16 * ub_mod
                    ub_offset = num_c * 16
                    repeat = add_zu
                    srcm0 = 1
                    dstm0 = col_len
                    srcm1 = 8
                    dstm1 = dstm0 * 8
                    mask1, mask2 = _set_mask(128)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)
                with tvm_ib.if_scope(add_mod > 0):
                    res_offset = num_c * 16 * ub_mod + add_zu * 8 * 16
                    ub_offset = num_c * 16 + add_zu * 8 * 16 * col_len
                    repeat = 1
                    srcm0 = 1
                    dstm0 = col_len
                    srcm1 = 0
                    dstm1 = 0
                    mask_len = add_mod * 16
                    mask1, mask2 = _set_mask(mask_len)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)

            tvm_ib.emit(tvm.call_extern(
                dst.dtype, "set_vector_mask",
                tvm.const(-1, dtype="uint64"),
                tvm.const(-1, dtype="uint64")))

        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                res_offset = num_c * 16 * ub_mod
                ub_offset = num_c * 16
                n_burst = ub_mod
                burst_len = 1
                src_stride = 0
                dst_stride = col_len - 1
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        dst_offset = n_index * col_len * row_len \
                     + ub_loop * row_len_ub * col_len
        burst_len_dst = col_len * ub_mod // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _two_row_align_split_row_fp16_new(dst, data):
    """
    function of making ir node builder for row align split row fp16 new scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_row_align_split_row_fp16_new(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_row_align_split_row_fp16_new(args)

    return tvm_ib.get()


def _move_for_row_align_split_row_fp16_new_fencore(args):
    """
    function of moving data for row align split row fp16 new fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    cp_align_len, float_size, ub_ele, col_len, row_len, n_index,\
    row_len_ub, row_len_begin, row_len_now = args

    with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
        data_offset = n_index * col_len * row_len \
                      + num_c * row_len + row_len_begin
        ub_offset = num_c * row_len_now
        burst_len_data = row_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    dim_ele = col_len * row_len_now
    dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
    dim_zu = dim_ele_align // 16

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(col_len <= 31):
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            add_zu = row_len_now // 8
            add_mod = row_len_now % 8
            with tvm_ib.if_scope(add_zu > 0):
                res_offset = num_c * 16 * row_len_now
                ub_offset = num_c * 16
                repeat = add_zu
                srcm0 = 1
                dstm0 = col_len
                srcm1 = 8
                dstm1 = dstm0 * 8
                mask1, mask2 = _set_mask(128)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)
            with tvm_ib.if_scope(add_mod > 0):
                res_offset = num_c * 16 * row_len_now + add_zu * 8 * 16
                ub_offset = num_c * 16 + add_zu * 8 * 16 * col_len
                repeat = 1
                srcm0 = 1
                dstm0 = col_len
                srcm1 = 0
                dstm1 = 0
                mask_len = add_mod * 16
                mask1, mask2 = _set_mask(mask_len)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)

        tvm_ib.emit(tvm.call_extern(
            dst.dtype, "set_vector_mask",
            tvm.const(-1, dtype="uint64"),
            tvm.const(-1, dtype="uint64")))

    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            res_offset = num_c * 16 * row_len_now
            ub_offset = num_c * 16
            n_burst = row_len_now
            burst_len = 1
            src_stride = 0
            dst_stride = col_len - 1
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    dst_offset = n_index * col_len * row_len \
                 + row_len_begin * col_len
    burst_len_dst = col_len * row_len_now // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, 1, burst_len_dst, 0, 0))


def _func_two_row_align_split_row_fp16_new_fencore_nomod(args):
    """
    function for row align split row fp16 new fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    row_len_now = row_len_ub
    row_len_begin = fen_index * row_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, cp_align_len, float_size, ub_ele, \
           col_len, row_len, n_index, row_len_ub, \
           row_len_begin, row_len_now
    _move_for_row_align_split_row_fp16_new_fencore(args)


def _func_two_row_align_split_row_fp16_new_fencore_mod(args):
    """
    function for row align split row fp16 new fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        row_len_now = row_len_ub
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, cp_align_len, float_size, ub_ele,\
               col_len, row_len, n_index, row_len_ub,\
               row_len_begin, row_len_now
        _move_for_row_align_split_row_fp16_new_fencore(args)
    with tvm_ib.else_scope():
        row_len_now = ub_mod
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, cp_align_len, float_size, ub_ele, \
               col_len, row_len, n_index, row_len_ub, \
               row_len_begin, row_len_now
        _move_for_row_align_split_row_fp16_new_fencore(args)


def _two_row_align_split_row_fp16_new_fencore(dst, data):
    """
    function of making ir node builder
    for row align split row fp16 new fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    new_space_ele_split_row = _ceil_fill(col_len * 16, 16) * 16
    num_row_len_ub = ub_ele // new_space_ele_split_row
    row_len_ub = num_row_len_ub * 16
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_row_align_split_row_fp16_new_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_row_align_split_row_fp16_new_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_row_align_split_row_fp16_new_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_row_align_split_row_fp16_new_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_row_align_split_col_fp16(args):
    """
    function of moving data for row align split col fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    col_len_ub = (ub_ele // row_len // cp_align_len) * cp_align_len
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:

        data_offset = n_index * col_len * row_len\
                      + num_u * col_len_ub * row_len
        burst_len_data = (col_len_ub * row_len) // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        c_zu = col_len_ub // 16
        r_zu = row_len // 16
        with tvm_ib.if_scope(row_len >= col_len_ub):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len_ub * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        with tvm_ib.for_range(0, row_len, name="num_rl") as num_rl:
            dst_offset = n_index * col_len * row_len\
                         + num_rl * col_len + num_u * col_len_ub
            res_offset = num_rl * col_len_ub
            burst_len_dst = col_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r",
                                            offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        col_len_mod_begin = col_len - ub_mod_align

        data_offset = n_index * col_len * row_len\
                      + col_len_mod_begin * row_len
        burst_len_data = (ub_mod_align * row_len) // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        c_zu = ub_mod_align // 16
        r_zu = row_len // 16
        with tvm_ib.if_scope(row_len >= ub_mod_align):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_mod_align * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        with tvm_ib.for_range(0, row_len, name="num_rl") as num_rl:
            dst_offset = n_index * col_len * row_len\
                         + num_rl * col_len + col_len_mod_begin
            res_offset = num_rl * ub_mod_align
            burst_len_dst = ub_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r",
                                            offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _two_row_align_split_col_fp16(dst, data):
    """
    function of making ir node builder for row align split col fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_row_align_split_col_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_row_align_split_col_fp16(args)

    return tvm_ib.get()


def _move_for_row_align_split_col_fp16_fencore(args):
    """
    function of moving data for row align split col fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    ub_ele, cp_align_len, float_size, col_len, row_len, n_index,\
    col_len_ub, col_len_begin, col_len_now = args

    data_offset = n_index * col_len * row_len \
                  + col_len_begin * row_len
    burst_len_data = (col_len_now * row_len) // cp_align_len
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    c_zu = col_len_now // 16
    r_zu = row_len // 16
    with tvm_ib.if_scope(row_len >= col_len_now):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len_now * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    with tvm_ib.for_range(0, row_len, name="num_rl") as num_rl:
        dst_offset = n_index * col_len * row_len \
                     + num_rl * col_len + col_len_begin
        res_offset = num_rl * col_len_now
        burst_len_dst = col_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r",
                                                        offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))


def _func_two_row_align_split_col_fp16_fencore_nomod(args):
    """
    function for row align split col fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)


    col_len_now = col_len_ub
    col_len_begin = fen_index * col_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, ub_ele, cp_align_len, float_size, \
           col_len, row_len, n_index, col_len_ub, \
           col_len_begin, col_len_now
    _move_for_row_align_split_col_fp16_fencore(args)


def _func_two_row_align_split_col_fp16_fencore_mod(args):
    """
    function for row align split col fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        col_len_now = col_len_ub
        col_len_begin = fen_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, ub_ele, cp_align_len, float_size,\
               col_len, row_len, n_index, col_len_ub,\
               col_len_begin, col_len_now
        _move_for_row_align_split_col_fp16_fencore(args)

    with tvm_ib.else_scope():
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        col_len_now = ub_mod_align
        col_len_begin = col_len - ub_mod_align
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, cp_align_len, float_size, \
               col_len, row_len, n_index, col_len_ub, \
               col_len_begin, col_len_now
        _move_for_row_align_split_col_fp16_fencore(args)


def _two_row_align_split_col_fp16_fencore(dst, data):
    """
    function of making ir node builder
    for row align split col fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    col_len_ub = (ub_ele // row_len // cp_align_len) * cp_align_len
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_row_align_split_col_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_row_align_split_col_fp16_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_row_align_split_col_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_row_align_split_col_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_row_align_large_fp16(args):
    """
    function of moving data for row align large fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    row_zu = row_len // 16
    col_16_ele = col_len * 16
    ub_loop = col_16_ele // ub_ele
    ub_mod = col_16_ele % ub_ele
    ub_col = ub_ele // 16
    row_ub = 16
    ub_col_mod = ub_mod // 16

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, row_zu, name="num_rowz") as num_rowz:
        with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:

            data_offset = n_index * col_len * row_len\
                          + num_u * ub_col * row_len + num_rowz * row_ub
            n_burst = ub_col
            burst_len_data = row_ub // cp_align_len
            src_stride = (row_len - row_ub) // cp_align_len
            args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
                   burst_len_data, src_stride, 0, cp_align_len
            _func_gm_to_ub_align(args)

            c_zu = ub_col // 16
            r_zu = row_ub // 16
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_col * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

            with tvm_ib.for_range(0, row_ub, name="num_ru") as num_ru:
                dst_offset = n_index * col_len * row_len\
                             + (num_rowz * row_ub + num_ru) * col_len\
                             + num_u * ub_col
                res_offset = num_ru * ub_col
                burst_len_dst = ub_col // cp_align_len
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r",
                                                offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))

        with tvm_ib.if_scope(ub_col_mod > 0):
            ub_col_mod_align = _ceil_fill(ub_col_mod, cp_align_len)
            col_mod_begin = col_len - ub_col_mod_align

            data_offset = n_index * col_len * row_len \
                          + col_mod_begin * row_len + num_rowz * row_ub
            n_burst = ub_col_mod
            burst_len_data = row_ub // cp_align_len
            src_stride = (row_len - row_ub) // cp_align_len
            args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
                   burst_len_data, src_stride, 0, cp_align_len
            _func_gm_to_ub_align(args)

            c_zu = ub_col_mod_align // 16
            r_zu = row_ub // 16
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_col_mod_align * 16)\
                            * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

            with tvm_ib.for_range(0, row_ub, name="num_ru") as num_ru:
                dst_offset = n_index * col_len * row_len \
                             + (num_rowz * row_ub + num_ru) * col_len \
                             + col_mod_begin
                res_offset = num_ru * ub_col_mod_align
                burst_len_dst = ub_col_mod_align // cp_align_len
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r",
                                                offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))


def _two_row_align_large_fp16(dst, data):
    """
    function of making ir node builder for row align large fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_row_align_large_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_row_align_large_fp16(args)

    return tvm_ib.get()


def _func_two_row_align_large_fp16_fencore(args):
    """
    function of moving data for row align large fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    row_zu = row_len // 16
    col_16_ele = col_len * 16
    ub_loop = col_16_ele // ub_ele
    ub_mod = col_16_ele % ub_ele
    ub_col = ub_ele // 16
    row_ub = 16
    ub_col_mod = ub_mod // 16

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, row_zu, name="num_rowz") as num_rowz:
        with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
            data_offset = n_index * col_len * row_len\
                          + num_u * ub_col * row_len + num_rowz * row_ub
            n_burst = ub_col
            burst_len_data = row_ub // cp_align_len
            src_stride = (row_len - row_ub) // cp_align_len
            args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
                   burst_len_data, src_stride, 0, cp_align_len
            _func_gm_to_ub_align(args)

            c_zu = ub_col // 16
            r_zu = row_ub // 16
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_col * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

            with tvm_ib.for_range(0, row_ub, name="num_ru") as num_ru:
                dst_offset = n_index * col_len * row_len\
                             + (num_rowz * row_ub + num_ru) * col_len\
                             + num_u * ub_col
                res_offset = num_ru * ub_col
                burst_len_dst = ub_col // cp_align_len
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r",
                                                offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))

        with tvm_ib.if_scope(ub_col_mod > 0):
            ub_col_mod_align = _ceil_fill(ub_col_mod, cp_align_len)
            col_mod_begin = col_len - ub_col_mod_align

            data_offset = n_index * col_len * row_len \
                          + col_mod_begin * row_len + num_rowz * row_ub
            n_burst = ub_col_mod
            burst_len_data = row_ub // cp_align_len
            src_stride = (row_len - row_ub) // cp_align_len
            args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
                   burst_len_data, src_stride, 0, cp_align_len
            _func_gm_to_ub_align(args)

            c_zu = ub_col_mod_align // 16
            r_zu = row_ub // 16
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_col_mod_align * 16)\
                            * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

            with tvm_ib.for_range(0, row_ub, name="num_ru") as num_ru:
                dst_offset = n_index * col_len * row_len \
                             + (num_rowz * row_ub + num_ru) * col_len \
                             + col_mod_begin
                res_offset = num_ru * ub_col_mod_align
                burst_len_dst = ub_col_mod_align // cp_align_len
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r",
                                                offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))


def _move_for_row_align_large_fp16_fencore(args):
    """
    function of moving data for row align large fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, \
    addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
    row_len, n_index, row_index, row_ub, col_len_now, col_len_begin = args

    data_offset = n_index * col_len * row_len \
                  + col_len_begin * row_len + row_index * row_ub
    n_burst = col_len_now
    burst_len_data = row_ub // cp_align_len
    src_stride = (row_len - row_ub) // cp_align_len
    args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
           burst_len_data, src_stride, 0, cp_align_len
    _func_gm_to_ub_align(args)

    c_zu = col_len_now // 16
    r_zu = row_ub // 16
    with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
        one_begin = (num_rz * 16) * float_size
        two_begin = (ub_ele + num_rz * col_len_now * 16) * float_size
        repeat_vconv = c_zu
        src_stride_vconv = 16 * r_zu
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, \
               two_begin, repeat_vconv, src_stride_vconv, \
               dst_stride_vconv, r_zu, c_zu
        _vconv_one(args)

    with tvm_ib.for_range(0, row_ub, name="num_ru") as num_ru:
        dst_offset = n_index * col_len * row_len \
                     + (row_index * row_ub + num_ru) * col_len \
                     + col_len_begin
        res_offset = num_ru * col_len_now
        burst_len_dst = col_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r",
                                                        offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))


def _func_two_row_align_large_fp16_fencore_nomod(args):
    """
    function for row align large fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_zu, \
    row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    col_len_now = ub_col
    col_len_begin = col_index * ub_col
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
           row_len, n_index, row_index, row_ub, col_len_now, col_len_begin
    _move_for_row_align_large_fp16_fencore(args)


def _func_two_row_align_large_fp16_fencore_mod(args):
    """
    function of moving data for row align large fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_zu, \
    row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(col_index < col_fen - 1):
        col_len_now = ub_col
        col_len_begin = col_index * ub_col
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len,\
               row_len, n_index, row_index, row_ub, col_len_now, col_len_begin
        _move_for_row_align_large_fp16_fencore(args)
    with tvm_ib.else_scope():
        ub_col_mod_align = _ceil_fill(ub_col_mod, cp_align_len)
        col_len_now = ub_col_mod_align
        col_len_begin = col_len - col_len_now
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
               row_len, n_index, row_index, row_ub, col_len_now, col_len_begin
        _move_for_row_align_large_fp16_fencore(args)


def _two_row_align_large_fp16_fencore(dst, data):
    """
    function of making ir node builder for row align large fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    row_zu = row_len // 16
    col_16_ele = col_len * 16
    ub_loop = col_16_ele // ub_ele
    ub_mod = col_16_ele % ub_ele
    ub_col = ub_ele // 16
    row_ub = 16
    ub_col_mod = ub_mod // 16

    with tvm_ib.if_scope(ub_col_mod > 0):
        col_fen = ub_loop + 1
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_zu, \
                   row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, num_g
            _func_two_row_align_large_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_zu, \
                   row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, num_g
                _func_two_row_align_large_fp16_fencore_mod(args)
    with tvm_ib.else_scope():
        col_fen = ub_loop
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_zu, \
                   row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, num_g
            _func_two_row_align_large_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, row_zu, \
                       row_ub, fen_n, ub_loop, ub_col, ub_col_mod,\
                       col_fen, num_g
                _func_two_row_align_large_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _vconv_one_not_align(args):
    """
    function of vnchwconv for one _func_vconv_fp16

    """
    tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
    repeat_vconv, src_stride_vconv, dst_stride_vconv, r_zu = args

    src0_offset = 8 * 0
    src1_offset = 8 * 1
    dst0_offset = 8 * 2
    dst1_offset = 8 * 3
    src_gap = 32 * r_zu
    src_eight_gap = src_gap * 8
    dst_gap = 32
    dst_eight_gap = dst_gap * 8

    with tvm_ib.for_range(0, 8, name="i") as i:
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src0_offset + i]),
                                    one_begin + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src1_offset + i]),
                                    one_begin + src_eight_gap
                                    + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst0_offset + i]),
                                    two_begin + i * dst_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst1_offset + i]),
                                    two_begin + dst_eight_gap
                                    + i * dst_gap))

    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA0",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA1",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src1_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA2",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA3",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst1_offset)))
    with tvm_ib.if_scope(repeat_vconv == 1):
        tvm_ib.emit(tvm.call_extern("int32",
                                    "scatter_vnchwconv_b16",
                                    "VA2",
                                    "VA0",
                                    1,
                                    0,
                                    0))
    with tvm_ib.else_scope():
        tvm_ib.emit(tvm.call_extern("int32",
                                    "scatter_vnchwconv_b16",
                                    "VA2",
                                    "VA0",
                                    repeat_vconv,
                                    dst_stride_vconv,
                                    src_stride_vconv))


def _vconv_two_not_align(args):
    """
    function of vnchwconv for two _func_vconv_fp16

    """
    tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
    repeat_vconv, src_stride_vconv, dst_stride_vconv = args

    src0_offset = 8 * 0
    src1_offset = 8 * 1
    dst0_offset = 8 * 2
    dst1_offset = 8 * 3
    src_gap = 32
    src_eight_gap = src_gap * 8
    dst_gap = 32
    dst_eight_gap = dst_gap * 8

    with tvm_ib.for_range(0, 8, name="i") as i:
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src0_offset + i]),
                                    one_begin + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src1_offset + i]),
                                    one_begin + src_eight_gap
                                    + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst0_offset + i]),
                                    two_begin + i * dst_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst1_offset + i]),
                                    two_begin + dst_eight_gap
                                    + i * dst_gap))

    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA0",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA1",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src1_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA2",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA3",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst1_offset)))
    with tvm_ib.if_scope(repeat_vconv == 1):
        tvm_ib.emit(tvm.call_extern("int32",
                                    "scatter_vnchwconv_b16",
                                    "VA2",
                                    "VA0",
                                    1,
                                    0,
                                    0))
    with tvm_ib.else_scope():
        tvm_ib.emit(tvm.call_extern("int32",
                                    "scatter_vnchwconv_b16",
                                    "VA2",
                                    "VA0",
                                    repeat_vconv,
                                    dst_stride_vconv,
                                    src_stride_vconv))


def _func_two_not_align_small_fp16(args):
    """
    function of moving data for not align small fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    dim_ele = col_len * row_len
    dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
    dim_zu = dim_ele_align // 16

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    data_offset = n_index * col_len * row_len
    burst_len_data = _ceil_div(dim_ele, cp_align_len)
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(row_len <= 31):
        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            add_zu = col_len // 8
            add_mod = col_len % 8
            with tvm_ib.if_scope(add_zu > 0):
                res_offset = num_r * 16
                ub_offset = num_r * 16 * col_len
                repeat = add_zu
                srcm0 = row_len
                dstm0 = 1
                srcm1 = srcm0 * 8
                dstm1 = 8
                mask1, mask2 = _set_mask(128)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)
            with tvm_ib.if_scope(add_mod > 0):
                res_offset = num_r * 16 + add_zu * 8 * 16 * row_len
                ub_offset = num_r * 16 * col_len + add_zu * 8 * 16
                repeat = 1
                srcm0 = row_len
                dstm0 = 1
                srcm1 = 0
                dstm1 = 0
                mask_len = add_mod * 16
                mask1, mask2 = _set_mask(mask_len)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)

        tvm_ib.emit(tvm.call_extern(
            dst.dtype, "set_vector_mask",
            tvm.const(-1, dtype="uint64"),
            tvm.const(-1, dtype="uint64")))

    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * col_len
            n_burst = col_len
            burst_len = 1
            src_stride = row_len - 1
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(dim_ele % cp_align_len > 0):
        dim_ele_sub = dim_ele - cp_align_len
        dst_offset = n_index * col_len * row_len
        burst_len = _ceil_div(dim_ele_sub, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len, 0, 0))
        with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_res.access_ptr(
                    'r',
                    offset=dim_ele_sub + num_a)
            ))
            tvm_ib.emit(tvm.call_extern(
                data_tail.dtype, "reg_mov",
                data_tail.access_ptr('w', offset=num_a),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr(
                                        'w',
                                        offset=dst_offset + dim_ele_sub),
                                    data_tail.access_ptr("r", offset=0),
                                    0, 1, 1, 0, 0))

    with tvm_ib.else_scope():
        dst_offset = n_index * col_len * row_len
        burst_len_dst = dim_ele // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _two_not_align_small_fp16(dst, data):
    """
    function of making ir node builder for not align small fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_not_align_small_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_not_align_small_fp16(args)

    return tvm_ib.get()


def _func_two_not_align_small_multidim_fp16(args):
    """
    function of moving data for not align small multidim fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
    addr_array, addr_array_buf, device_core_num, block_index,\
    cp_align_len, float_size, ub_ele, num_dim_ub, num_g, num_dim_cur = args

    n_i, col_len, row_len = data.shape
    n_index = num_g * device_core_num + block_index

    cur_ele = num_dim_cur * col_len * row_len
    data_offset = n_index * num_dim_ub * col_len * row_len
    burst_len_data = _ceil_div(cur_ele, cp_align_len)
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    cur_ele_align = _ceil_fill(cur_ele, 16)
    cur_ele_div = cur_ele_align // 16
    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = cur_ele_div
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, num_dim_cur, name="num_d") as num_d:
        with tvm_ib.for_range(0, col_len, name="num_cl") as num_cl:
            res_offset = num_d * col_len * row_len * cp_align_len\
                         + num_cl * row_len * cp_align_len
            ub_offset = num_d * col_len * row_len * cp_align_len\
                        + num_cl * cp_align_len
            n_burst = row_len
            burst_len = 1
            dst_stride = col_len - 1
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                0, dst_stride))

    cur_ele_align = _ceil_fill(cur_ele, 16)
    cur_ele_div = cur_ele_align // 16
    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = cur_ele_div
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(cur_ele % cp_align_len > 0):
        with tvm_ib.if_scope(cur_ele > cp_align_len):
            move_len = cur_ele - cp_align_len
            dst_offset = n_index * num_dim_ub * col_len * row_len
            burst_len = _ceil_div(move_len, cp_align_len)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len, 0, 0))
            with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
                tvm_ib.emit(tvm.call_extern(
                    data_res.dtype, "reg_mov",
                    tvm.call_extern(reg.dtype, "reg", reg[0]),
                    data_res.access_ptr(
                        'r',
                        offset=move_len + num_a)
                ))
                tvm_ib.emit(tvm.call_extern(
                    data_tail.dtype, "reg_mov",
                    data_tail.access_ptr('w', offset=num_a),
                    tvm.call_extern(reg.dtype, "reg", reg[0])
                ))
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr(
                                            'w',
                                            offset=(dst_offset + move_len)),
                                        data_tail.access_ptr("r", offset=0),
                                        0, 1, 1, 0, 0))

        with tvm_ib.else_scope():
            dst_offset = n_index * num_dim_ub * col_len * row_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, 1, 0, 0))
    with tvm_ib.else_scope():
        dst_offset = n_index * num_dim_ub * col_len * row_len
        burst_len = cur_ele // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len, 0, 0))


def _two_not_align_small_multidim_fp16(dst, data):
    """
    function of making ir node builder for not align small multidim fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    dim_ele = _ceil_fill(col_len * row_len, 16) * 16
    num_dim_ub = ub_ele // dim_ele
    core_full = n_i // num_dim_ub
    num_dim_mod = n_i % num_dim_ub

    group_index = core_full // device_core_num
    group_mod = core_full % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, device_core_num, block_index,\
               cp_align_len, float_size, ub_ele, num_dim_ub, num_g, num_dim_ub
        _func_two_not_align_small_multidim_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, device_core_num, block_index, \
                   cp_align_len, float_size, ub_ele, num_dim_ub,\
                   group_index, num_dim_ub
            _func_two_not_align_small_multidim_fp16(args)

    with tvm_ib.if_scope(num_dim_mod > 0):
        core_mod = core_full
        core_group = core_mod // device_core_num
        core_block = core_mod % device_core_num

        with tvm_ib.if_scope(tvm.all(block_index > (core_block - 1),
                                     block_index < (core_block + 1))):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, device_core_num, block_index, \
                   cp_align_len, float_size, ub_ele, num_dim_ub, \
                   core_group, num_dim_mod
            _func_two_not_align_small_multidim_fp16(args)

    return tvm_ib.get()


def _func_two_not_align_split_row_fp16_new(args):
    """
    function of moving data for not align split row fp16 new scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    new_space_ele_split_row = _ceil_fill(col_len * 16, 16) * 16
    num_row_len_ub = ub_ele // new_space_ele_split_row
    row_len_ub = 16 * num_row_len_ub

    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len\
                          + num_c * row_len + num_u * row_len_ub
            ub_offset = num_c * row_len_ub
            burst_len_data = row_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = col_len * row_len_ub
        dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
        dim_zu = dim_ele_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.if_scope(col_len <= 31):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                add_zu = row_len_ub // 8
                add_mod = row_len_ub % 8
                with tvm_ib.if_scope(add_zu > 0):
                    res_offset = num_c * 16 * row_len_ub
                    ub_offset = num_c * 16
                    repeat = add_zu
                    srcm0 = 1
                    dstm0 = col_len
                    srcm1 = 8
                    dstm1 = dstm0 * 8
                    mask1, mask2 = _set_mask(128)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)
                with tvm_ib.if_scope(add_mod > 0):
                    res_offset = num_c * 16 * row_len_ub + add_zu * 8 * 16
                    ub_offset = num_c * 16 + add_zu * 8 * 16 * col_len
                    repeat = 1
                    srcm0 = 1
                    dstm0 = col_len
                    srcm1 = 0
                    dstm1 = 0
                    mask_len = add_mod * 16
                    mask1, mask2 = _set_mask(mask_len)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)

            tvm_ib.emit(tvm.call_extern(
                dst.dtype, "set_vector_mask",
                tvm.const(-1, dtype="uint64"),
                tvm.const(-1, dtype="uint64")))

        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                res_offset = num_c * 16 * row_len_ub
                ub_offset = num_c * 16
                n_burst = row_len_ub
                burst_len = 1
                src_stride = 0
                dst_stride = col_len - 1
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        dst_offset = n_index * col_len * row_len \
                     + num_u * row_len_ub * col_len
        burst_len_dst = col_len * row_len_ub // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))
    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        ub_mod_begin = row_len - ub_mod_align

        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len\
                          + num_c * row_len + ub_mod_begin
            ub_offset = num_c * ub_mod_align
            burst_len_data = ub_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = col_len * ub_mod_align
        dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
        dim_zu = dim_ele_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.if_scope(col_len <= 31):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                add_zu = ub_mod_align // 8
                add_mod = ub_mod_align % 8
                with tvm_ib.if_scope(add_zu > 0):
                    res_offset = num_c * 16 * ub_mod_align
                    ub_offset = num_c * 16
                    repeat = add_zu
                    srcm0 = 1
                    dstm0 = col_len
                    srcm1 = 8
                    dstm1 = dstm0 * 8
                    mask1, mask2 = _set_mask(128)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)
                with tvm_ib.if_scope(add_mod > 0):
                    res_offset = num_c * 16 * ub_mod_align + add_zu * 8 * 16
                    ub_offset = num_c * 16 + add_zu * 8 * 16 * col_len
                    repeat = 1
                    srcm0 = 1
                    dstm0 = col_len
                    srcm1 = 0
                    dstm1 = 0
                    mask_len = add_mod * 16
                    mask1, mask2 = _set_mask(mask_len)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)

            tvm_ib.emit(tvm.call_extern(
                dst.dtype, "set_vector_mask",
                tvm.const(-1, dtype="uint64"),
                tvm.const(-1, dtype="uint64")))

        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                res_offset = num_c * 16 * ub_mod_align
                ub_offset = num_c * 16
                n_burst = ub_mod_align
                burst_len = 1
                src_stride = 0
                dst_stride = col_len - 1
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        dst_offset = n_index * col_len * row_len \
                     + ub_mod_begin * col_len
        burst_len_dst = col_len * ub_mod_align // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _two_not_align_split_row_fp16_new(dst, data):
    """
    function of making ir node builder for not align split row fp16 new scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_not_align_split_row_fp16_new(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_not_align_split_row_fp16_new(args)

    return tvm_ib.get()


def _move_for_not_align_split_row_fp16_new_fencore(args):
    """
    function of moving data for not align split row fp16 new fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    float_size, cp_align_len, ub_ele, n_index, col_len,\
    row_len, row_len_ub, row_len_begin, row_len_now = args

    with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
        data_offset = n_index * col_len * row_len \
                      + num_c * row_len + row_len_begin
        ub_offset = num_c * row_len_now
        burst_len_data = row_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    dim_ele = col_len * row_len_now
    dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
    dim_zu = dim_ele_align // 16

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(col_len <= 31):
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            add_zu = row_len_now // 8
            add_mod = row_len_now % 8
            with tvm_ib.if_scope(add_zu > 0):
                res_offset = num_c * 16 * row_len_now
                ub_offset = num_c * 16
                repeat = add_zu
                srcm0 = 1
                dstm0 = col_len
                srcm1 = 8
                dstm1 = dstm0 * 8
                mask1, mask2 = _set_mask(128)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)
            with tvm_ib.if_scope(add_mod > 0):
                res_offset = num_c * 16 * row_len_now + add_zu * 8 * 16
                ub_offset = num_c * 16 + add_zu * 8 * 16 * col_len
                repeat = 1
                srcm0 = 1
                dstm0 = col_len
                srcm1 = 0
                dstm1 = 0
                mask_len = add_mod * 16
                mask1, mask2 = _set_mask(mask_len)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)

        tvm_ib.emit(tvm.call_extern(
            dst.dtype, "set_vector_mask",
            tvm.const(-1, dtype="uint64"),
            tvm.const(-1, dtype="uint64")))

    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            res_offset = num_c * 16 * row_len_now
            ub_offset = num_c * 16
            n_burst = row_len_now
            burst_len = 1
            src_stride = 0
            dst_stride = col_len - 1
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    dst_offset = n_index * col_len * row_len \
                 + row_len_begin * col_len
    burst_len_dst = col_len * row_len_now // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, 1, burst_len_dst, 0, 0))


def _func_two_not_align_split_row_fp16_new_fencore_nomod(args):
    """
    function for not align split row fp16 new fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    row_len_now = row_len_ub
    row_len_begin = fen_index * row_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, float_size, cp_align_len, ub_ele, \
           n_index, col_len, row_len, row_len_ub, \
           row_len_begin, row_len_now
    _move_for_not_align_split_row_fp16_new_fencore(args)


def _func_two_not_align_split_row_fp16_new_fencore_mod(args):
    """
    function for not align split row fp16 new fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        row_len_now = row_len_ub
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, float_size, cp_align_len, ub_ele,\
               n_index, col_len, row_len, row_len_ub,\
               row_len_begin, row_len_now
        _move_for_not_align_split_row_fp16_new_fencore(args)
    with tvm_ib.else_scope():
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        row_len_now = ub_mod_align
        row_len_begin = row_len - row_len_now
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, float_size, cp_align_len, ub_ele, \
               n_index, col_len, row_len, row_len_ub, \
               row_len_begin, row_len_now
        _move_for_not_align_split_row_fp16_new_fencore(args)


def _two_not_align_split_row_fp16_new_fencore(dst, data):
    """
    function of making ir node builder
    for not align split row fp16 new fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    new_space_ele_split_row = _ceil_fill(col_len * 16, 16) * 16
    num_row_len_ub = ub_ele // new_space_ele_split_row
    row_len_ub = 16 * num_row_len_ub
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_not_align_split_row_fp16_new_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_not_align_split_row_fp16_new_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_not_align_split_row_fp16_new_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_not_align_split_row_fp16_new_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_not_align_split_row_fp16(args):
    """
    function of moving data for not align split row fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    col_len_align = _ceil_fill(col_len, cp_align_len)

    row_len_ub = (ub_ele // col_len_align // cp_align_len) * cp_align_len
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    n_index = num_g * device_core_num + block_index
    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len\
                          + num_c * row_len + num_u * row_len_ub
            ub_offset = num_c * row_len_ub
            burst_len_data = row_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = col_len_align // 16
        r_zu = row_len_ub // 16
        with tvm_ib.if_scope(row_len_ub >= col_len_align):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len_ub * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len_align * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        with tvm_ib.if_scope(ub_mod > 0):
            with tvm_ib.for_range(0, row_len_ub, name="num_rl") as num_rl:
                dst_offset = n_index * col_len * row_len\
                             + (num_u * row_len_ub + num_rl) * col_len
                res_offset = num_rl * col_len_align
                burst_len_dst = _ceil_div(col_len, cp_align_len)
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))
        with tvm_ib.else_scope():
            with tvm_ib.if_scope(num_u < ub_loop - 1):
                with tvm_ib.for_range(0, row_len_ub, name="num_rl") as num_rl:
                    dst_offset = n_index * col_len * row_len \
                                 + (num_u * row_len_ub + num_rl) * col_len
                    res_offset = num_rl * col_len_align
                    burst_len_dst = _ceil_div(col_len, cp_align_len)
                    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w',
                                                    offset=dst_offset),
                                                data_res.access_ptr(
                                                    "r", offset=res_offset),
                                                0, 1, burst_len_dst, 0, 0))

            with tvm_ib.else_scope():
                with tvm_ib.for_range(0, (row_len_ub - 1), name="num_rl")\
                        as num_rl:
                    dst_offset = n_index * col_len * row_len \
                                 + (num_u * row_len_ub + num_rl) * col_len
                    res_offset = num_rl * col_len_align
                    burst_len_dst = _ceil_div(col_len, cp_align_len)
                    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w',
                                                    offset=dst_offset),
                                                data_res.access_ptr(
                                                    "r", offset=res_offset),
                                                0, 1, burst_len_dst, 0, 0))

                move_len = col_len - cp_align_len
                dst_offset = n_index * col_len * row_len \
                             + (num_u * row_len_ub + row_len_ub - 1) * col_len
                res_offset = (row_len_ub - 1) * col_len_align
                burst_len_dst = _ceil_div(move_len, cp_align_len)
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))
                with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
                    tvm_ib.emit(tvm.call_extern(
                        data_res.dtype, "reg_mov",
                        tvm.call_extern(reg.dtype, "reg", reg[0]),
                        data_res.access_ptr(
                            'r',
                            offset=((row_len_ub - 1) * col_len_align
                                    + move_len + num_a))
                    ))
                    tvm_ib.emit(tvm.call_extern(
                        data_tail.dtype, "reg_mov",
                        data_tail.access_ptr(
                            'w', offset=num_a),
                        tvm.call_extern(reg.dtype, "reg", reg[0])
                    ))
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w',
                                                offset=dst_offset + move_len),
                                            data_tail.access_ptr(
                                                "r", offset=res_offset),
                                            0, 1, 1, 0, 0))
    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        ub_mod_begin = row_len - ub_mod_align

        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len \
                          + num_c * row_len + ub_mod_begin
            ub_offset = num_c * ub_mod_align
            burst_len_data = ub_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = col_len_align // 16
        r_zu = ub_mod_align // 16
        with tvm_ib.if_scope(ub_mod_align >= col_len_align):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * ub_mod_align * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len_align * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        with tvm_ib.for_range(0, (ub_mod_align - 1), name="num_rl") as num_rl:
            dst_offset = n_index * col_len * row_len \
                         + (ub_mod_begin + num_rl) * col_len
            res_offset = num_rl * col_len_align
            burst_len_dst = _ceil_div(col_len, cp_align_len)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

        move_len = col_len - cp_align_len
        dst_offset = n_index * col_len * row_len \
                     + (ub_mod_begin + ub_mod_align - 1) * col_len
        res_offset = (ub_mod_align - 1) * col_len_align
        burst_len_dst = _ceil_div(move_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))
        with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_res.access_ptr(
                    'r',
                    offset=((ub_mod_align - 1) * col_len_align
                            + move_len + num_a))
            ))
            tvm_ib.emit(tvm.call_extern(
                data_tail.dtype, "reg_mov",
                data_tail.access_ptr(
                    'w', offset=num_a),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr(
                                        'w',
                                        offset=dst_offset + move_len),
                                    data_tail.access_ptr(
                                        "r", offset=0),
                                    0, 1, 1, 0, 0))


def _two_not_align_split_row_fp16(dst, data):
    """
    function of making ir node builder for not align split row fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_not_align_split_row_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_not_align_split_row_fp16(args)

    return tvm_ib.get()


def _move_for_not_align_split_row_fp16_fencore(args):
    """
    function of moving data for not align split row fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array, \
    addr_array_buf, float_size, cp_align_len, ub_ele, \
    n_index, col_len, row_len, row_len_ub, \
    row_len_begin, row_len_now = args

    col_len_align = _ceil_fill(col_len, cp_align_len)

    with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
        data_offset = n_index * col_len * row_len \
                      + num_c * row_len + row_len_begin
        ub_offset = num_c * row_len_now
        burst_len_data = row_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    c_zu = col_len_align // 16
    r_zu = row_len_now // 16
    with tvm_ib.if_scope(row_len_now >= col_len_align):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len_now * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len_align * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    with tvm_ib.for_range(0, (row_len_now - 1), name="num_rl") as num_rl:
        dst_offset = n_index * col_len * row_len \
                     + (row_len_begin + num_rl) * col_len
        res_offset = num_rl * col_len_align
        burst_len_dst = _ceil_div(col_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))

    move_len = col_len - cp_align_len
    dst_offset = n_index * col_len * row_len \
                 + (row_len_begin + row_len_now - 1) * col_len
    res_offset = (row_len_now - 1) * col_len_align
    burst_len_dst = _ceil_div(move_len, cp_align_len)
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, 1, burst_len_dst, 0, 0))
    with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_res.access_ptr(
                'r', offset=((row_len_now - 1) * col_len_align
                             + move_len + num_a))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr(
                'w', offset=num_a),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset + move_len),
                                data_tail.access_ptr(
                                    "r", offset=0),
                                0, 1, 1, 0, 0))


def _func_two_not_align_split_row_fp16_fencore_nomod(args):
    """
    function for not align split row fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    row_len_now = row_len_ub
    row_len_begin = fen_index * row_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
           addr_array, addr_array_buf, float_size, cp_align_len, ub_ele, \
           n_index, col_len, row_len, row_len_ub, \
           row_len_begin, row_len_now
    _move_for_not_align_split_row_fp16_fencore(args)


def _func_two_not_align_split_row_fp16_fencore_mod(args):
    """
    function for not align split row fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        row_len_now = row_len_ub
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, float_size, cp_align_len, ub_ele, \
               n_index, col_len, row_len, row_len_ub,\
               row_len_begin, row_len_now
        _move_for_not_align_split_row_fp16_fencore(args)
    with tvm_ib.else_scope():
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        row_len_now = ub_mod_align
        row_len_begin = row_len - row_len_now
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, float_size, cp_align_len, ub_ele, \
               n_index, col_len, row_len, row_len_ub,\
               row_len_begin, row_len_now
        _move_for_not_align_split_row_fp16_fencore(args)


def _two_not_align_split_row_fp16_fencore(dst, data):
    """
    function of making ir node builder
    for not align split row fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    col_len_align = _ceil_fill(col_len, cp_align_len)

    row_len_ub = (ub_ele // col_len_align // cp_align_len) * cp_align_len
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_not_align_split_row_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_not_align_split_row_fp16_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_not_align_split_row_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_not_align_split_row_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_not_align_split_col_fp16(args):
    """
    function of moving data for not align split col fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)

    col_len_ub = (ub_ele // row_len_align // cp_align_len) * cp_align_len
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, col_len_ub, name="num_cl") as num_cl:
            data_offset = n_index * col_len * row_len \
                          + num_u * col_len_ub * row_len + num_cl * row_len
            ub_offset = num_cl * row_len_align
            burst_len_data = _ceil_div(row_len, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = col_len_ub // 16
        r_zu = row_len_align // 16
        with tvm_ib.if_scope(row_len_align >= col_len_ub):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len_align * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len_ub * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len\
                         + num_r * col_len + num_u * col_len_ub
            res_offset = num_r * col_len_ub
            burst_len_dst = col_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        ub_mod_begin = col_len - ub_mod_align
        with tvm_ib.for_range(0, ub_mod_align, name="num_cl") as num_cl:
            data_offset = n_index * col_len * row_len \
                          + ub_mod_begin * row_len + num_cl * row_len
            ub_offset = num_cl * row_len_align
            burst_len_data = _ceil_div(row_len, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = ub_mod_align // 16
        r_zu = row_len_align // 16
        with tvm_ib.if_scope(row_len_align >= ub_mod_align):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len_align * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_mod_align * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len\
                         + num_r * col_len + ub_mod_begin
            res_offset = num_r * ub_mod_align
            burst_len_dst = ub_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _two_not_align_split_col_fp16(dst, data):
    """
    function of making ir node builder for not align split col fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_not_align_split_col_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_not_align_split_col_fp16(args)

    return tvm_ib.get()


def _move_for_not_align_split_col_fp16_fencore(args):
    """
    function of moving data for not align split col fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, \
    addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
    col_len, row_len, col_len_begin, col_len_now = args

    row_len_align = _ceil_fill(row_len, cp_align_len)

    with tvm_ib.for_range(0, col_len_now, name="num_cl") as num_cl:
        data_offset = n_index * col_len * row_len \
                      + col_len_begin * row_len + num_cl * row_len
        ub_offset = num_cl * row_len_align
        burst_len_data = _ceil_div(row_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    c_zu = col_len_now // 16
    r_zu = row_len_align // 16
    with tvm_ib.if_scope(row_len_align >= col_len_now):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len_align * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len_now * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
        dst_offset = n_index * col_len * row_len \
                     + num_r * col_len + col_len_begin
        res_offset = num_r * col_len_now
        burst_len_dst = col_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))


def _func_two_not_align_split_col_fp16_fencore_nomod(args):
    """
    function for not align split col fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    col_len_now = col_len_ub
    col_len_begin = fen_index * col_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
           col_len, row_len, col_len_begin, col_len_now
    _move_for_not_align_split_col_fp16_fencore(args)


def _func_two_not_align_split_col_fp16_fencore_mod(args):
    """
    function for not align split col fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        col_len_now = col_len_ub
        col_len_begin = fen_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index,\
               col_len, row_len, col_len_begin, col_len_now
        _move_for_not_align_split_col_fp16_fencore(args)

    with tvm_ib.else_scope():
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        col_len_now = ub_mod_align
        col_len_begin = col_len - col_len_now
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
               col_len, row_len, col_len_begin, col_len_now
        _move_for_not_align_split_col_fp16_fencore(args)


def _two_not_align_split_col_fp16_fencore(dst, data):
    """
    function of making ir node builder
    for not align split col fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    row_len_align = _ceil_fill(row_len, cp_align_len)
    col_len_ub = (ub_ele // row_len_align // cp_align_len) * cp_align_len
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_not_align_split_col_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_not_align_split_col_fp16_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_not_align_split_col_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_not_align_split_col_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_not_align_split_col_fp16_new(args):
    """
    function of moving data for not align split col fp16 new scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    new_space_ele_split_col = _ceil_fill(row_len * 16, 16) * 16
    num_col_len_ub = ub_ele // new_space_ele_split_col
    col_len_ub = 16 * num_col_len_ub

    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        data_offset = n_index * col_len * row_len\
                      + num_u * col_len_ub * row_len
        burst_len_data = col_len_ub * row_len // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        dim_ele_align = col_len_ub * row_len
        dim_zu = dim_ele_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.if_scope(row_len <= 31):
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                add_zu = col_len_ub // 8
                add_mod = col_len_ub % 8
                with tvm_ib.if_scope(add_zu > 0):
                    res_offset = num_r * 16
                    ub_offset = num_r * 16 * col_len_ub
                    repeat = add_zu
                    srcm0 = row_len
                    dstm0 = 1
                    srcm1 = srcm0 * 8
                    dstm1 = 8
                    mask1, mask2 = _set_mask(128)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)
                with tvm_ib.if_scope(add_mod > 0):
                    res_offset = num_r * 16 + add_zu * 8 * 16 * row_len
                    ub_offset = num_r * 16 * col_len_ub + add_zu * 8 * 16
                    repeat = 1
                    srcm0 = row_len
                    dstm0 = 1
                    srcm1 = 0
                    dstm1 = 0
                    mask_len = add_mod * 16
                    mask1, mask2 = _set_mask(mask_len)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)

            tvm_ib.emit(tvm.call_extern(
                dst.dtype, "set_vector_mask",
                tvm.const(-1, dtype="uint64"),
                tvm.const(-1, dtype="uint64")))

        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                res_offset = num_r * 16
                ub_offset = num_r * 16 * col_len_ub
                n_burst = col_len_ub
                burst_len = 1
                src_stride = row_len - 1
                dst_stride = 0
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len\
                         + num_r * col_len + num_u * col_len_ub
            res_offset = num_r * col_len_ub
            burst_len_dst = col_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        ub_mod_begin = col_len - ub_mod_align

        data_offset = n_index * col_len * row_len \
                      + ub_mod_begin * row_len
        burst_len_data = ub_mod_align * row_len // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        dim_ele_align = ub_mod_align * row_len
        dim_zu = dim_ele_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.if_scope(row_len <= 31):
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                add_zu = ub_mod_align // 8
                add_mod = ub_mod_align % 8
                with tvm_ib.if_scope(add_zu > 0):
                    res_offset = num_r * 16
                    ub_offset = num_r * 16 * ub_mod_align
                    repeat = add_zu
                    srcm0 = row_len
                    dstm0 = 1
                    srcm1 = srcm0 * 8
                    dstm1 = 8
                    mask1, mask2 = _set_mask(128)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)
                with tvm_ib.if_scope(add_mod > 0):
                    res_offset = num_r * 16 + add_zu * 8 * 16 * row_len
                    ub_offset = num_r * 16 * ub_mod_align + add_zu * 8 * 16
                    repeat = 1
                    srcm0 = row_len
                    dstm0 = 1
                    srcm1 = 0
                    dstm1 = 0
                    mask_len = add_mod * 16
                    mask1, mask2 = _set_mask(mask_len)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)

            tvm_ib.emit(tvm.call_extern(
                dst.dtype, "set_vector_mask",
                tvm.const(-1, dtype="uint64"),
                tvm.const(-1, dtype="uint64")))

        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                res_offset = num_r * 16
                ub_offset = num_r * 16 * ub_mod_align
                n_burst = ub_mod_align
                burst_len = 1
                src_stride = row_len - 1
                dst_stride = 0
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len \
                         + num_r * col_len + ub_mod_begin
            res_offset = num_r * ub_mod_align
            burst_len_dst = ub_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _two_not_align_split_col_fp16_new(dst, data):
    """
    function of making ir node builder for not align split col fp16 new scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_not_align_split_col_fp16_new(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_not_align_split_col_fp16_new(args)

    return tvm_ib.get()


def _move_for_not_align_split_col_fp16_new_fencore(args):
    """
    function of moving data for not align split col fp16 new fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, \
    addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
    col_len, row_len, col_len_begin, col_len_now = args

    data_offset = n_index * col_len * row_len \
                  + col_len_begin * row_len
    burst_len_data = col_len_now * row_len // cp_align_len
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    dim_ele_align = col_len_now * row_len
    dim_zu = dim_ele_align // 16

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(row_len <= 31):
        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            add_zu = col_len_now // 8
            add_mod = col_len_now % 8
            with tvm_ib.if_scope(add_zu > 0):
                res_offset = num_r * 16
                ub_offset = num_r * 16 * col_len_now
                repeat = add_zu
                srcm0 = row_len
                dstm0 = 1
                srcm1 = srcm0 * 8
                dstm1 = 8
                mask1, mask2 = _set_mask(128)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)
            with tvm_ib.if_scope(add_mod > 0):
                res_offset = num_r * 16 + add_zu * 8 * 16 * row_len
                ub_offset = num_r * 16 * col_len_now + add_zu * 8 * 16
                repeat = 1
                srcm0 = row_len
                dstm0 = 1
                srcm1 = 0
                dstm1 = 0
                mask_len = add_mod * 16
                mask1, mask2 = _set_mask(mask_len)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)

        tvm_ib.emit(tvm.call_extern(
            dst.dtype, "set_vector_mask",
            tvm.const(-1, dtype="uint64"),
            tvm.const(-1, dtype="uint64")))

    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * col_len_now
            n_burst = col_len_now
            burst_len = 1
            src_stride = row_len - 1
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
        dst_offset = n_index * col_len * row_len \
                     + num_r * col_len + col_len_begin
        res_offset = num_r * col_len_now
        burst_len_dst = col_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))


def _func_two_not_align_split_col_fp16_new_fencore_nomod(args):
    """
    function for not align split col fp16 new fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    col_len_now = col_len_ub
    col_len_begin = fen_index * col_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
           col_len, row_len, col_len_begin, col_len_now
    _move_for_not_align_split_col_fp16_new_fencore(args)


def _func_two_not_align_split_col_fp16_new_fencore_mod(args):
    """
    function for not align split col fp16 new fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        col_len_now = col_len_ub
        col_len_begin = fen_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index,\
               col_len, row_len, col_len_begin, col_len_now
        _move_for_not_align_split_col_fp16_new_fencore(args)

    with tvm_ib.else_scope():
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        col_len_now = ub_mod_align
        col_len_begin = col_len - col_len_now
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
               col_len, row_len, col_len_begin, col_len_now
        _move_for_not_align_split_col_fp16_new_fencore(args)


def _two_not_align_split_col_fp16_new_fencore(dst, data):
    """
    function of making ir node builder
    for not align split col fp16 new fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    new_space_ele_split_col = _ceil_fill(row_len * 16, 16) * 16
    num_col_len_ub = ub_ele // new_space_ele_split_col
    col_len_ub = 16 * num_col_len_ub

    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_not_align_split_col_fp16_new_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_not_align_split_col_fp16_new_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_not_align_split_col_fp16_new_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_not_align_split_col_fp16_new_fencore_nomod(args)

    return tvm_ib.get()


def _move_data_large_not_align(args):
    """
    function of moving data for not align large scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    cp_align_len, col_len, row_len, ub_ele, float_size, row_ub, ub_loop,\
    ub_col, ub_col_mod, n_index, num_rowz, row_len_now = args

    row_len_now_align = _ceil_fill(row_len_now, cp_align_len)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, ub_col, name="num_uc") as num_uc:
            data_offset = n_index * col_len * row_len\
                          + (num_u * ub_col + num_uc) * row_len\
                          + num_rowz * row_ub
            ub_offset = num_uc * row_len_now_align
            burst_len_data = _ceil_div(row_len_now, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = ub_col // 16
        r_zu = row_len_now_align // 16
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * ub_col * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

        with tvm_ib.for_range(0, row_len_now, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len\
                         + (num_rowz * row_ub + num_r) * col_len\
                         + num_u * ub_col
            res_offset = num_r * ub_col
            burst_len_dst = ub_col // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

    with tvm_ib.if_scope(ub_col_mod > 0):
        ub_col_mod_align = _ceil_fill(ub_col_mod, cp_align_len)
        ub_col_mod_begin = col_len - ub_col_mod_align

        with tvm_ib.for_range(0, ub_col_mod_align, name="num_uc") as num_uc:
            data_offset = n_index * col_len * row_len\
                          + (ub_col_mod_begin + num_uc) * row_len\
                          + num_rowz * row_ub
            ub_offset = num_uc * row_len_now_align
            burst_len_data = _ceil_div(row_len_now, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = ub_col_mod_align // 16
        r_zu = row_len_now_align // 16
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * ub_col_mod_align * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

        with tvm_ib.for_range(0, row_len_now, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len\
                         + (num_rowz * row_ub + num_r) * col_len\
                         + ub_col_mod_begin
            res_offset = num_r * ub_col_mod_align
            burst_len_dst = ub_col_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _func_two_not_align_large_fp16(args):
    """
    function for not align large fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)

    row_zu = row_len_align // 16
    col_16_ele = col_len * 16
    ub_loop = col_16_ele // ub_ele
    ub_mod = col_16_ele % ub_ele
    ub_col = ub_ele // 16
    row_ub = 16
    ub_col_mod = ub_mod // 16

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, row_zu, name="num_rowz") as num_rowz:
        with tvm_ib.if_scope(num_rowz < (row_zu - 1)):
            row_len_now = row_ub
            args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
                   addr_array_buf, cp_align_len, col_len, row_len, ub_ele,\
                   float_size, row_ub, ub_loop, ub_col, ub_col_mod, n_index,\
                   num_rowz, row_len_now
            _move_data_large_not_align(args)

        with tvm_ib.else_scope():
            row_len_now = row_len - (row_zu - 1) * row_ub
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, cp_align_len, col_len, row_len, ub_ele, \
                   float_size, row_ub, ub_loop, ub_col, ub_col_mod, n_index, \
                   num_rowz, row_len_now
            _move_data_large_not_align(args)


def _two_not_align_large_fp16(dst, data):
    """
    function of making ir node builder for not align large fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_not_align_large_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_not_align_large_fp16(args)

    return tvm_ib.get()


def _move_for_not_align_large_fp16_fencore(args):
    """
    function of moving data for not align large fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, \
    addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
    row_len, n_index, row_index, row_ub, \
    row_len_now, col_len_now, col_len_begin = args

    row_len_now_align = _ceil_fill(row_len_now, cp_align_len)

    with tvm_ib.for_range(0, col_len_now, name="num_uc") as num_uc:
        data_offset = n_index * col_len * row_len \
                      + (col_len_begin + num_uc) * row_len \
                      + row_index * row_ub
        ub_offset = num_uc * row_len_now_align
        burst_len_data = _ceil_div(row_len_now, cp_align_len)
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    c_zu = col_len_now // 16
    r_zu = row_len_now_align // 16
    with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
        one_begin = (num_rz * 16) * float_size
        two_begin = (ub_ele + num_rz * col_len_now * 16) * float_size
        repeat_vconv = c_zu
        src_stride_vconv = 16 * r_zu
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, \
               two_begin, repeat_vconv, src_stride_vconv, \
               dst_stride_vconv, r_zu, c_zu
        _vconv_one(args)

    with tvm_ib.for_range(0, row_len_now, name="num_r") as num_r:
        dst_offset = n_index * col_len * row_len \
                     + (row_index * row_ub + num_r) * col_len + col_len_begin
        res_offset = num_r * col_len_now
        burst_len_dst = col_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))


def _func_two_not_align_large_fp16_fencore_nomod(args):
    """
    function for not align large fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, \
    row_ub, row_zu, fen_n, col_fen, ub_col, ub_col_mod, \
    num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(row_index < row_zu - 1):
        row_len_now = row_ub
        col_len_now = ub_col
        col_len_begin = col_index * ub_col
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
               row_len, n_index, row_index, row_ub, \
               row_len_now, col_len_now, col_len_begin
        _move_for_not_align_large_fp16_fencore(args)
    with tvm_ib.else_scope():
        row_len_now = row_len - (row_zu - 1) * row_ub
        col_len_now = ub_col
        col_len_begin = col_index * ub_col
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
               row_len, n_index, row_index, row_ub, \
               row_len_now, col_len_now, col_len_begin
        _move_for_not_align_large_fp16_fencore(args)


def _func_two_not_align_large_fp16_fencore_mod(args):
    """
    function for not align large fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, \
    row_ub, row_zu, fen_n, col_fen, ub_col, ub_col_mod, \
    num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(row_index < row_zu - 1):
        with tvm_ib.if_scope(col_index < col_fen - 1):
            row_len_now = row_ub
            col_len_now = ub_col
            col_len_begin = col_index * ub_col
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
                   row_len, n_index, row_index, row_ub, \
                   row_len_now, col_len_now, col_len_begin
            _move_for_not_align_large_fp16_fencore(args)
        with tvm_ib.else_scope():
            row_len_now = row_ub
            ub_col_mod_align = _ceil_fill(ub_col_mod, cp_align_len)
            col_len_now = ub_col_mod_align
            col_len_begin = col_len - col_len_now
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
                   row_len, n_index, row_index, row_ub, \
                   row_len_now, col_len_now, col_len_begin
            _move_for_not_align_large_fp16_fencore(args)
    with tvm_ib.else_scope():
        with tvm_ib.if_scope(col_index < col_fen - 1):
            row_len_now = row_len - (row_zu - 1) * row_ub
            col_len_now = ub_col
            col_len_begin = col_index * ub_col
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
                   row_len, n_index, row_index, row_ub, \
                   row_len_now, col_len_now, col_len_begin
            _move_for_not_align_large_fp16_fencore(args)
        with tvm_ib.else_scope():
            row_len_now = row_len - (row_zu - 1) * row_ub
            ub_col_mod_align = _ceil_fill(ub_col_mod, cp_align_len)
            col_len_now = ub_col_mod_align
            col_len_begin = col_len - col_len_now
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
                   row_len, n_index, row_index, row_ub, \
                   row_len_now, col_len_now, col_len_begin
            _move_for_not_align_large_fp16_fencore(args)


def _two_not_align_large_fp16_fencore(dst, data):
    """
    function of making ir node builder for not align large fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    row_len_align = _ceil_fill(row_len, cp_align_len)

    row_zu = row_len_align // 16
    col_16_ele = col_len * 16
    ub_loop = col_16_ele // ub_ele
    ub_mod = col_16_ele % ub_ele
    ub_col = ub_ele // 16
    row_ub = 16
    ub_col_mod = ub_mod // 16

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_col_mod > 0):
        col_fen = ub_loop + 1
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, \
                   row_ub, row_zu, fen_n, col_fen, ub_col, ub_col_mod, num_g
            _func_two_not_align_large_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, \
                       row_ub, row_zu, fen_n, col_fen, \
                       ub_col, ub_col_mod, group_index
                _func_two_not_align_large_fp16_fencore_mod(args)
    with tvm_ib.else_scope():
        col_fen = ub_loop
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, \
                   row_ub, row_zu, fen_n, col_fen, ub_col, ub_col_mod, num_g
            _func_two_not_align_large_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, \
                       row_ub, row_zu, fen_n, col_fen, \
                       ub_col, ub_col_mod, group_index
                _func_two_not_align_large_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_not_align_little_fp16(args):
    """
    function of moving data for not align little fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size, device_core_num, block_index,\
    cp_align_len, num_g, num_dim_one_core, num_dim_cur_core = args

    n_i, col_len, row_len = data.shape
    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    num_dim_one_group = num_dim_one_core * device_core_num
    num_dim_before_core = num_g * num_dim_one_group\
                          + block_index * num_dim_one_core
    dim_ele = col_len * row_len
    cur_dim_ele = dim_ele * num_dim_cur_core
    cur_dim_ele_align = _ceil_fill(cur_dim_ele, cp_align_len)
    cur_core_ele = num_dim_cur_core * dim_ele

    data_offset = num_dim_before_core * dim_ele
    burst_len_data = _ceil_div(cur_core_ele, cp_align_len)
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    d_zu = cur_dim_ele_align // 16
    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = d_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, dim_ele, name="num_e") as num_e:
        res_offset = num_e * 16
        row_index = num_e // row_len
        col_index = num_e % row_len
        ub_offset = (col_index * col_len + row_index) * 16
        n_burst = num_dim_cur_core
        burst_len = 1
        src_stride = dim_ele - 1
        dst_stride = dim_ele - 1
        tvm_ib.emit(
            tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                            data_ub.access_ptr(
                                "w", offset=ub_offset),
                            data_res.access_ptr(
                                "r", offset=res_offset),
                            0, n_burst, burst_len,
                            src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = d_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(cur_core_ele % cp_align_len > 0):
        with tvm_ib.if_scope(cur_core_ele > cp_align_len):
            cur_core_ele_align = cur_core_ele - cp_align_len

            dst_offset = num_dim_before_core * dim_ele
            burst_len_dst = _ceil_div(cur_core_ele_align, cp_align_len)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))
            with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
                tvm_ib.emit(tvm.call_extern(
                    data_res.dtype, "reg_mov",
                    tvm.call_extern(reg.dtype, "reg", reg[0]),
                    data_res.access_ptr(
                        'r', offset=cur_core_ele_align + num_a)
                ))
                tvm_ib.emit(tvm.call_extern(
                    data_tail.dtype, "reg_mov",
                    data_tail.access_ptr(
                        'w', offset=num_a),
                    tvm.call_extern(reg.dtype, "reg", reg[0])
                ))
            tvm_ib.emit(
                tvm.call_extern(
                    dst.dtype, "copy_ubuf_to_gm",
                    dst.access_ptr(
                        'w',
                        offset=dst_offset + cur_core_ele_align),
                    data_tail.access_ptr("r", offset=0),
                    0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            dst_offset = num_dim_before_core * dim_ele
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, 1, 0, 0))

    with tvm_ib.else_scope():
        dst_offset = num_dim_before_core * dim_ele
        burst_len_dst = cur_core_ele // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _two_not_align_little_fp16(dst, data):
    """
    function of making ir node builder for not align little fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    n_i, col_len, row_len = data.shape

    dim_ele = col_len * row_len
    dim_ele_align = _ceil_fill(dim_ele, cp_align_len)

    num_dim_one_core = ub_ele // 16 // dim_ele_align
    num_dim_one_group = num_dim_one_core * device_core_num

    group_index = n_i // num_dim_one_group
    group_mod = n_i % num_dim_one_group

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g,\
               num_dim_one_core, num_dim_one_core
        _func_two_not_align_little_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        num_core = group_mod // num_dim_one_core
        num_dim_mod = group_mod % num_dim_one_core
        with tvm_ib.if_scope(num_core > 0):
            with tvm_ib.if_scope(block_index < num_core):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       group_index, num_dim_one_core, num_dim_one_core
                _func_two_not_align_little_fp16(args)
        with tvm_ib.if_scope(num_dim_mod > 0):
            with tvm_ib.if_scope(tvm.all(block_index > (num_core - 1),
                                         block_index < (num_core + 1))):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       group_index, num_dim_one_core, num_dim_mod
                _func_two_not_align_little_fp16(args)

    return tvm_ib.get()


def _func_two_small_fp32(args):
    """
    function of moving data for two small fp32 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    dim_ele = col_len * row_len
    dim_ele_two = dim_ele * 2
    dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
    dim_zu = dim_ele_two_align // 16

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    data_offset = n_index * col_len * row_len
    burst_len_data = _ceil_div(dim_ele, cp_align_len)
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
        res_offset = num_r * 16
        ub_offset = num_r * 16 * col_len
        n_burst = col_len
        burst_len = 2
        src_stride = row_len * 2 - 2
        dst_stride = 0
        tvm_ib.emit(
            tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                            data_ub.access_ptr(
                                "w", offset=ub_offset),
                            data_res.access_ptr(
                                "r", offset=res_offset),
                            0, n_burst, burst_len,
                            src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(dim_ele % cp_align_len > 0):
        dim_ele_sub = dim_ele - cp_align_len
        dst_offset = n_index * col_len * row_len
        burst_len = _ceil_div(dim_ele_sub, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len, 0, 0))
        with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_res.access_ptr(
                    'r',
                    offset=dim_ele_sub + num_a)
            ))
            tvm_ib.emit(tvm.call_extern(
                data_tail.dtype, "reg_mov",
                data_tail.access_ptr('w', offset=num_a),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr(
                                        'w',
                                        offset=dst_offset + dim_ele_sub),
                                    data_tail.access_ptr("r", offset=0),
                                    0, 1, 1, 0, 0))

    with tvm_ib.else_scope():
        dst_offset = n_index * col_len * row_len
        burst_len_dst = dim_ele // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _two_small_fp32(dst, data):
    """
    function of making ir node builder for two small fp32 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_small_fp32(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_small_fp32(args)

    return tvm_ib.get()


def _func_two_little_fp32(args):
    """
    function of moving data for two little fp32 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size, device_core_num, block_index,\
    cp_align_len, num_g, num_dim_one_core, num_dim_cur_core = args

    n_i, col_len, row_len = data.shape
    dim_ele = col_len * row_len
    dim_ele_two = dim_ele * 2

    mov_ele = col_len * row_len * num_dim_cur_core
    mov_ele_two = mov_ele * 2
    mov_ele_two_align = _ceil_fill(mov_ele_two, 16)
    dim_zu = mov_ele_two_align // 16

    num_dim_one_group = num_dim_one_core * device_core_num
    num_dim_before_core = num_g * num_dim_one_group\
                          + block_index * num_dim_one_core
    data_offset = num_dim_before_core * dim_ele
    burst_len_data = _ceil_div(num_dim_cur_core * dim_ele, cp_align_len)
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, dim_ele, name="num_de") as num_de:
        col_index = num_de // row_len
        row_index = num_de % row_len
        new_index = row_index * col_len + col_index

        res_offset = num_de * 16
        ub_offset = new_index * 16
        n_burst = num_dim_cur_core
        burst_len = 2
        src_stride = dim_ele_two - 2
        dst_stride = dim_ele_two - 2
        tvm_ib.emit(
            tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                            data_ub.access_ptr(
                                "w", offset=ub_offset),
                            data_res.access_ptr(
                                "r", offset=res_offset),
                            0, n_burst, burst_len,
                            src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    core_ele = dim_ele * num_dim_cur_core
    with tvm_ib.if_scope(core_ele % cp_align_len > 0):
        with tvm_ib.if_scope(core_ele > cp_align_len):
            core_ele_align = core_ele - cp_align_len
            dst_offset = num_dim_before_core * dim_ele
            burst_len = _ceil_div(core_ele_align, cp_align_len)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len, 0, 0))
            with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
                tvm_ib.emit(tvm.call_extern(
                    data_res.dtype, "reg_mov",
                    tvm.call_extern(reg.dtype, "reg", reg[0]),
                    data_res.access_ptr(
                        'r',
                        offset=core_ele_align + num_a)
                ))
                tvm_ib.emit(tvm.call_extern(
                    data_tail.dtype, "reg_mov",
                    data_tail.access_ptr('w', offset=num_a),
                    tvm.call_extern(reg.dtype, "reg", reg[0])
                ))
            tvm_ib.emit(
                tvm.call_extern(
                    dst.dtype, "copy_ubuf_to_gm",
                    dst.access_ptr(
                        'w',
                        offset=dst_offset + core_ele_align),
                    data_tail.access_ptr("r", offset=0),
                    0, 1, 1, 0, 0))

        with tvm_ib.else_scope():
            dst_offset = num_dim_before_core * dim_ele
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, 1, 0, 0))

    with tvm_ib.else_scope():
        dst_offset = num_dim_before_core * dim_ele
        burst_len = core_ele // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len, 0, 0))


def _two_little_fp32(dst, data):
    """
    function of making ir node builder for two little fp32 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape
    dim_space = col_len * row_len * 2 * 8

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    num_dim_one_core = ub_ele // dim_space
    num_dim_one_group = num_dim_one_core * device_core_num
    group_index = n_i // num_dim_one_group
    group_mod = n_i % num_dim_one_group

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len,\
               num_g, num_dim_one_core, num_dim_one_core
        _func_two_little_fp32(args)
    with tvm_ib.if_scope(group_mod > 0):
        num_core = group_mod // num_dim_one_core
        num_dim_mod = group_mod % num_dim_one_core
        with tvm_ib.if_scope(num_core > 0):
            with tvm_ib.if_scope(block_index < num_core):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, \
                       group_index, num_dim_one_core, num_dim_one_core
                _func_two_little_fp32(args)
        with tvm_ib.if_scope(num_dim_mod > 0):
            with tvm_ib.if_scope(tvm.all(block_index > (num_core - 1),
                                         block_index < (num_core + 1))):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, \
                       group_index, num_dim_one_core, num_dim_mod
                _func_two_little_fp32(args)

    return tvm_ib.get()


def _func_two_split_row_fp32(args):
    """
    function of moving data for two split row fp32 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    new_space_ele_split_row = col_len * 8 * 2 * 8
    num_row_len_ub = ub_ele // new_space_ele_split_row
    row_len_ub = num_row_len_ub * 8

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len\
                          + num_c * row_len + num_u * row_len_ub
            ub_offset = num_c * row_len_ub
            burst_len_data = row_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = col_len * row_len_ub
        dim_ele_two = dim_ele * 2
        dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
        dim_zu = dim_ele_two_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len_ub, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * col_len
            n_burst = col_len
            burst_len = 2
            src_stride = row_len_ub * 2 - 2
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        dst_offset = n_index * col_len * row_len\
                     + num_u * row_len_ub * col_len
        burst_len_dst = row_len_ub * col_len // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))

    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        ub_mod_begin = row_len - ub_mod_align

        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len\
                          + num_c * row_len + ub_mod_begin
            ub_offset = num_c * ub_mod_align
            burst_len_data = ub_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = col_len * ub_mod_align
        dim_ele_two = dim_ele * 2
        dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
        dim_zu = dim_ele_two_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, ub_mod_align, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * col_len
            n_burst = col_len
            burst_len = 2
            src_stride = ub_mod_align * 2 - 2
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        dst_offset = n_index * col_len * row_len + ub_mod_begin * col_len
        burst_len_dst = ub_mod_align * col_len // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _two_split_row_fp32(dst, data):
    """
    function of making ir node builder for two split row fp32 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape
    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_split_row_fp32(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_split_row_fp32(args)

    return tvm_ib.get()


def _move_for_two_split_row_fp32_fencore(args):
    """
    function of moving data for two split row fp32 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, \
    addr_array_buf, float_size, cp_align_len, ub_ele, \
    n_index, col_len, row_len, row_len_ub, \
    row_len_begin, row_len_now = args

    with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
        data_offset = n_index * col_len * row_len \
                      + num_c * row_len + row_len_begin
        ub_offset = num_c * row_len_now
        burst_len_data = row_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    dim_ele = col_len * row_len_now
    dim_ele_two = dim_ele * 2
    dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
    dim_zu = dim_ele_two_align // 16

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, row_len_now, name="num_r") as num_r:
        res_offset = num_r * 16
        ub_offset = num_r * 16 * col_len
        n_burst = col_len
        burst_len = 2
        src_stride = row_len_now * 2 - 2
        dst_stride = 0
        tvm_ib.emit(
            tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                            data_ub.access_ptr(
                                "w", offset=ub_offset),
                            data_res.access_ptr(
                                "r", offset=res_offset),
                            0, n_burst, burst_len,
                            src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    dst_offset = n_index * col_len * row_len + row_len_begin * col_len
    burst_len_dst = row_len_now * col_len // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, 1, burst_len_dst, 0, 0))


def _func_two_split_row_fp32_fencore_nomod(args):
    """
    function for two split row fp32 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    row_len_now = row_len_ub
    row_len_begin = fen_index * row_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, float_size, cp_align_len, ub_ele, \
           n_index, col_len, row_len, row_len_ub, \
           row_len_begin, row_len_now
    _move_for_two_split_row_fp32_fencore(args)


def _func_two_split_row_fp32_fencore_mod(args):
    """
    function for two split row fp32 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        row_len_now = row_len_ub
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, float_size, cp_align_len, ub_ele,\
               n_index, col_len, row_len, row_len_ub,\
               row_len_begin, row_len_now
        _move_for_two_split_row_fp32_fencore(args)
    with tvm_ib.else_scope():
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        row_len_now = ub_mod_align
        row_len_begin = row_len - row_len_now
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, float_size, cp_align_len, ub_ele, \
               n_index, col_len, row_len, row_len_ub, \
               row_len_begin, row_len_now
        _move_for_two_split_row_fp32_fencore(args)


def _two_split_row_fp32_fencore(dst, data):
    """
    function of making ir node builder for two split row fp32 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape
    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    new_space_ele_split_row = col_len * 8 * 2 * 8
    num_row_len_ub = ub_ele // new_space_ele_split_row
    row_len_ub = num_row_len_ub * 8
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_split_row_fp32_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_split_row_fp32_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_split_row_fp32_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_split_row_fp32_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_split_col_fp32(args):
    """
    function of moving data for two split col fp32 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    new_space_ele_split_col = row_len * 8 * 2 * 8
    num_col_len_ub = ub_ele // new_space_ele_split_col
    col_len_ub = num_col_len_ub * 8

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        data_offset = n_index * col_len * row_len\
                      + num_u * col_len_ub * row_len
        burst_len_data = row_len * col_len_ub // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        dim_ele = col_len_ub * row_len
        dim_ele_two = dim_ele * 2
        dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
        dim_zu = dim_ele_two_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * col_len_ub
            n_burst = col_len_ub
            burst_len = 2
            src_stride = row_len * 2 - 2
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len\
                         + num_r * col_len + num_u * col_len_ub
            res_offset = num_r * col_len_ub
            burst_len_dst = col_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        ub_mod_begin = col_len - ub_mod_align

        data_offset = n_index * col_len * row_len \
                      + ub_mod_begin * row_len
        burst_len_data = row_len * ub_mod_align // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        dim_ele = ub_mod_align * row_len
        dim_ele_two = dim_ele * 2
        dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
        dim_zu = dim_ele_two_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * ub_mod_align
            n_burst = ub_mod_align
            burst_len = 2
            src_stride = row_len * 2 - 2
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len \
                         + num_r * col_len + ub_mod_begin
            res_offset = num_r * ub_mod_align
            burst_len_dst = ub_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _two_split_col_fp32(dst, data):
    """
    function of making ir node builder for two split col fp32 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_split_col_fp32(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_split_col_fp32(args)

    return tvm_ib.get()


def _move_for_two_split_col_fp32_fencore(args):
    """
    function of moving data for two split col fp32 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, \
    addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
    col_len, row_len, col_len_begin, col_len_now = args

    data_offset = n_index * col_len * row_len \
                  + col_len_begin * row_len
    burst_len_data = row_len * col_len_now // cp_align_len
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    dim_ele = col_len_now * row_len
    dim_ele_two = dim_ele * 2
    dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
    dim_zu = dim_ele_two_align // 16

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
        res_offset = num_r * 16
        ub_offset = num_r * 16 * col_len_now
        n_burst = col_len_now
        burst_len = 2
        src_stride = row_len * 2 - 2
        dst_stride = 0
        tvm_ib.emit(
            tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                            data_ub.access_ptr(
                                "w", offset=ub_offset),
                            data_res.access_ptr(
                                "r", offset=res_offset),
                            0, n_burst, burst_len,
                            src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
        dst_offset = n_index * col_len * row_len \
                     + num_r * col_len + col_len_begin
        res_offset = num_r * col_len_now
        burst_len_dst = col_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))


def _func_two_split_col_fp32_fencore_nomod(args):
    """
    function for two split col fp32 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    col_len_now = col_len_ub
    col_len_begin = fen_index * col_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
           col_len, row_len, col_len_begin, col_len_now
    _move_for_two_split_col_fp32_fencore(args)


def _func_two_split_col_fp32_fencore_mod(args):
    """
    function for two split col fp32 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        col_len_now = col_len_ub
        col_len_begin = fen_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
               col_len, row_len, col_len_begin, col_len_now
        _move_for_two_split_col_fp32_fencore(args)

    with tvm_ib.else_scope():
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        col_len_now = ub_mod_align
        col_len_begin = col_len - col_len_now
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
               col_len, row_len, col_len_begin, col_len_now
        _move_for_two_split_col_fp32_fencore(args)


def _two_split_col_fp32_fencore(dst, data):
    """
    function of making ir node builder for two split col fp32 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    new_space_ele_split_col = row_len * 8 * 2 * 8
    num_col_len_ub = ub_ele // new_space_ele_split_col
    col_len_ub = num_col_len_ub * 8
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_split_col_fp32_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_split_col_fp32_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_split_col_fp32_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_split_col_fp32_fencore_nomod(args)

    return tvm_ib.get()


def _move_for_large_fp32(args):
    """
    function of moving data for large fp32 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array, \
    addr_array_buf, ub_ele, float_size, device_core_num, block_index,\
    cp_align_len, num_g, col_len_ub, ub_loop, ub_mod, n_index, row_ub,\
    num_rowz, row_len_now = args

    n_i, col_len, row_len = data.shape

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, col_len_ub, name="num_cl") as num_cl:
            data_offset = n_index * col_len * row_len \
                          + (num_u * col_len_ub + num_cl) * row_len\
                          + num_rowz * row_ub
            ub_offset = num_cl * row_ub
            burst_len_data = row_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = col_len_ub * row_ub
        dim_ele_two = dim_ele * 2
        dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
        dim_zu = dim_ele_two_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_ub, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * col_len_ub
            n_burst = col_len_ub
            burst_len = 2
            src_stride = row_ub * 2 - 2
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len_now, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len\
                         + (num_rowz * row_ub + num_r) * col_len\
                         + num_u * col_len_ub
            res_offset = num_r * col_len_ub
            burst_len_dst = col_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        ub_mod_begin = col_len - ub_mod_align

        with tvm_ib.for_range(0, ub_mod_align, name="num_cl") as num_cl:
            data_offset = n_index * col_len * row_len \
                          + (ub_mod_begin + num_cl) * row_len \
                          + num_rowz * row_ub
            ub_offset = num_cl * row_ub
            burst_len_data = row_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = ub_mod_align * row_ub
        dim_ele_two = dim_ele * 2
        dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
        dim_zu = dim_ele_two_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_ub, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * ub_mod_align
            n_burst = ub_mod_align
            burst_len = 2
            src_stride = row_ub * 2 - 2
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len_now, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len \
                         + (num_rowz * row_ub + num_r) * col_len \
                         + ub_mod_begin
            res_offset = num_r * ub_mod_align
            burst_len_dst = ub_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _func_two_large_fp32(args):
    """
    function for two large fp32 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    row_ub = 8
    col_len_ub = (ub_ele // 16 // 8 // 16) * 16
    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    row_len_align = _ceil_fill(row_len, cp_align_len)
    row_zu = row_len_align // cp_align_len

    with tvm_ib.for_range(0, row_zu, name="num_rowz") as num_rowz:
        with tvm_ib.if_scope(num_rowz < (row_zu - 1)):
            row_len_now = row_ub
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, num_g,\
                   col_len_ub, ub_loop, ub_mod, n_index, row_ub,\
                   num_rowz, row_len_now
            _move_for_large_fp32(args)
        with tvm_ib.else_scope():
            row_len_now = row_len - ((row_zu - 1) * row_ub)
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, num_g, \
                   col_len_ub, ub_loop, ub_mod, n_index, row_ub, \
                   num_rowz, row_len_now
            _move_for_large_fp32(args)


def _two_large_fp32(dst, data):
    """
    function of making ir node builder for two large fp32 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_large_fp32(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_large_fp32(args)

    return tvm_ib.get()


def _move_for_large_fp32_fencore(args):
    """
    function of moving data for large fp32 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array, \
    addr_array_buf, ub_ele, float_size, device_core_num, block_index,\
    cp_align_len, num_g, col_len_ub, ub_loop, ub_mod, n_index, row_ub,\
    num_rowz, row_len_now = args

    n_i, col_len, row_len = data.shape

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, col_len_ub, name="num_cl") as num_cl:
            data_offset = n_index * col_len * row_len \
                          + (num_u * col_len_ub + num_cl) * row_len\
                          + num_rowz * row_ub
            ub_offset = num_cl * row_ub
            burst_len_data = row_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = col_len_ub * row_ub
        dim_ele_two = dim_ele * 2
        dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
        dim_zu = dim_ele_two_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_ub, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * col_len_ub
            n_burst = col_len_ub
            burst_len = 2
            src_stride = row_ub * 2 - 2
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len_now, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len\
                         + (num_rowz * row_ub + num_r) * col_len\
                         + num_u * col_len_ub
            res_offset = num_r * col_len_ub
            burst_len_dst = col_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        ub_mod_begin = col_len - ub_mod_align

        with tvm_ib.for_range(0, ub_mod_align, name="num_cl") as num_cl:
            data_offset = n_index * col_len * row_len \
                          + (ub_mod_begin + num_cl) * row_len \
                          + num_rowz * row_ub
            ub_offset = num_cl * row_ub
            burst_len_data = row_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = ub_mod_align * row_ub
        dim_ele_two = dim_ele * 2
        dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
        dim_zu = dim_ele_two_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_ub, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * ub_mod_align
            n_burst = ub_mod_align
            burst_len = 2
            src_stride = row_ub * 2 - 2
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len_now, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len \
                         + (num_rowz * row_ub + num_r) * col_len \
                         + ub_mod_begin
            res_offset = num_r * ub_mod_align
            burst_len_dst = ub_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _move_for_two_large_fp32_fencore(args):
    """
    function of moving data for two large fp32 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, \
    addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
    row_len, n_index, row_index, row_ub, \
    row_len_now, col_len_now, col_len_begin = args

    with tvm_ib.for_range(0, col_len_now, name="num_cl") as num_cl:
        data_offset = n_index * col_len * row_len \
                      + (col_len_begin + num_cl) * row_len \
                      + row_index * row_ub
        ub_offset = num_cl * row_ub
        burst_len_data = row_ub // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    dim_ele = col_len_now * row_ub
    dim_ele_two = dim_ele * 2
    dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
    dim_zu = dim_ele_two_align // 16

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, row_ub, name="num_r") as num_r:
        res_offset = num_r * 16
        ub_offset = num_r * 16 * col_len_now
        n_burst = col_len_now
        burst_len = 2
        src_stride = row_ub * 2 - 2
        dst_stride = 0
        tvm_ib.emit(
            tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                            data_ub.access_ptr(
                                "w", offset=ub_offset),
                            data_res.access_ptr(
                                "r", offset=res_offset),
                            0, n_burst, burst_len,
                            src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, row_len_now, name="num_r") as num_r:
        dst_offset = n_index * col_len * row_len \
                     + (row_index * row_ub + num_r) * col_len \
                     + col_len_begin
        res_offset = num_r * col_len_now
        burst_len_dst = col_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))


def _func_two_large_fp32_fencore_nomod(args):
    """
    function for two large fp32 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, \
    row_ub, row_zu, fen_n, col_fen, col_len_ub, ub_mod, \
    num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(row_index < row_zu - 1):
        row_len_now = row_ub
        col_len_now = col_len_ub
        col_len_begin = col_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
               row_len, n_index, row_index, row_ub, \
               row_len_now, col_len_now, col_len_begin
        _move_for_two_large_fp32_fencore(args)
    with tvm_ib.else_scope():
        row_len_now = row_len - (row_zu - 1) * row_ub
        col_len_now = col_len_ub
        col_len_begin = col_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
               row_len, n_index, row_index, row_ub, \
               row_len_now, col_len_now, col_len_begin
        _move_for_two_large_fp32_fencore(args)


def _func_two_large_fp32_fencore_mod(args):
    """
    function for two large fp32 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, \
    row_ub, row_zu, fen_n, col_fen, col_len_ub, ub_mod, \
    num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(row_index < row_zu - 1):
        with tvm_ib.if_scope(col_index < col_fen - 1):
            row_len_now = row_ub
            col_len_now = col_len_ub
            col_len_begin = col_index * col_len_ub
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
                   row_len, n_index, row_index, row_ub, \
                   row_len_now, col_len_now, col_len_begin
            _move_for_two_large_fp32_fencore(args)
        with tvm_ib.else_scope():
            row_len_now = row_ub
            ub_col_mod_align = _ceil_fill(ub_mod, cp_align_len)
            col_len_now = ub_col_mod_align
            col_len_begin = col_len - col_len_now
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
                   row_len, n_index, row_index, row_ub, \
                   row_len_now, col_len_now, col_len_begin
            _move_for_two_large_fp32_fencore(args)
    with tvm_ib.else_scope():
        with tvm_ib.if_scope(col_index < col_fen - 1):
            row_len_now = row_len - (row_zu - 1) * row_ub
            col_len_now = col_len_ub
            col_len_begin = col_index * col_len_ub
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
                   row_len, n_index, row_index, row_ub, \
                   row_len_now, col_len_now, col_len_begin
            _move_for_two_large_fp32_fencore(args)
        with tvm_ib.else_scope():
            row_len_now = row_len - (row_zu - 1) * row_ub
            ub_col_mod_align = _ceil_fill(ub_mod, cp_align_len)
            col_len_now = ub_col_mod_align
            col_len_begin = col_len - col_len_now
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
                   row_len, n_index, row_index, row_ub, \
                   row_len_now, col_len_now, col_len_begin
            _move_for_two_large_fp32_fencore(args)


def _two_large_fp32_fencore(dst, data):
    """
    function of making ir node builder for two large fp32 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    row_ub = 8
    col_len_ub = (ub_ele // 16 // 8 // 16) * 16
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub
    row_len_align = _ceil_fill(row_len, cp_align_len)
    row_zu = row_len_align // cp_align_len

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        col_fen = ub_loop + 1
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, \
                   row_ub, row_zu, fen_n, col_fen, col_len_ub, ub_mod, num_g
            _func_two_large_fp32_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, \
                       row_ub, row_zu, fen_n, col_fen, \
                       col_len_ub, ub_mod, group_index
                _func_two_large_fp32_fencore_mod(args)
    with tvm_ib.else_scope():
        col_fen = ub_loop
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, \
                   row_ub, row_zu, fen_n, col_fen, col_len_ub, ub_mod, num_g
            _func_two_large_fp32_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, \
                       row_ub, row_zu, fen_n, col_fen, \
                       col_len_ub, ub_mod, group_index
                _func_two_large_fp32_fencore_nomod(args)

    return tvm_ib.get()


def _reg_mov_batch_0213(args):
    """
    reg_mov data in ub for 0213 scene

    """
    tvm_ib, data_ub, data_res, reg, one_ele, two_ele,\
    three_d, num_o, num_e, two_d = args

    ele_reg = 8
    r_cycle = two_d // ele_reg
    r_mod = two_d % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(num_o * one_ele
                                       + (num_cr*ele_reg + reg_zero)
                                       * three_d + num_e))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(num_o * one_ele
                                       + (num_cr*ele_reg + reg_one)
                                       * three_d + num_e))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(num_o * one_ele
                                       + (num_cr*ele_reg + reg_two)
                                       * three_d + num_e))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(num_o * one_ele
                                       + (num_cr*ele_reg + reg_three)
                                       * three_d + num_e))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(num_o * one_ele
                                       + (num_cr*ele_reg + reg_four)
                                       * three_d + num_e))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(num_o * one_ele
                                       + (num_cr*ele_reg + reg_five)
                                       * three_d + num_e))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(num_o * one_ele
                                       + (num_cr*ele_reg + reg_six)
                                       * three_d + num_e))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(num_o * one_ele
                                       + (num_cr*ele_reg + reg_seven)
                                       * three_d + num_e))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_zero)
                                        * two_ele + num_o * three_d + num_e)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_one)
                                        * two_ele + num_o * three_d + num_e)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_two)
                                        * two_ele + num_o * three_d + num_e)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_three)
                                        * two_ele + num_o * three_d + num_e)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_four)
                                        * two_ele + num_o * three_d + num_e)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_five)
                                        * two_ele + num_o * three_d + num_e)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_six)
                                        * two_ele + num_o * three_d + num_e)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_seven)
                                        * two_ele + num_o * three_d + num_e)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(num_o * one_ele
                                       + (r_cycle*ele_reg + num_er)
                                       * three_d + num_e))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((r_cycle*ele_reg + num_er)
                                        * two_ele + num_o * three_d + num_e)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _func_move_0213_small_dim(args):
    """
    function of moving data for 0213 small dim scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
    float_size, cp_align_len, device_core_num, block_index, num_g = args
    _, one_d, two_d, three_d = data.shape

    dim_ele = one_d * two_d * three_d

    n_index = num_g * device_core_num + block_index

    data_offset = n_index * dim_ele
    burst_len_data = _ceil_div(dim_ele, cp_align_len)
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    one_ele = two_d * three_d
    two_ele = one_d * three_d
    with tvm_ib.for_range(0, one_d, name="num_o") as num_o:
        with tvm_ib.for_range(0, three_d, name="num_e") as num_e:
            args = tvm_ib, data_ub, data_res, reg, one_ele, two_ele,\
                   three_d, num_o, num_e, two_d
            _reg_mov_batch_0213(args)

    dst_offset = n_index * dim_ele
    with tvm_ib.if_scope(dim_ele % cp_align_len > 0):
        move_len = dim_ele - cp_align_len
        burst_len_dst = _ceil_div(move_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))
        with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_res.access_ptr(
                    'r', offset=move_len + num_a)
            ))
            tvm_ib.emit(tvm.call_extern(
                data_tail.dtype, "reg_mov",
                data_tail.access_ptr(
                    'w', offset=num_a),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr(
                                        'w',
                                        offset=dst_offset + move_len),
                                    data_tail.access_ptr(
                                        "r", offset=0),
                                    0, 1, 1, 0, 0))

    with tvm_ib.else_scope():
        burst_len_dst = _ceil_div(dim_ele, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _move_0213_small_dim(dst, data):
    """
    function of making ir node builder for 0213 small dim scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)

    n_i = data.shape[0]

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               float_size, cp_align_len, device_core_num, block_index, num_g
        _func_move_0213_small_dim(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   float_size, cp_align_len, device_core_num,\
                   block_index, group_index
            _func_move_0213_small_dim(args)

    return tvm_ib.get()


def _move_0213_sp1(dst, data):
    """
    function of making ir node builder for move 0213 special one scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)

    one_d, two_d, three_d, four_d = data.shape
    half_two = two_d // 2
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(block_index < 2):
        data_offset = block_index * half_two * three_d * four_d
        burst_len_data = half_two * three_d * four_d // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        with tvm_ib.for_range(0, three_d, name="num_t") as num_t:
            dst_offset = block_index * half_two * four_d\
                         + num_t * two_d * four_d
            res_offset = num_t * four_d
            n_burst = half_two
            burst_len_dst = four_d // cp_align_len
            src_stride = (three_d - 1) * four_d // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_ub.access_ptr(
                                            "r", offset=res_offset),
                                        0, n_burst, burst_len_dst, src_stride,
                                        0))

    return tvm_ib.get()


def _func_move_0213_12_30_26_fp16(args):
    """
    function of moving data for 0213 scene
    [n, 12, 30, 26]  or  [n, 30, 12, 26]

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, cp_align_len, float_size, ub_ele, device_core_num,\
    block_index, num_g = args

    one_d, two_d, three_d, four_d = data.shape
    split_zu = 3
    split_three = three_d // split_zu
    dim_ele = two_d * three_d * four_d
    n_index = num_g * device_core_num + block_index

    with tvm_ib.for_range(0, split_zu, name="num_z") as num_z:
        data_len = split_three * four_d
        data_len_align = _ceil_fill(data_len, cp_align_len)
        data_len_div = data_len_align // cp_align_len
        with tvm_ib.for_range(0, two_d, name="num_t") as num_t:
            data_offset = n_index * dim_ele + num_z * split_three * four_d\
                          + num_t * three_d * four_d
            ub_offset = num_t * data_len_align
            burst_len_data = data_len_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        with tvm_ib.for_range(0, two_d, name="num_t") as num_t:
            one_begin = num_t * data_len_align * float_size
            two_begin = ub_ele * float_size\
                        + num_t * data_len * cp_align_len * float_size
            repeat_vconv = data_len_div
            src_stride_vconv = 1
            dst_stride_vconv = 16
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_two_not_align(args)

        with tvm_ib.for_range(0, split_three, name="num_s") as num_s:
            res_offset = num_s * four_d * cp_align_len
            ub_offset = num_s * two_d * four_d * cp_align_len
            n_burst = two_d
            burst_len = four_d
            src_stride = (split_three - 1) * four_d
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr("w",
                                                   offset=ub_offset),
                                data_res.access_ptr('r',
                                                    offset=res_offset),
                                0, n_burst, burst_len, src_stride, 0))

        all_ele = data_len * two_d
        all_ele_div = _ceil_div(all_ele, cp_align_len)
        ub_begin = 0
        res_begin = ub_ele * float_size
        repeat_vconv = all_ele_div
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, ub_begin, res_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.if_scope(all_ele % cp_align_len > 0):
            move_len = all_ele - cp_align_len
            dst_offset = n_index * dim_ele + num_z * all_ele
            burst_len_dst = _ceil_div(move_len, cp_align_len)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))
            with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
                tvm_ib.emit(tvm.call_extern(
                    data_res.dtype, "reg_mov",
                    tvm.call_extern(reg.dtype, "reg", reg[0]),
                    data_res.access_ptr(
                        'r',
                        offset=(move_len + num_a))
                ))
                tvm_ib.emit(tvm.call_extern(
                    data_tail.dtype, "reg_mov",
                    data_tail.access_ptr(
                        'w', offset=num_a),
                    tvm.call_extern(reg.dtype, "reg", reg[0])
                ))
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr(
                                            'w',
                                            offset=(dst_offset + move_len)),
                                        data_tail.access_ptr(
                                            "r", offset=0),
                                        0, 1, 1, 0, 0))

        with tvm_ib.else_scope():
            dst_offset = n_index * dim_ele + num_z * all_ele
            burst_len_dst = all_ele // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))


def _move_0213_12_30_26_fp16(dst, data):
    """
    function of making ir node builder for move 0213
    [n,12,30,26] or [n,30,12,26] special scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    one_d = data.shape[0]
    group_index = one_d // device_core_num
    group_mod = one_d % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, cp_align_len, float_size,\
               ub_ele, device_core_num, block_index, num_g
        _func_move_0213_12_30_26_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, cp_align_len, float_size, \
                   ub_ele, device_core_num, block_index, group_index
            _func_move_0213_12_30_26_fp16(args)

    return tvm_ib.get()


def _func_move_0213_12_30_26_fp32(args):
    """
    function of moving data for 0213 scene
    [n, 12, 30, 26]  or  [n, 30, 12, 26]

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, cp_align_len, float_size, ub_ele, device_core_num,\
    block_index, num_g = args

    one_d, two_d, three_d, four_d = data.shape
    split_zu = 6
    split_three = three_d // split_zu
    dim_ele = two_d * three_d * four_d
    n_index = num_g * device_core_num + block_index

    with tvm_ib.for_range(0, split_zu, name="num_z") as num_z:
        data_len = split_three * four_d
        data_len_align = _ceil_fill(data_len, cp_align_len)
        data_len_div = data_len_align // cp_align_len
        with tvm_ib.for_range(0, two_d, name="num_t") as num_t:
            data_offset = n_index * dim_ele + num_z * split_three * four_d\
                          + num_t * three_d * four_d
            ub_offset = num_t * data_len_align
            burst_len_data = data_len_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        vconv_len = data_len * 2
        vconv_len_div = _ceil_div(vconv_len, 16)
        with tvm_ib.for_range(0, two_d, name="num_t") as num_t:
            one_begin = num_t * data_len_align * float_size
            two_begin = ub_ele * float_size\
                        + num_t * vconv_len * cp_align_len * float_size
            repeat_vconv = vconv_len_div
            src_stride_vconv = 1
            dst_stride_vconv = 16
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_two_not_align(args)

        with tvm_ib.for_range(0, split_three, name="num_s") as num_s:
            res_offset = num_s * four_d * 2 * cp_align_len
            ub_offset = num_s * two_d * four_d * 2 * cp_align_len
            n_burst = two_d
            burst_len = four_d * 2
            src_stride = (split_three - 1) * four_d * 2
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr("w",
                                                   offset=ub_offset),
                                data_res.access_ptr('r',
                                                    offset=res_offset),
                                0, n_burst, burst_len, src_stride, 0))

        all_ele = data_len * two_d * 2
        all_ele_div = _ceil_div(all_ele, 16)
        ub_begin = 0
        res_begin = ub_ele * float_size
        repeat_vconv = all_ele_div
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, ub_begin, res_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        move_ele = two_d * split_three * four_d
        with tvm_ib.if_scope(move_ele % cp_align_len > 0):
            move_ele_sub = move_ele - cp_align_len
            dst_offset = n_index * dim_ele + num_z * move_ele
            burst_len_dst = _ceil_div(move_ele_sub, cp_align_len)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))
            with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
                tvm_ib.emit(tvm.call_extern(
                    data_res.dtype, "reg_mov",
                    tvm.call_extern(reg.dtype, "reg", reg[0]),
                    data_res.access_ptr(
                        'r',
                        offset=(move_ele_sub + num_a))
                ))
                tvm_ib.emit(tvm.call_extern(
                    data_tail.dtype, "reg_mov",
                    data_tail.access_ptr(
                        'w', offset=num_a),
                    tvm.call_extern(reg.dtype, "reg", reg[0])
                ))
            tvm_ib.emit(
                tvm.call_extern(
                    dst.dtype, "copy_ubuf_to_gm",
                    dst.access_ptr(
                        'w', offset=(dst_offset + move_ele_sub)),
                    data_tail.access_ptr("r", offset=0),
                    0, 1, 1, 0, 0))

        with tvm_ib.else_scope():
            dst_offset = n_index * dim_ele + num_z * move_ele
            burst_len_dst = move_ele // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))


def _move_0213_12_30_26_fp32(dst, data):
    """
    function of making ir node builder for move 0213
    [n,12,30,26] or [n,30,12,26] special scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    one_d = data.shape[0]
    group_index = one_d // device_core_num
    group_mod = one_d % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, cp_align_len, float_size,\
               ub_ele, device_core_num, block_index, num_g
        _func_move_0213_12_30_26_fp32(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, cp_align_len, float_size, \
                   ub_ele, device_core_num, block_index, group_index
            _func_move_0213_12_30_26_fp32(args)

    return tvm_ib.get()


def _func_0213_vec_small(args):

    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, block_index, device_core_num, cp_align_len, float_size,\
    ub_ele, num_g = args

    n_index = num_g * device_core_num + block_index
    _, two_d, three_d, four_d = data.shape
    dim_ele = two_d * three_d * four_d
    dim_ele_div = _ceil_div(dim_ele, cp_align_len)

    data_offset = n_index * dim_ele
    burst_len_data = dim_ele_div
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_ele_div
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, three_d, name="num_te") as num_te:
        res_offset = num_te * four_d * cp_align_len
        ub_offset = num_te * two_d * four_d * cp_align_len
        n_burst = two_d
        burst_len = four_d
        src_stride = three_d * four_d - four_d
        tvm_ib.emit(
            tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                            data_ub.access_ptr("w",
                                               offset=ub_offset),
                            data_res.access_ptr('r',
                                                offset=res_offset),
                            0, n_burst, burst_len, src_stride, 0))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_ele_div
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(dim_ele % cp_align_len > 0):
        move_len = dim_ele - cp_align_len
        dst_offset = n_index * dim_ele
        burst_len_dst = _ceil_div(move_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))
        with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_res.access_ptr(
                    'r',
                    offset=(move_len + num_a))
            ))
            tvm_ib.emit(tvm.call_extern(
                data_tail.dtype, "reg_mov",
                data_tail.access_ptr(
                    'w', offset=num_a),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))

        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr(
                                        'w', offset=(dst_offset + move_len)),
                                    data_tail.access_ptr(
                                        "r", offset=0),
                                    0, 1, 1, 0, 0))
    with tvm_ib.else_scope():
        dst_offset = n_index * dim_ele
        burst_len_dst = dim_ele // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _move_0213_vec_small(dst, data):
    """
    function of making ir node builder for 0213 vec small scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i = data.shape[0]
    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, block_index, device_core_num,\
               cp_align_len, float_size, ub_ele, num_g
        _func_0213_vec_small(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, block_index, device_core_num, \
                   cp_align_len, float_size, ub_ele, group_index
            _func_0213_vec_small(args)

    return tvm_ib.get()


def _0213_vec_mid_two(args):
    """
    function of moving data for 0213 vec mid two scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
    addr_array, addr_array_buf, ub_ele, float_size, cp_align_len,\
    two_d, three_d, four_d, n_index, dim_ele, thf_ele,\
    two_len, two_before = args

    twof_ele = two_len * four_d
    twof_ele_align = _ceil_fill(twof_ele, cp_align_len)

    move_ele = two_len * thf_ele
    move_ele_div = _ceil_div(move_ele, 16)
    data_offset = n_index * dim_ele + two_before * thf_ele
    burst_len_data = move_ele_div
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = move_ele_div
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, three_d, name="num_te") as num_te:
        res_offset = num_te * four_d * cp_align_len
        ub_offset = num_te * two_len * four_d * cp_align_len
        n_burst = two_len
        burst_len = four_d
        src_stride = three_d * four_d - four_d
        tvm_ib.emit(
            tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                            data_ub.access_ptr("w",
                                               offset=ub_offset),
                            data_res.access_ptr('r',
                                                offset=res_offset),
                            0, n_burst, burst_len, src_stride, 0))

    with tvm_ib.for_range(0, three_d, name="num_tr") as num_tr:
        one_begin = num_tr * twof_ele * cp_align_len * float_size
        two_begin = ub_ele * float_size \
                    + num_tr * twof_ele_align * float_size
        repeat_vconv = twof_ele_align // 16
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

    with tvm_ib.for_range(0, three_d, name="num_tz") as num_tz:
        with tvm_ib.if_scope(twof_ele % cp_align_len > 0):
            move_len = twof_ele - cp_align_len
            dst_offset = n_index * dim_ele + two_before * four_d\
                         + num_tz * two_d * four_d
            res_offset = num_tz * twof_ele_align
            burst_len_dst = _ceil_div(move_len, cp_align_len)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))
            with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
                tvm_ib.emit(tvm.call_extern(
                    data_res.dtype, "reg_mov",
                    tvm.call_extern(reg.dtype, "reg", reg[0]),
                    data_res.access_ptr(
                        'r',
                        offset=(num_tz * twof_ele_align + move_len + num_a))
                ))
                tvm_ib.emit(tvm.call_extern(
                    data_tail.dtype, "reg_mov",
                    data_tail.access_ptr(
                        'w', offset=num_a),
                    tvm.call_extern(reg.dtype, "reg", reg[0])
                ))

            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr(
                                            'w',
                                            offset=dst_offset + move_len),
                                        data_tail.access_ptr(
                                            "r", offset=0),
                                        0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            dst_offset = n_index * dim_ele + two_before * four_d \
                         + num_tz * two_d * four_d
            res_offset = num_tz * twof_ele_align
            burst_len_dst = twof_ele // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _func_0213_vec_mid_two(args):
    """
    function of 0213 vec mid two scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array, \
    addr_array_buf, block_index, device_core_num, cp_align_len, float_size, \
    ub_ele, num_g = args

    _, two_d, three_d, four_d = data.shape
    n_index = num_g * device_core_num + block_index
    dim_ele = two_d * three_d * four_d

    thf_ele = three_d * four_d
    thf_space_ele = _ceil_fill(thf_ele, 16) * cp_align_len
    two_ub = ub_ele // thf_space_ele
    ub_loop = two_d // two_ub
    ub_mod = two_d % two_ub

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        two_len = two_ub
        two_before = num_u * two_ub
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size, cp_align_len,\
               two_d, three_d, four_d, n_index, dim_ele, thf_ele,\
               two_len, two_before
        _0213_vec_mid_two(args)
    with tvm_ib.if_scope(ub_mod > 0):
        with tvm_ib.if_scope(ub_mod * four_d >= cp_align_len):
            two_len = ub_mod
            two_before = ub_loop * two_ub
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   cp_align_len, two_d, three_d, four_d, n_index, dim_ele,\
                   thf_ele, two_len, two_before
            _0213_vec_mid_two(args)
        with tvm_ib.else_scope():
            two_len = _ceil_div(cp_align_len, four_d)
            two_before = two_d - two_len
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   cp_align_len, two_d, three_d, four_d, n_index, dim_ele,\
                   thf_ele, two_len, two_before
            _0213_vec_mid_two(args)


def _move_0213_vec_mid_two(dst, data):
    """
    function of making ir node builder for 0213 vec mid two scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i = data.shape[0]
    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, block_index, device_core_num,\
               cp_align_len, float_size, ub_ele, num_g
        _func_0213_vec_mid_two(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, block_index, device_core_num, \
                   cp_align_len, float_size, ub_ele, group_index
            _func_0213_vec_mid_two(args)

    return tvm_ib.get()


def _func_0213_vec_mid_two_mod(args):
    """
    function of 0213 vec mid two mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
    addr_array, addr_array_buf, ub_ele, float_size, cp_align_len,\
    two_ub, ub_mod, fen_n, device_core_num, device_core_num,\
    block_index, num_g = args

    core_before = num_g * device_core_num + block_index
    n_index = core_before // fen_n
    fen_index = core_before % fen_n

    _, two_d, three_d, four_d = data.shape
    dim_ele = two_d * three_d * four_d
    thf_ele = three_d * four_d

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        two_len = two_ub
        two_before = fen_index * two_ub
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
               addr_array, addr_array_buf, ub_ele, float_size, cp_align_len, \
               two_d, three_d, four_d, n_index, dim_ele, thf_ele, \
               two_len, two_before
        _0213_vec_mid_two(args)
    with tvm_ib.else_scope():
        with tvm_ib.if_scope(ub_mod * four_d >= cp_align_len):
            two_len = ub_mod
            two_before = (fen_n - 1) * two_ub
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   cp_align_len, two_d, three_d, four_d, n_index, dim_ele,\
                   thf_ele, two_len, two_before
            _0213_vec_mid_two(args)
        with tvm_ib.else_scope():
            two_len = _ceil_div(cp_align_len, four_d)
            two_before = two_d - two_len
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   cp_align_len, two_d, three_d, four_d, n_index, dim_ele,\
                   thf_ele, two_len, two_before
            _0213_vec_mid_two(args)


def _func_0213_vec_mid_two_nomod(args):
    """
    function of 0213 vec mid two no mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, cp_align_len, \
    two_ub, ub_mod, fen_n, device_core_num, device_core_num,\
    block_index, num_g = args

    core_before = num_g * device_core_num + block_index
    n_index = core_before // fen_n
    fen_index = core_before % fen_n

    _, two_d, three_d, four_d = data.shape
    dim_ele = two_d * three_d * four_d
    thf_ele = three_d * four_d

    two_len = two_ub
    two_before = fen_index * two_ub
    args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
           addr_array, addr_array_buf, ub_ele, float_size, cp_align_len, \
           two_d, three_d, four_d, n_index, dim_ele, thf_ele, \
           two_len, two_before
    _0213_vec_mid_two(args)


def _move_0213_vec_mid_two_fencore(dst, data):
    """
    function of making ir node builder for 0213 vec mid two fen core scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    n_i, two_d, three_d, four_d = data.shape
    thf_ele = three_d * four_d
    thf_space_ele = _ceil_fill(thf_ele, 16) * cp_align_len
    two_ub = ub_ele // thf_space_ele
    ub_loop = two_d // two_ub
    ub_mod = two_d % two_ub

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_core = n_i * fen_n
        group_index = all_core // device_core_num
        group_mod = all_core % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   cp_align_len, two_ub, ub_mod, fen_n, device_core_num,\
                   device_core_num, block_index, num_g
            _func_0213_vec_mid_two_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size,\
                       cp_align_len, two_ub, ub_mod, fen_n, device_core_num,\
                       device_core_num, block_index, group_index
                _func_0213_vec_mid_two_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_core = n_i * fen_n
        group_index = all_core // device_core_num
        group_mod = all_core % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   cp_align_len, two_ub, ub_mod, fen_n, device_core_num,\
                   device_core_num, block_index, num_g
            _func_0213_vec_mid_two_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size,\
                       cp_align_len, two_ub, ub_mod, fen_n, device_core_num,\
                       device_core_num, block_index, group_index
                _func_0213_vec_mid_two_nomod(args)

    return tvm_ib.get()


def _0213_vec_mid_one(args):
    """
    function of moving data for 0213 vec mid one scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
    addr_array, addr_array_buf, ub_ele, float_size, cp_align_len,\
    two_d, three_d, four_d, n_index, dim_ele, twofour_ele,\
    three_len, three_before = args

    tef_ele = three_len * four_d
    tef_ele_align = _ceil_fill(tef_ele, cp_align_len)
    tef_ele_div = tef_ele_align // cp_align_len

    with tvm_ib.for_range(0, two_d, name="num_tw") as num_tw:
        data_offset = n_index * dim_ele + three_before * four_d\
                      + num_tw * three_d * four_d
        ub_offset = num_tw * tef_ele_align
        burst_len_data = tef_ele_div
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    with tvm_ib.for_range(0, two_d, name="num_to") as num_to:
        one_begin = num_to * tef_ele_align * float_size
        two_begin = ub_ele * float_size\
                    + num_to * tef_ele * cp_align_len * float_size
        repeat_vconv = tef_ele_align // 16
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

    with tvm_ib.for_range(0, two_d, name="num_td") as num_td:
        res_offset = num_td * three_len * four_d * cp_align_len
        ub_offset = num_td * four_d * cp_align_len
        n_burst = three_len
        burst_len = four_d
        dst_stride = two_d * four_d - four_d
        tvm_ib.emit(
            tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                            data_ub.access_ptr("w",
                                               offset=ub_offset),
                            data_res.access_ptr('r',
                                                offset=res_offset),
                            0, n_burst, burst_len, 0, dst_stride))

    all_ele = three_len * two_d * four_d
    all_ele_align = _ceil_fill(all_ele, cp_align_len)
    all_ele_div = all_ele_align // cp_align_len

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = all_ele_div
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(all_ele % cp_align_len > 0):
        move_len = all_ele - cp_align_len
        dst_offset = n_index * dim_ele + three_before * two_d * four_d
        burst_len_dst = _ceil_div(move_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))
        with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_res.access_ptr(
                    'r',
                    offset=(move_len + num_a))
            ))
            tvm_ib.emit(tvm.call_extern(
                data_tail.dtype, "reg_mov",
                data_tail.access_ptr(
                    'w', offset=num_a),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))

        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr(
                                        'w',
                                        offset=dst_offset + move_len),
                                    data_tail.access_ptr(
                                        "r", offset=0),
                                    0, 1, 1, 0, 0))
    with tvm_ib.else_scope():
        dst_offset = n_index * dim_ele + three_before * two_d * four_d
        burst_len_dst = all_ele // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _func_0213_vec_mid_one(args):
    """
    function of 0213 vec mid one scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array, \
    addr_array_buf, block_index, device_core_num, cp_align_len, float_size, \
    ub_ele, num_g = args

    _, two_d, three_d, four_d = data.shape
    n_index = num_g * device_core_num + block_index
    dim_ele = two_d * three_d * four_d

    twofour_ele = two_d * four_d
    twofour_space_ele = _ceil_fill(twofour_ele, 16) * cp_align_len
    three_ub = ub_ele // twofour_space_ele
    ub_loop = three_d // three_ub
    ub_mod = three_d % three_ub

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        three_len = three_ub
        three_before = num_u * three_ub
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size, cp_align_len,\
               two_d, three_d, four_d, n_index, dim_ele, twofour_ele,\
               three_len, three_before
        _0213_vec_mid_one(args)
    with tvm_ib.if_scope(ub_mod > 0):
        three_len = ub_mod
        three_before = ub_loop * three_ub
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
               addr_array, addr_array_buf, ub_ele, float_size, \
               cp_align_len, two_d, three_d, four_d, n_index, dim_ele, \
               twofour_ele, three_len, three_before
        _0213_vec_mid_one(args)


def _move_0213_vec_mid_one(dst, data):
    """
    function of making ir node builder for 0213 vec mid one scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i = data.shape[0]
    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, block_index, device_core_num,\
               cp_align_len, float_size, ub_ele, num_g
        _func_0213_vec_mid_one(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, block_index, device_core_num, \
                   cp_align_len, float_size, ub_ele, group_index
            _func_0213_vec_mid_one(args)

    return tvm_ib.get()


def _func_0213_vec_mid_one_mod(args):
    """
    function of 0213 vec mid one mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, cp_align_len, \
    three_ub, ub_mod, fen_n, device_core_num, device_core_num, \
    block_index, num_g = args

    core_before = num_g * device_core_num + block_index
    n_index = core_before // fen_n
    fen_index = core_before % fen_n

    _, two_d, three_d, four_d = data.shape
    dim_ele = two_d * three_d * four_d
    twofour_ele = two_d * four_d

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        three_len = three_ub
        three_before = fen_index * three_ub
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size, cp_align_len,\
               two_d, three_d, four_d, n_index, dim_ele, twofour_ele,\
               three_len, three_before
        _0213_vec_mid_one(args)
    with tvm_ib.else_scope():
        three_len = ub_mod
        three_before = (fen_n - 1) * three_ub
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
               addr_array, addr_array_buf, ub_ele, float_size, cp_align_len, \
               two_d, three_d, four_d, n_index, dim_ele, twofour_ele, \
               three_len, three_before
        _0213_vec_mid_one(args)


def _func_0213_vec_mid_one_nomod(args):
    """
    function of 0213 vec mid one no mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, cp_align_len, \
    three_ub, ub_mod, fen_n, device_core_num, device_core_num, \
    block_index, num_g = args

    core_before = num_g * device_core_num + block_index
    n_index = core_before // fen_n
    fen_index = core_before % fen_n

    _, two_d, three_d, four_d = data.shape
    dim_ele = two_d * three_d * four_d
    twofour_ele = two_d * four_d

    three_len = three_ub
    three_before = fen_index * three_ub
    args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
           addr_array, addr_array_buf, ub_ele, float_size, cp_align_len, \
           two_d, three_d, four_d, n_index, dim_ele, twofour_ele, \
           three_len, three_before
    _0213_vec_mid_one(args)


def _move_0213_vec_mid_one_fencore(dst, data):
    """
    function of making ir node builder for 0213 vec mid one fen core scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    n_i, two_d, three_d, four_d = data.shape
    twofour_ele = two_d * four_d
    twofour_space_ele = _ceil_fill(twofour_ele, 16) * cp_align_len
    three_ub = ub_ele // twofour_space_ele
    ub_loop = three_d // three_ub
    ub_mod = three_d % three_ub

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_core = n_i * fen_n
        group_index = all_core // device_core_num
        group_mod = all_core % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   cp_align_len, three_ub, ub_mod, fen_n, device_core_num, \
                   device_core_num, block_index, num_g
            _func_0213_vec_mid_one_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       cp_align_len, three_ub, ub_mod, fen_n, device_core_num,\
                       device_core_num, block_index, group_index
                _func_0213_vec_mid_one_mod(args)
    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_core = n_i * fen_n
        group_index = all_core // device_core_num
        group_mod = all_core % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   cp_align_len, three_ub, ub_mod, fen_n, device_core_num, \
                   device_core_num, block_index, num_g
            _func_0213_vec_mid_one_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       cp_align_len, three_ub, ub_mod, fen_n, device_core_num,\
                       device_core_num, block_index, group_index
                _func_0213_vec_mid_one_nomod(args)

    return tvm_ib.get()


def _clean_ubuf(ib_, src, src_offset, dup_len):
    """
    function of cleaning space in UB

    """
    uint64_all_one = tvm.const(2**64 - 1, dtype="uint64")
    uint64_all_zero = tvm.const(0, dtype="uint64")
    dtype_factor = 32 // cce.cce_intrin.get_bit_len(src.dtype)
    dup_value = tvm.const(0.0, dtype=src.dtype)
    batch_cnt = 64

    if dup_len > 0:
        if src.dtype == "float16":
            ib_.emit(
                tvm.call_extern("uint64", 'set_vector_mask', uint64_all_one,
                                uint64_all_one))
        else:
            ib_.emit(
                tvm.call_extern("uint64", 'set_vector_mask', uint64_all_zero,
                                uint64_all_one))

        repeat = dup_len // (batch_cnt * dtype_factor)
        dup_left = dup_len % (batch_cnt * dtype_factor)
        if repeat >= 255:
            repeat_loop = (repeat + 255 - 1) // 255
            with ib_.for_range(0, repeat_loop) as i:
                with ib_.if_scope(i != repeat_loop - 1):
                    ib_.emit(
                        tvm.call_extern(
                            src.dtype, 'vector_dup',
                            src.access_ptr(
                                "rw",
                                offset=(255 * batch_cnt * dtype_factor) * i +
                                src_offset), dup_value, 255, 1, 1, 8, 8))
                with ib_.else_scope():
                    ib_.emit(
                        tvm.call_extern(
                            src.dtype, "vector_dup",
                            src.access_ptr(
                                "rw",
                                offset=(255 * batch_cnt * dtype_factor) * i +
                                src_offset), dup_value, repeat % 255, 1, 1, 8,
                            8))

        else:
            ib_.emit(
                tvm.call_extern(src.dtype, "vector_dup",
                                src.access_ptr("rw", offset=src_offset),
                                dup_value, repeat, 1, 1, 8, 8))

            if dup_left > 0:
                if dup_left > 64:
                    high_mask = tvm.const(2 ** (dup_left % 64) - 1,
                                          dtype="uint64")
                    ib_.emit(
                        tvm.call_extern("uint64", 'set_vector_mask',
                                        high_mask,
                                        uint64_all_one))
                elif 0 < dup_left <= 64:
                    low_mask = tvm.const(2 ** dup_left - 1, dtype="uint64")
                    ib_.emit(
                        tvm.call_extern("uint64", 'set_vector_mask',
                                        uint64_all_zero,
                                        low_mask))
                ib_.emit(
                    tvm.call_extern(src.dtype, "vector_dup",
                                    src.access_ptr(
                                        "rw",
                                        offset=(src_offset
                                                + repeat * batch_cnt
                                                * dtype_factor)),
                                    dup_value, 1, 1, 1, 8, 8))

        ib_.emit(
            tvm.call_extern("uint64", 'set_vector_mask', uint64_all_one,
                            uint64_all_one))


def _func_gm_to_ub_align(args):
    """
    function of moving data from data to data_ub

    """
    tvm_ib, data, data_ub, data_offset, ub_offset, ori_nburst,\
    burst_len, src_stride, dst_stride, cp_align_len = args

    with tvm_ib.if_scope(ori_nburst > 0):
        with tvm_ib.if_scope(burst_len > 0):
            with tvm_ib.if_scope(burst_len <= 65535):
                with tvm_ib.if_scope(src_stride >= 0):
                    with tvm_ib.if_scope(dst_stride >= 0):
                        with tvm_ib.if_scope(dst_stride <= 65535):
                            with tvm_ib.if_scope(src_stride <= 65535):
                                with tvm_ib.if_scope(ori_nburst <= 4095):
                                    tvm_ib.emit(
                                        tvm.call_extern(
                                            data_ub.dtype,
                                            "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset),
                                            data.access_ptr(
                                                'r', offset=data_offset),
                                            0, ori_nburst,
                                            burst_len,
                                            src_stride, dst_stride))
                                with tvm_ib.else_scope():
                                    n_burst = 4095
                                    c_cycle = ori_nburst // n_burst
                                    c_mod = ori_nburst % n_burst
                                    with tvm_ib.for_range(0, c_cycle,
                                                          name="num_cy")\
                                            as num_cy:
                                        data_cur = data_offset + (
                                            burst_len + src_stride) \
                                                   * cp_align_len\
                                                   * n_burst * num_cy
                                        ub_cur = ub_offset + (
                                            burst_len + dst_stride) \
                                                 * cp_align_len\
                                                 * n_burst * num_cy
                                        tvm_ib.emit(
                                            tvm.call_extern(
                                                data_ub.dtype,
                                                "copy_gm_to_ubuf",
                                                data_ub.access_ptr(
                                                    "w", offset=ub_cur),
                                                data.access_ptr(
                                                    'r', offset=data_cur),
                                                0, n_burst,
                                                burst_len,
                                                src_stride,
                                                dst_stride))
                                    with tvm_ib.if_scope(c_mod > 0):
                                        data_cur = data_offset + (
                                            burst_len + src_stride) \
                                                   * cp_align_len\
                                                   * n_burst * c_cycle
                                        ub_cur = ub_offset + (
                                            burst_len + dst_stride) \
                                                 * cp_align_len\
                                                 * n_burst * c_cycle
                                        tvm_ib.emit(
                                            tvm.call_extern(
                                                data_ub.dtype,
                                                "copy_gm_to_ubuf",
                                                data_ub.access_ptr(
                                                    "w", offset=ub_cur),
                                                data.access_ptr(
                                                    'r', offset=data_cur),
                                                0, c_mod, burst_len,
                                                src_stride,
                                                dst_stride))
                            with tvm_ib.else_scope():
                                with tvm_ib.for_range(0, ori_nburst,
                                                      name="num_nb") as num_nb:
                                    data_cur = data_offset + (
                                        burst_len + src_stride)\
                                               * cp_align_len * num_nb
                                    ub_cur = ub_offset + (
                                        burst_len + dst_stride)\
                                             * cp_align_len * num_nb
                                    tvm_ib.emit(
                                        tvm.call_extern(
                                            data_ub.dtype,
                                            "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_cur),
                                            data.access_ptr(
                                                'r', offset=data_cur),
                                            0, 1, burst_len,
                                            0, 0))


def _func_ub_to_gm_align(args):
    """
    function of moving data from ub to gm

    """
    tvm_ib, dst, data_res, dst_offset, res_offset, ori_nburst,\
    burst_len, src_stride, dst_stride, cp_align_len = args

    with tvm_ib.if_scope(ori_nburst > 0):
        with tvm_ib.if_scope(burst_len > 0):
            with tvm_ib.if_scope(burst_len <= 65535):
                with tvm_ib.if_scope(src_stride >= 0):
                    with tvm_ib.if_scope(src_stride <= 65535):
                        with tvm_ib.if_scope(dst_stride >= 0):
                            with tvm_ib.if_scope(dst_stride <= 65535):
                                with tvm_ib.if_scope(ori_nburst <= 4095):
                                    tvm_ib.emit(
                                        tvm.call_extern(
                                            dst.dtype,
                                            "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w', offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, ori_nburst,
                                            burst_len,
                                            src_stride,
                                            dst_stride))
                                with tvm_ib.else_scope():
                                    n_burst = 4095
                                    c_cycle = ori_nburst // n_burst
                                    c_mod = ori_nburst % n_burst
                                    with tvm_ib.for_range(0, c_cycle,
                                                          name="num_cy")\
                                            as num_cy:
                                        dst_cur = dst_offset + (
                                            burst_len + dst_stride) \
                                                  * cp_align_len\
                                                  * n_burst * num_cy
                                        res_cur = res_offset + (
                                            burst_len + src_stride) \
                                                  * cp_align_len\
                                                  * n_burst * num_cy
                                        tvm_ib.emit(
                                            tvm.call_extern(
                                                dst.dtype,
                                                "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w',
                                                    offset=dst_cur),
                                                data_res.access_ptr(
                                                    "r", offset=res_cur),
                                                0, n_burst,
                                                burst_len,
                                                src_stride,
                                                dst_stride))
                                    with tvm_ib.if_scope(c_mod > 0):
                                        dst_cur = dst_offset + (
                                            burst_len + dst_stride) \
                                                  * cp_align_len\
                                                  * n_burst * c_cycle
                                        res_cur = res_offset + (
                                            burst_len + src_stride) \
                                                  * cp_align_len\
                                                  * n_burst * c_cycle
                                        tvm_ib.emit(
                                            tvm.call_extern(
                                                dst.dtype,
                                                "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w', offset=dst_cur),
                                                data_res.access_ptr(
                                                    "r", offset=res_cur),
                                                0, c_mod,
                                                burst_len,
                                                src_stride,
                                                dst_stride))
                            with tvm_ib.else_scope():
                                with tvm_ib.for_range(0, ori_nburst,
                                                      name="num_nb") as num_nb:
                                    dst_cur = dst_offset + (
                                        burst_len + dst_stride)\
                                              * cp_align_len * num_nb
                                    res_cur = res_offset + (
                                        burst_len + src_stride)\
                                              * cp_align_len * num_nb
                                    tvm_ib.emit(
                                        tvm.call_extern(
                                            dst.dtype,
                                            "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w', offset=dst_cur),
                                            data_res.access_ptr(
                                                "r", offset=res_cur),
                                            0, 1, burst_len,
                                            0, 0))


def _func_ub_to_gm(args):
    """
    function of moving data from ub to gm

    """
    tvm_ib, param, dst, data_res, dst_offset, res_offset, ori_nburst,\
    burst_len, src_stride, dst_stride = args

    with tvm_ib.if_scope(ori_nburst > 0):
        with tvm_ib.if_scope(burst_len > 0):
            with tvm_ib.if_scope(burst_len <= 65535):
                with tvm_ib.if_scope(src_stride >= 0):
                    with tvm_ib.if_scope(src_stride <= 65535):
                        with tvm_ib.if_scope(dst_stride >= 0):
                            with tvm_ib.if_scope(dst_stride <= 65535):
                                with tvm_ib.if_scope(ori_nburst <= 4095):
                                    tvm_ib.emit(
                                        tvm.call_extern(
                                            dst.dtype,
                                            "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w',
                                                offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, ori_nburst,
                                            burst_len,
                                            src_stride,
                                            dst_stride))
                                with tvm_ib.else_scope():
                                    n_burst = 4095
                                    c_cycle = ori_nburst // n_burst
                                    c_mod = ori_nburst % n_burst
                                    with tvm_ib.for_range(0, c_cycle,
                                                          name="num_cy")\
                                            as num_cy:
                                        dst_cur = dst_offset + (
                                            burst_len + dst_stride) \
                                                  * param.get("cp_align_len")\
                                                  * n_burst * num_cy
                                        res_cur = res_offset + (
                                            burst_len + src_stride) \
                                                  * param.get("cp_align_len")\
                                                  * n_burst * num_cy
                                        tvm_ib.emit(
                                            tvm.call_extern(
                                                dst.dtype,
                                                "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w', offset=dst_cur),
                                                data_res.access_ptr(
                                                    "r", offset=res_cur),
                                                0, n_burst,
                                                burst_len,
                                                src_stride,
                                                dst_stride))
                                    with tvm_ib.if_scope(c_mod > 0):
                                        dst_cur = dst_offset + (
                                            burst_len + dst_stride) \
                                                  * param.get("cp_align_len")\
                                                  * n_burst * c_cycle
                                        res_cur = res_offset + (
                                            burst_len + src_stride) \
                                                  * param.get("cp_align_len")\
                                                  * n_burst * c_cycle
                                        tvm_ib.emit(
                                            tvm.call_extern(
                                                dst.dtype,
                                                "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w', offset=dst_cur),
                                                data_res.access_ptr(
                                                    "r", offset=res_cur),
                                                0, c_mod,
                                                burst_len,
                                                src_stride,
                                                dst_stride))
                            with tvm_ib.else_scope():
                                with tvm_ib.for_range(0, ori_nburst,
                                                      name="num_nb") as num_nb:
                                    dst_cur = dst_offset + (
                                        burst_len + dst_stride)\
                                              * param.get("cp_align_len")\
                                              * num_nb
                                    res_cur = res_offset + (
                                        burst_len + src_stride)\
                                              * param.get("cp_align_len")\
                                              * num_nb
                                    tvm_ib.emit(
                                        tvm.call_extern(
                                            dst.dtype,
                                            "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w',
                                                offset=dst_cur),
                                            data_res.access_ptr(
                                                "r",
                                                offset=res_cur),
                                            0, 1, burst_len,
                                            0, 0))


def _get_branch_0231_core(ub_bytes, core_divide, c_i, cp_align_len):
    ub_bytes_core = ub_bytes // core_divide
    ub_half_core = ub_bytes_core // 2
    num_block_in_ub_half_core = ub_half_core // 32

    if c_i <= num_block_in_ub_half_core:
        return "more_row_ir_0231"
    else:
        num_block_ci = c_i + _ceil_div(c_i, cp_align_len)
        num_block_in_ub_core = ub_bytes_core // 32
        if num_block_ci <= num_block_in_ub_core:
            return "one_row_ir_0231"
        else:
            return "split_row_ir_0231"


def _get_branch_0231(src_shape, dtype):
    """
    judge ir node builder branch when perm is [0, 2, 3, 1]

    """
    device_core_num = AICORE_NUM
    c_i = src_shape[1]
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 32
    ub_half = ub_bytes // 2
    num_block_in_ub_half = ub_half // 32

    shape_ele = functools_reduce(lambda x, y: x*y, src_shape[:])
    shape_bytes = shape_ele*float_size
    ub_bytes_group = ub_bytes*device_core_num
    ub_half_group = ub_half*device_core_num

    no_divide = 1
    core_divide = 8
    if c_i <= num_block_in_ub_half:
        if shape_bytes < ub_half_group:
            branch = _get_branch_0231_core(ub_bytes, core_divide,
                                           c_i, cp_align_len)
            return branch, core_divide
        else:
            return "more_row_ir_0231", no_divide
    else:
        if shape_bytes < ub_bytes_group:
            branch = _get_branch_0231_core(ub_bytes, core_divide,
                                           c_i, cp_align_len)
            return branch, core_divide
        else:
            num_block_ci = c_i + _ceil_div(c_i, cp_align_len)
            num_block_in_ub = ub_bytes // 32
            if num_block_ci <= num_block_in_ub:
                return "one_row_ir_0231", no_divide
            else:
                return "split_row_ir_0231", no_divide


def _get_branch_0312(src_shape, dtype):
    """
    judge ir node builder branch when perm is [0, 3, 1, 2]

    """
    _, h_i, w_i, c_i = src_shape
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    num_row = h_i*w_i
    ub_bytes = UB_SIZE_B - 32
    ub_half = ub_bytes // 2
    dim_bytes = num_row*cp_align_len*float_size
    actual_row_len = min(cp_align_len, c_i)
    one_row_bytes = _ceil_fill(num_row, cp_align_len)*(actual_row_len + 1)\
                    * float_size
    if dim_bytes <= ub_half:
        return "more_dim_0312"
    else:
        if one_row_bytes <= ub_bytes:
            if c_i >= cp_align_len:
                return "one_dim_0312"
            else:
                return "one_dim_0312_small"
        else:
            if c_i >= cp_align_len:
                return "split_dim_0312"
            else:
                return "split_dim_0312_small"


# pylint: disable=locally-disabled,too-many-return-statements
def _get_branch_10(src_shape, dtype):
    """
    judge ir node builder branch when perm is [1, 0]

    """
    num, col_len, row_len = src_shape
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 32
    ub_half = ub_bytes // 2
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = ub_half // float_size
    two_dim_ele = col_len*row_len
    two_dim_ele_align = _ceil_fill(two_dim_ele, cp_align_len)
    row_len_align = _ceil_fill(row_len, cp_align_len)
    ub_ele_small = (ub_bytes - 32*cp_align_len) // 2 // float_size

    shape_ele = num*col_len*row_len
    ub_ele_group = ub_ele*device_core_num
    no_divide = 1

    if shape_ele < ub_ele_group:
        core_divide = 8
        ub_ele_core = ub_ele // core_divide
        ub_ele_small_core = ub_ele_small // core_divide
        if two_dim_ele_align <= ub_ele_core:
            return "more_two_dim", core_divide
        elif col_len * cp_align_len <= ub_ele_core:
            return "more_dim", core_divide
        elif row_len_align * cp_align_len <= ub_ele_small_core:
            return "split_dim", core_divide
        else:
            return "large_two_dim", core_divide
    else:
        if two_dim_ele_align <= ub_ele:
            return "more_two_dim", no_divide
        elif col_len * cp_align_len <= ub_ele:
            return "more_dim", no_divide
        elif row_len_align * cp_align_len <= ub_ele_small:
            return "split_dim", no_divide
        else:
            return "large_two_dim", no_divide


def _check_branch_10(src_shape, dtype):
    """
    judge ir node builder branch when perm is [1, 0]

    """
    num, col_len, row_len = src_shape
    ub_bytes = UB_SIZE_B - 32
    ub_half = ub_bytes // 2
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = ub_half // float_size
    two_dim_ele = col_len*row_len
    two_dim_ele_align = _ceil_fill(two_dim_ele, cp_align_len)
    row_len_align = _ceil_fill(row_len, cp_align_len)
    ub_ele_small = (ub_bytes - 32*cp_align_len) // 2 // float_size

    if two_dim_ele_align <= ub_ele:
        return "more_two_dim"
    elif col_len*cp_align_len <= ub_ele:
        return "more_dim"
    elif row_len_align*cp_align_len <= ub_ele_small:
        return "split_dim"
    else:
        return "large_two_dim"


def _check_two_dim(perm, dtype):
    """
    judge whether to use branch of two dim

    """
    if dtype != "float16" and dtype != "float32"\
            and dtype != "int32" and dtype != "int8":
        return False
    if len(perm) < 2:
        return False
    len_p = len(perm)

    if perm[-1] == (len_p - 2) and perm[-2] == (len_p - 1):
        for i in range(0, len_p - 2):
            if perm[i] != i:
                return False
        return True
    if list(perm) == [1, 2, 0]:
        return True

    return False


def _update_shape_10(shape, perm):
    """
    update shape for two dim scene

    """
    len_p = len(perm)
    shape_new = []
    if perm[-1] == (len_p - 2) and perm[-2] == (len_p - 1):
        dim_zero = 1
        for i in range(len_p - 2):
            dim_zero = dim_zero * shape[i]
        shape_new.append(dim_zero)
        shape_new.append(shape[-2])
        shape_new.append(shape[-1])
    elif list(perm) == [1, 2, 0]:
        shape_new.append(1)
        shape_new.append(shape[0])
        shape_new.append(shape[1] * shape[2])

    return shape_new


def _check_shape_102(shape, perm, dtype):
    if dtype != "float16" and dtype != "float32":
        return False
    if list(perm) != [1, 0, 2]:
        return False
    ub_bytes = UB_SIZE_B - 32
    ub_half = ub_bytes // 2
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = ub_half // float_size
    shape_ele = functools_reduce(lambda x, y: x*y, shape[:])
    if shape_ele < ub_ele and shape[-1] < cp_align_len:
        return True

    return False


def _get_max_mod(a, b):
    """
    function of getting max common divisor

    """
    if b > a:
        temp = a
        a = b
        b = temp

    c = b
    while a % b != 0:
        c = a % b
        a = b
        b = c

    return c


def _get_min_mul(a, b):
    """
    function of getting min common multiple

    """
    mod = _get_max_mod(a, b)
    res = (a*b)//mod

    return res


def _get_row_zu(row_out, dtype):
    """
    function of getting row group

    """
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size

    row_mod = row_out % cp_align_len
    row_zu = _get_min_mul(cp_align_len, row_mod) // row_mod

    return row_zu


def _check_sp_0312_fp32(shape_nhwc, dtype):
    """
    check whether 0312 float32 special branch

    """
    if dtype != "float32":
        return False

    n_i, h_i, w_i, c_i = shape_nhwc

    device_core_num = AICORE_NUM
    if device_core_num != 32:
        return False

    if n_i > device_core_num:
        return False

    if n_i < device_core_num:
        if device_core_num % n_i > 0:
            return False

    if h_i*w_i % 256 > 0:
        return False

    if n_i < device_core_num:
        flag = device_core_num // n_i
        hw_new = h_i*w_i // flag
        if hw_new % 256 > 0:
            return False

    if c_i == 19:
        return True

    return False


def _check_sp_0231_fp32(shape_nchw, dtype):
    """
    check whether 0231 float32 special branch

    """
    if dtype != "float32":
        return False

    n_i, c_i, h_i, w_i = shape_nchw

    device_core_num = AICORE_NUM
    if device_core_num != 32:
        return False

    if n_i > device_core_num:
        return False

    if n_i < device_core_num:
        if device_core_num % n_i > 0:
            return False

    if h_i * w_i % 256 > 0:
        return False

    if n_i < device_core_num:
        flag = device_core_num // n_i
        hw_new = h_i * w_i // flag
        if hw_new % 256 > 0:
            return False

    if c_i == 19:
        return True

    return False


def _update_shape_for_notchange_last(shape, perm):
    """
    update the shape and perm for not change last axis scene

    """
    if len(perm) < 2:
        return shape, perm

    len_p = len(perm)
    list_range = list(range(len_p))
    if list(perm) == list_range:
        perm_up = [0]
        value_all = functools_reduce(lambda x, y: x*y, shape[:])
        shape_up = [value_all]
        return shape_up, perm_up

    flag = len_p - 1
    for i, perm_i in enumerate(reversed(perm)):
        if (i + perm_i) != (len_p - 1):
            flag = i
            break

    diff_loc = len_p - flag - 1
    same_loc = diff_loc + 1

    shape_up = []
    perm_up = []
    for i, (shape_i, perm_i) in enumerate(zip(shape, perm)):
        if i <= diff_loc:
            shape_up.append(shape_i)
            perm_up.append(perm_i)

    perm_up.append(same_loc)
    value_last = functools_reduce(lambda x, y: x*y, shape[same_loc:])
    shape_up.append(value_last)

    return shape_up, perm_up


def _check_two_permute_align_fp16(shape, perm, dtype):
    """
    check whether two permute align fp16

    """
    if dtype != "float16":
        return False

    if perm != [0, 2, 1]:
        return False

    _, col_len, row_len = shape

    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size

    if col_len % cp_align_len == 0 and row_len % cp_align_len == 0:
        return True

    return False


def _update_shape_perm(shape, perm):
    """
    function of updating shape and perm for two permute scene

    """
    if perm == [0, 2, 1]:
        return shape, perm

    n_i = shape[0]

    if perm == [0, 2, 3, 1]:
        col_len = shape[1]
        row_len = shape[2] * shape[3]
    elif perm == [0, 3, 1, 2]:
        col_len = shape[1] * shape[2]
        row_len = shape[3]
    elif perm == [1, 0]:
        n_i = 1
        col_len = shape[0]
        row_len = shape[1]
    elif perm == [0, 1, 3, 2]:
        n_i = shape[0] * shape[1]
        col_len = shape[2]
        row_len = shape[3]
    elif perm == [0, 1, 2, 4, 3]:
        n_i = shape[0] * shape[1] * shape[2]
        col_len = shape[3]
        row_len = shape[4]
    elif perm == [2, 0, 1]:
        n_i = 1
        col_len = shape[0] * shape[1]
        row_len = shape[2]

    shape_new = [n_i, col_len, row_len]
    perm_new = [0, 2, 1]

    return shape_new, perm_new


def _choose_branch_two_permute_align_fp16(shape, dtype):
    """
    choose which branch in two permute align fp16

    """
    n_i, col_len, row_len = shape

    ub_bytes = UB_SIZE_B - 64
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256
    dim_ele = col_len * row_len

    device_core_num = AICORE_NUM

    if dim_ele <= ub_ele:
        return "small"
    elif col_len * cp_align_len <= ub_ele and n_i < device_core_num:
        return "split_row_fencore"
    elif col_len * cp_align_len <= ub_ele:
        return "split_row"
    elif cp_align_len * row_len <= ub_ele and n_i < device_core_num:
        return "split_col_fencore"
    elif cp_align_len * row_len <= ub_ele:
        return "split_col"
    elif n_i < device_core_num:
        return "large_fencore"
    else:
        return "large"


def _check_two_col_align_fp16(shape, perm, dtype):
    """
    check whether two col align fp16

    """
    if dtype != "float16":
        return False

    if perm != [0, 2, 1]:
        return False

    _, col_len, row_len = shape

    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size

    if col_len % cp_align_len == 0 and row_len % cp_align_len > 0:
        return True

    return False


def _choose_branch_two_col_align_fp16(shape, dtype):
    """
    choose which branch in two col align fp16

    """
    n_i, col_len, row_len = shape

    ub_bytes = UB_SIZE_B - 64
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    row_len_align = _ceil_fill(row_len, cp_align_len)
    dim_ele = col_len * row_len_align
    new_space_ele_split_col = _ceil_fill(row_len * 16, 16) * 16

    device_core_num = AICORE_NUM

    little_ele = _ceil_fill(col_len * row_len, cp_align_len)

    if little_ele * 16 <= ub_ele:
        return "little"
    elif dim_ele <= ub_ele:
        return "small"
    elif cp_align_len * row_len_align <= ub_ele\
            and new_space_ele_split_col <= ub_ele\
            and n_i < device_core_num:
        return "split_col_new_fencore"
    elif cp_align_len * row_len_align <= ub_ele\
            and new_space_ele_split_col <= ub_ele:
        return "split_col_new"
    elif col_len * cp_align_len <= ub_ele and n_i < device_core_num:
        return "split_row_fencore"
    elif col_len * cp_align_len <= ub_ele:
        return "split_row"
    elif cp_align_len * row_len_align <= ub_ele and n_i < device_core_num:
        return "split_col_fencore"
    elif cp_align_len * row_len_align <= ub_ele:
        return "split_col"
    elif n_i < device_core_num:
        return "large_fencore"
    else:
        return "large"


def _check_two_row_align_fp16(shape, perm, dtype):
    """
    check whether two row align fp16

    """
    if dtype != "float16":
        return False

    if perm != [0, 2, 1]:
        return False

    _, col_len, row_len = shape

    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size

    if col_len % cp_align_len > 0 and row_len % cp_align_len == 0:
        return True

    return False


def _choose_branch_two_row_align_fp16(shape, dtype):
    """
    choose which branch in two row align fp16

    """
    n_i, col_len, row_len = shape

    ub_bytes = UB_SIZE_B - 64
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    col_len_align = _ceil_fill(col_len, cp_align_len)
    dim_ele = col_len_align * row_len

    new_space_ele_split_row = _ceil_fill(col_len * 16, 16) * 16

    device_core_num = AICORE_NUM

    little_ele = _ceil_fill(col_len * row_len, cp_align_len)

    if little_ele * 16 <= ub_ele:
        return "little"
    elif dim_ele <= ub_ele and col_len >= cp_align_len:
        return "small"
    elif col_len_align * cp_align_len <= ub_ele \
             and new_space_ele_split_row <= ub_ele \
             and n_i < device_core_num:
        return "split_row_new_fencore"
    elif col_len_align * cp_align_len <= ub_ele \
            and new_space_ele_split_row <= ub_ele:
        return "split_row_new"
    elif col_len_align * cp_align_len <= ub_ele and n_i < device_core_num:
        return "split_row_fencore"
    elif col_len_align * cp_align_len <= ub_ele:
        return "split_row"
    elif cp_align_len * row_len <= ub_ele and n_i < device_core_num:
        return "split_col_fencore"
    elif cp_align_len * row_len <= ub_ele:
        return "split_col"
    elif n_i < device_core_num:
        return "large_fencore"
    else:
        return "large"


def _check_two_not_align_fp16(shape, perm, dtype):
    """
    check whether two not align fp16

    """
    if dtype != "float16":
        return False

    if perm != [0, 2, 1]:
        return False

    n_i, col_len, row_len = shape
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size

    if n_i > 50000 * device_core_num and col_len * row_len < 4 * cp_align_len:
        return False

    if col_len % cp_align_len > 0 and row_len % cp_align_len > 0:
        return True

    return False


def _choose_branch_two_not_align_fp16(shape, dtype):
    """
    choose which branch in two not align fp16

    """
    n_i, col_len, row_len = shape

    ub_bytes = UB_SIZE_B - 64
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    col_len_align = _ceil_fill(col_len, cp_align_len)
    row_len_align = _ceil_fill(row_len, cp_align_len)
    dim_ele = _ceil_fill(col_len * row_len, 16) * 16
    new_space_ele_split_row = _ceil_fill(col_len * 16, 16) * 16
    new_space_ele_split_col = _ceil_fill(row_len * 16, 16) * 16

    true_dim_ele = col_len * row_len

    device_core_num = AICORE_NUM

    if true_dim_ele < cp_align_len:
        return "little"
    elif dim_ele <= ub_ele:
        num_dim_ub = ub_ele // dim_ele
        num_dim_group = num_dim_ub * device_core_num
        if num_dim_group <= n_i and num_dim_ub > 1:
            return "small_multidim"
        else:
            return "small"
    elif col_len_align * cp_align_len <= ub_ele \
            and new_space_ele_split_row <= ub_ele \
            and n_i < device_core_num:
        return "split_row_new_fencore"
    elif col_len_align * cp_align_len <= ub_ele\
            and new_space_ele_split_row <= ub_ele:
        return "split_row_new"
    elif row_len_align * cp_align_len <= ub_ele \
            and new_space_ele_split_col <= ub_ele \
            and n_i < device_core_num:
        return "split_col_new_fencore"
    elif row_len_align * cp_align_len <= ub_ele\
            and new_space_ele_split_col <= ub_ele:
        return "split_col_new"
    elif col_len_align * cp_align_len <= ub_ele and n_i < device_core_num:
        return "split_row_fencore"
    elif col_len_align * cp_align_len <= ub_ele:
        return "split_row"
    elif cp_align_len * row_len_align <= ub_ele and n_i < device_core_num:
        return "split_col_fencore"
    elif cp_align_len * row_len_align <= ub_ele:
        return "split_col"
    elif n_i < device_core_num:
        return "large_fencore"
    else:
        return "large"


def _check_two_fp32(perm, dtype):
    """
    check whether two fp32

    """
    if dtype != "float32":
        return False

    if perm != [0, 2, 1]:
        return False

    return True


def _choose_branch_two_fp32(shape, dtype):
    """
    choose which branch in two fp32

    """
    n_i, col_len, row_len = shape
    ub_bytes = UB_SIZE_B - 64
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    dim_ele = col_len * row_len
    dim_ele_two = col_len * row_len * 2
    dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
    space_ele = dim_ele_two_align * 8

    new_space_split_row_fp32 = col_len * 8 * 2 * 8
    new_space_split_col_fp32 = row_len * 8 * 2 * 8

    device_core_num = AICORE_NUM

    if dim_ele < cp_align_len:
        return "little"
    elif space_ele <= ub_ele:
        dim_space = col_len * row_len * 2 * 8
        if dim_space < ub_ele:
            num_dim_one_core = ub_ele // dim_space
            num_dim_one_group = num_dim_one_core * device_core_num
            if num_dim_one_group <= n_i and num_dim_one_core > 1:
                return "little"
            else:
                return "small"
        else:
            return "small"
    elif new_space_split_row_fp32 <= ub_ele and n_i < device_core_num:
        return "split_row_fencore"
    elif new_space_split_row_fp32 <= ub_ele:
        return "split_row"
    elif new_space_split_col_fp32 <= ub_ele and n_i < device_core_num:
        return "split_col_fencore"
    elif new_space_split_col_fp32 <= ub_ele:
        return "split_col"
    elif n_i < device_core_num:
        return "large_fencore"
    else:
        return "large"


def _update_shape_side_one(shape):
    value_shape = functools_reduce(lambda x, y: x * y, shape[:])
    shape_new = [value_shape]
    perm_new = [0]
    shape_res_new = [value_shape]

    return shape_new, perm_new, shape_res_new


def _check_side_one(shape, perm, shape_res):
    """
    check whether side one branch

    """
    if perm == [0, 2, 1]:
        if shape[1] == 1 or shape[2] == 1:
            return _update_shape_side_one(shape)

    if perm == [1, 0, 2]:
        if shape[0] == 1 or shape[1] == 1:
            return _update_shape_side_one(shape)
        else:
            one_d = 1
            two_d = shape[0]
            three_d = shape[1]
            four_d = shape[2]
            shape_new = [one_d, two_d, three_d, four_d]
            perm_new = [0, 2, 1, 3]
            shape_res_new = _get_perm_shape(shape_new, perm_new)
            return shape_new, perm_new, shape_res_new

    if perm == [0, 2, 3, 1]:
        if shape[1] == 1 or shape[2] * shape[3] == 1:
            return _update_shape_side_one(shape)
        else:
            shape_new, perm_new = _update_shape_perm(shape, perm)
            shape_res_new = _get_perm_shape(shape_new, perm_new)
            return shape_new, perm_new, shape_res_new

    if perm == [0, 3, 1, 2]:
        if shape[1] * shape[2] == 1 or shape[3] == 1:
            return _update_shape_side_one(shape)
        else:
            shape_new, perm_new = _update_shape_perm(shape, perm)
            shape_res_new = _get_perm_shape(shape_new, perm_new)
            return shape_new, perm_new, shape_res_new

    if perm == [1, 0]:
        if shape[0] == 1 or shape[1] == 1:
            return _update_shape_side_one(shape)
        else:
            shape_new, perm_new = _update_shape_perm(shape, perm)
            shape_res_new = _get_perm_shape(shape_new, perm_new)
            return shape_new, perm_new, shape_res_new

    if perm == [0, 1, 3, 2]:
        if shape[2] == 1 or shape[3] == 1:
            return _update_shape_side_one(shape)
        else:
            shape_new, perm_new = _update_shape_perm(shape, perm)
            shape_res_new = _get_perm_shape(shape_new, perm_new)
            return shape_new, perm_new, shape_res_new

    if perm == [0, 1, 2, 4, 3]:
        if shape[3] == 1 or shape[4] == 1:
            return _update_shape_side_one(shape)
        else:
            shape_new, perm_new = _update_shape_perm(shape, perm)
            shape_res_new = _get_perm_shape(shape_new, perm_new)
            return shape_new, perm_new, shape_res_new

    if perm == [2, 0, 1]:
        if shape[0] * shape[1] == 1 or shape[2] == 1:
            return _update_shape_side_one(shape)
        else:
            shape_new, perm_new = _update_shape_perm(shape, perm)
            shape_res_new = _get_perm_shape(shape_new, perm_new)
            return shape_new, perm_new, shape_res_new

    return shape, perm, shape_res


def _check_0213(shape, perm, dtype):
    """
    check whether 0213 branch

    """
    if perm != [0, 2, 1, 3]:
        return False

    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    n_i, one_d, two_d, three_d = shape
    if n_i < device_core_num:
        return False

    if three_d >= cp_align_len:
        return False

    shape_ele = one_d * two_d * three_d
    if shape_ele <= cp_align_len:
        return False

    shape_ele_align = _ceil_fill(shape_ele, cp_align_len)
    if shape_ele_align < ub_ele:
        return True

    return False


def _check_0213_sp1(shape, perm, dtype):
    """
    check whether 0213 special one branch

    """
    if shape != [1, 128, 12, 64] or perm != [0, 2, 1, 3]\
            or dtype != "float16":
        return False

    device_core_num = AICORE_NUM
    if device_core_num < 2:
        return False

    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // float_size // cp_align_len) * cp_align_len
    one_d, two_d, three_d, four_d = shape
    half_two = two_d // 2
    dim_ele = half_two * three_d * four_d

    if dim_ele > ub_ele:
        return False

    return True


def _check_0213_12_30_26(shape, perm, dtype):
    """
    check whether 0213 special one branch

    """
    if len(shape) != 4:
        return False

    if perm != [0, 2, 1, 3]:
        return False

    if dtype != "float16" and dtype != "float32":
        return False

    shape_sub = shape[1:]

    if shape_sub != [12, 30, 26] and shape_sub != [30, 12, 26]:
        return False

    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    _, two_d, three_d, four_d = shape

    if dtype == "float16":
        split_zu = 3
        split_three = three_d // split_zu
        all_ele = two_d * split_three * four_d
        all_ele_align = _ceil_fill(all_ele, cp_align_len)
        space_ele = all_ele_align * cp_align_len

        if space_ele <= ub_ele:
            return True
    elif dtype == "float32":
        split_zu = 6
        split_three = three_d // split_zu
        all_ele = two_d * split_three * four_d * 2
        all_ele_align = _ceil_fill(all_ele, cp_align_len)
        space_ele = all_ele_align * cp_align_len

        if space_ele <= ub_ele:
            return True

    return False


def _check_0213_vec(shape, perm, dtype):
    """
    check whether 0213 vec branch

    """
    if len(shape) != 4:
        return False

    if perm != [0, 2, 1, 3] or dtype != "float16":
        return False

    one_d, two_d, three_d, four_d = shape
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size

    if four_d % cp_align_len == 0:
        return False

    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    all_ele = two_d * three_d * four_d
    small_ele = _ceil_fill(all_ele, 16) * cp_align_len
    if small_ele <= ub_ele:
        if all_ele < cp_align_len:
            return False
        return True

    if two_d > three_d:
        all_ele = three_d * four_d
        mid_two_ele = _ceil_fill(all_ele, 16) * cp_align_len
        if mid_two_ele <= ub_ele:
            two_ub = ub_ele // mid_two_ele
            move_len = four_d * two_ub
            if move_len >= cp_align_len:
                return True
            else:
                change_len = two_d * four_d
                mid_one_ele = _ceil_fill(change_len, 16) * cp_align_len
                if mid_one_ele <= ub_ele:
                    if change_len < cp_align_len:
                        return False
                    return True

    else:
        all_ele = two_d * four_d
        mid_one_ele = _ceil_fill(all_ele, 16) * cp_align_len
        if mid_one_ele <= ub_ele:
            if all_ele >= cp_align_len:
                return True
            else:
                change_ele = three_d * four_d
                mid_two_ele = _ceil_fill(change_ele, 16) * cp_align_len
                if mid_two_ele <= ub_ele:
                    two_ub = ub_ele // mid_two_ele
                    move_len = four_d * two_ub
                    if move_len < cp_align_len:
                        return False
                    return True

    return False


def _choose_branch_0213_vec(shape, dtype):
    """
    choose whether 0213 vec branch

    """
    one_d, two_d, three_d, four_d = shape
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    small_ele = _ceil_fill(two_d * three_d * four_d, 16) * cp_align_len
    if small_ele <= ub_ele:
        return "small_ele"

    if two_d > three_d:
        all_ele = three_d * four_d
        mid_two_ele = _ceil_fill(all_ele, 16) * cp_align_len
        if mid_two_ele <= ub_ele:
            two_ub = ub_ele // mid_two_ele
            move_len = four_d * two_ub
            if move_len >= cp_align_len:
                if one_d < AICORE_NUM:
                    return "mid_two_ele_fencore"
                else:
                    return "mid_two_ele"
            else:
                change_len = two_d * four_d
                mid_one_ele = _ceil_fill(change_len, 16) * cp_align_len
                if mid_one_ele <= ub_ele:
                    if one_d < AICORE_NUM:
                        return "mid_one_ele_fencore"
                    else:
                        return "mid_one_ele"

    else:
        all_ele = two_d * four_d
        mid_one_ele = _ceil_fill(all_ele, 16) * cp_align_len
        if mid_one_ele <= ub_ele:
            if all_ele >= cp_align_len:
                if one_d < AICORE_NUM:
                    return "mid_one_ele_fencore"
                else:
                    return "mid_one_ele"
            else:
                change_ele = three_d * four_d
                mid_two_ele = _ceil_fill(change_ele, 16) * cp_align_len
                if mid_two_ele <= ub_ele:
                    two_ub = ub_ele // mid_two_ele
                    move_len = four_d * two_ub
                    if move_len >= cp_align_len:
                        if one_d < AICORE_NUM:
                            return "mid_two_ele_fencore"
                        else:
                            return "mid_two_ele"


# pylint: disable=locally-disabled,too-many-locals,too-many-arguments
@util.check_input_type(dict, dict, (list, tuple), str)
def transpose_d(input_x, output_y, perm, kernel_name="transpose_d"):
    """
    algorithm: transpose
    calculating: permute the dimensions according to perm

    Parameters
    ----------
    input_x : dict
        shape and dtype of input
    output_y: dict
        shape and dtype of output, should be same shape and type as input
    perm: list or tuple
        permutation of the dimension of tensor
    kernel_name: str
        cce kernel name, default value is "transpose_d"

    Returns
    -------
    None
    """
    shape = list(input_x.get("shape"))
    dtype = input_x.get("dtype").lower()
    _check_params(shape, perm, dtype, kernel_name)
    perm = list(perm)

    if list(perm) == [0, 3, 4, 1, 2]:
        perm = [0, 2, 3, 1]
        one_dim = shape[0]
        two_dim = shape[1]*shape[2]
        three_dim = shape[3]
        four_dim = shape[4]
        shape = [one_dim, two_dim, three_dim, four_dim]

    elif list(perm) == [3, 2, 0, 1]:
        if shape[3] == 1:
            one_dim = shape[0] * shape[1]
            two_dim = shape[2]
            shape = [one_dim, two_dim]
            perm = [1, 0]

    elif list(perm) == [0, 3, 1, 2, 4]:
        one_dim = shape[0]
        two_dim = shape[1] * shape[2]
        three_dim = shape[3]
        four_dim = shape[4]
        shape = [one_dim, two_dim, three_dim, four_dim]
        perm = [0, 2, 1, 3]

    shape_res = _get_perm_shape(shape, perm)
    shape, perm, shape_res = _check_side_one(shape, perm, shape_res)

    if _check_two_permute_align_fp16(shape, perm, dtype):
        branch_per = _choose_branch_two_permute_align_fp16(shape, dtype)
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        if branch_per == "small":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_permute_align_small_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_permute_align_split_row_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_permute_align_split_col_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "large":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_permute_align_large_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_permute_align_split_row_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_permute_align_split_col_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        else:
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_permute_align_large_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif _check_two_col_align_fp16(shape, perm, dtype):
        branch_per = _choose_branch_two_col_align_fp16(shape, dtype)
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        if branch_per == "little":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_little_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "small":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_small_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_split_row_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col_new":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_split_col_fp16_new(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_split_col_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "large":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_large_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_split_row_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col_new_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_split_col_fp16_new_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_split_col_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        else:
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_large_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif _check_two_row_align_fp16(shape, perm, dtype):
        branch_per = _choose_branch_two_row_align_fp16(shape, dtype)
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        if branch_per == "little":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_row_align_little_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "small":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_row_align_small_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row_new":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_row_align_split_row_fp16_new(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        elif branch_per == "split_row":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_row_align_split_row_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        elif branch_per == "split_col":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_row_align_split_col_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "large":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_row_align_large_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row_new_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_row_align_split_row_fp16_new_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        elif branch_per == "split_row_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_row_align_split_row_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        elif branch_per == "split_col_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_row_align_split_col_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        else:
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_row_align_large_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif _check_two_not_align_fp16(shape, perm, dtype):
        branch_per = _choose_branch_two_not_align_fp16(shape, dtype)
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        if branch_per == "little":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_little_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "small":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_small_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "small_multidim":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_small_multidim_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row_new":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_split_row_fp16_new(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col_new":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_split_col_fp16_new(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        elif branch_per == "split_row":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_split_row_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        elif branch_per == "split_col":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_split_col_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "large":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_not_align_large_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row_new_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_split_row_fp16_new_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col_new_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_split_col_fp16_new_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        elif branch_per == "split_row_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_split_row_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        elif branch_per == "split_col_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_split_col_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        else:
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_large_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif _check_two_fp32(perm, dtype):
        branch_per = _choose_branch_two_fp32(shape, dtype)
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        if branch_per == "little":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_little_fp32(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "small":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_small_fp32(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_split_row_fp32(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_split_col_fp32(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "large":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_large_fp32(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_split_row_fp32_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_split_col_fp32_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        else:
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_large_fp32_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif _check_0213_sp1(shape, perm, dtype):
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        res = tvm.extern(shape_res, [data],
                         lambda ins, outs: _move_0213_sp1(
                             outs[0], ins[0]),
                         name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)
    elif _check_0213_12_30_26(shape, perm, dtype):
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        if dtype == "float16":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _move_0213_12_30_26_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif dtype == "float32":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _move_0213_12_30_26_fp32(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif _check_0213_vec(shape, perm, dtype):
        branch = _choose_branch_0213_vec(shape, dtype)
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        if branch == "small_ele":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _move_0213_vec_small(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch == "mid_two_ele":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _move_0213_vec_mid_two(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch == "mid_two_ele_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _move_0213_vec_mid_two_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch == "mid_one_ele":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _move_0213_vec_mid_one(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch == "mid_one_ele_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _move_0213_vec_mid_one_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif _check_0213(shape, perm, dtype):
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        res = tvm.extern(shape_res, [data],
                         lambda ins, outs: _move_0213_small_dim(
                             outs[0], ins[0]),
                         name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif _check_two_dim(perm, dtype):
        shape_new = _update_shape_10(shape, perm)
        perm_new = [0, 2, 1]
        shape_res = _get_perm_shape(shape_new, perm_new)
        data = tvm.placeholder(shape_new, dtype=dtype, name="data")
        branch_10, core_divide = _get_branch_10(shape_new, dtype)

        if branch_10 == "more_two_dim":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _more_two_dim_ir_10(outs[0],
                                                                   ins[0],
                                                                   core_divide),
                             name="res", dtype=dtype)
        elif branch_10 == "more_dim":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _more_dim_ir_10(outs[0],
                                                               ins[0],
                                                               core_divide),
                             name="res", dtype=dtype)
        elif branch_10 == "split_dim":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _split_dim_ir_10(outs[0],
                                                                ins[0],
                                                                core_divide),
                             name="res", dtype=dtype)
        else:
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _large_two_dim_ir_10(outs[0], ins[0],
                                                  core_divide),
                             name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)
    elif _check_shape_102(shape, perm, dtype):
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        res = tvm.extern(shape_res, [data],
                         lambda ins, outs: _small_shape_ir_102(outs[0],
                                                               ins[0]),
                         name="res", dtype=dtype)
        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif list(perm) == [0, 2, 3, 1]:
        if _check_sp_0231_fp32(shape, dtype):
            row_len = shape[1]
            row_zu = _get_row_zu(row_len, dtype)
            data = tvm.placeholder(shape, dtype=dtype, name="data")
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _mov_0231_256_vconv_fp32(outs[0], ins[0], row_zu),
                             name="res", dtype=dtype)
        else:
            data = tvm.placeholder(shape, dtype=dtype, name="data")
            branch_0231, core_divide = _get_branch_0231(shape, dtype)
            if branch_0231 == "more_row_ir_0231":
                res = tvm.extern(shape_res, [data],
                                 lambda ins, outs:
                                 _more_row_ir_0231(outs[0], ins[0],
                                                   core_divide),
                                 name="res", dtype=dtype)
            elif branch_0231 == "one_row_ir_0231":
                res = tvm.extern(shape_res, [data],
                                 lambda ins, outs:
                                 _one_row_ir_0231(outs[0], ins[0],
                                                  core_divide),
                                 name="res", dtype=dtype)
            else:
                res = tvm.extern(shape_res, [data],
                                 lambda ins, outs:
                                 _split_row_ir_0231(outs[0], ins[0],
                                                    core_divide),
                                 name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)
    elif list(perm) == [0, 3, 1, 2]:
        if _check_sp_0312_fp32(shape, dtype):
            row_len = shape[3]
            row_zu = _get_row_zu(row_len, dtype)
            data = tvm.placeholder(shape, dtype=dtype, name="data")
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _mov_0312_256_vconv_fp32(outs[0], ins[0], row_zu),
                             name="res", dtype=dtype)
        else:
            data = tvm.placeholder(shape, dtype=dtype, name="data")
            branch_0312 = _get_branch_0312(shape, dtype)

            if branch_0312 == "more_dim_0312":
                res = tvm.extern(shape_res, [data],
                                 lambda ins, outs: _more_dim_ir_0312(outs[0],
                                                                     ins[0]),
                                 name="res", dtype=dtype)
            elif branch_0312 == "one_dim_0312":
                res = tvm.extern(shape_res, [data],
                                 lambda ins, outs: _one_dim_ir_0312(outs[0],
                                                                    ins[0]),
                                 name="res", dtype=dtype)
            elif branch_0312 == "one_dim_0312_small":
                res = tvm.extern(shape_res, [data],
                                 lambda ins, outs: _one_dim_ir_0312_small(
                                     outs[0],
                                     ins[0]),
                                 name="res", dtype=dtype)
            elif branch_0312 == "split_dim_0312":
                res = tvm.extern(shape_res, [data],
                                 lambda ins, outs: _split_dim_ir_0312(outs[0],
                                                                      ins[0]),
                                 name="res", dtype=dtype)
            else:
                res = tvm.extern(shape_res, [data],
                                 lambda ins, outs: _split_dim_ir_0312_small(
                                     outs[0],
                                     ins[0]),
                                 name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    else:
        num = 0
        total_size = []
        if len(shape) - 1 == perm[-1]:
            shape_up, perm_up = _update_shape_for_notchange_last(shape, perm)
            shape_res_up = _get_perm_shape(shape_up, perm_up)
            data = tvm.placeholder(shape_up, dtype=dtype, name="data")
            sch, tensor_list = _tranpose_notchange_last(data, shape_res_up,
                                                        perm_up, dtype)
        elif _add_last_axis(shape, perm, dtype):
            shape_update = list(shape)
            shape_res_update = list(shape_res)
            perm_update = list(perm)
            shape_update.append(1)
            shape_res_update.append(1)
            perm_update.append(len(shape))
            data = tvm.placeholder(shape_update, dtype=dtype, name="data")
            sch, tensor_list = _tranpose_notchange_last(data, shape_res_update,
                                                        perm_update, dtype)
        else:
            data = tvm.placeholder(shape, dtype=dtype, name="data")
            sch, tensor_list, num, total_size =\
                _transpose_change_last(data, shape, shape_res, perm, dtype)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

        if num > 0:
            workspace_dict = {"workspace": {"num": num, "size": total_size}}
            _write_code(workspace_dict, "kernel_meta/" + kernel_name + ".json")
